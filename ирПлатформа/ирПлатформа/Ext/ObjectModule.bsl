Перем ирМобильный Экспорт;
Перем ирОбщий Экспорт;
Перем ирСервер Экспорт;
Перем ирКэш Экспорт;
Перем ирПривилегированный Экспорт;

Перем ЧистыйКонтекст;
Перем ФиксироватьВнешниеИсключенияАлгоритмов Экспорт;
Перем ВерсияПлатформы Экспорт;
Перем ЭтоФайловаяБаза Экспорт;
Перем мМетаданные Экспорт;
Перем Это2iS Экспорт;
Перем ЭтоИнтеграция Экспорт;
Перем СоответствиеВидовСравнения Экспорт;
Перем МаркерНачалаАлгоритма Экспорт;
Перем МаркерКонцаАлгоритма Экспорт;
Перем МакетыКомпонент Экспорт;
Перем мКэшПустыхЗначений Экспорт;
Перем ВложенностьИндикации Экспорт;
Перем КэшОбъектов Экспорт;
Перем ВремяОбъект Экспорт;
Перем ИДВерсииПлатформы Экспорт;
Перем АрхитектураПроцессора Экспорт;
Перем ИсполнительСкрытыхКомандСистемы Экспорт;
Перем СодержанияАрхивовСправки Экспорт;
Перем ИндексыАрхивовСправки Экспорт;
Перем ВыполнятьАлгоритмыЧерезВнешниеОбработки Экспорт;
Перем ВнешняяОбработкаСервисы Экспорт;
Перем ФайловыйКэшАлгоритмовДопускаетРедактирование Экспорт;
//Перем ТекстПотокаСИменемВнешнейОбработки;
//Перем ТекстПотокаСИменемВнешнейОбработкиСМакетом;
//Перем ФайлСИменемВнешнейОбработки;
//Перем ФайлСИменемВнешнейОбработкиСМакетом;
////Перем КешВнешнихОбработокАлгоритмов;
Перем КешАлгоритмов;
Перем СубПутьКФайлуПотокаМодуляВнешнейОбработки;
Перем СубПутьКФайлуПотокаМакетаВнешнейОбработки;
Перем СубПутьКФайлуПотокаЗаголовкаВнешнейОбработки;
Перем СубПутьККонтрольномуФайлуВнешнейОбработки;
Перем ПутьККаталогуСлужебныхВременныхФайлов;
//Перем ФайлЗамокШаблона;
//Перем ФайлЗамокШаблонаСМакетом;
Перем ПапкаКешаВнешнихОбработокАлгоритмов Экспорт;
Перем ПапкаКешаВнешнихОбработокАрхива Экспорт;
Перем ПапкаВнешнихКомпонент Экспорт;
Перем МаскироватьФайловыйКэш Экспорт;
Перем КаталогФайловогоКэша Экспорт;
Перем СтруктураПодкаталоговФайловогоКэша Экспорт;
Перем ИмяФайлаПакера Экспорт;
Перем ШаблоныВнешнейОбработки;
Перем ШаблоныВнешнейОбработкиСМакетом;
Перем ФайлРегистратораКомпонент Экспорт;
Перем МассивСравненияТекстов Экспорт;
Перем ОбъектыМДПоПолномуИмени Экспорт;

Перем WshShell Экспорт;
Перем WinAPI Экспорт;
Перем RegExp Экспорт;
Перем RegExp2 Экспорт;
Перем VBRegExp;

Перем шБуква Экспорт;
Перем шИмя Экспорт;
Перем шЧисло Экспорт;
Перем шИндекс Экспорт;
Перем шСкобки Экспорт;
Перем шGUID Экспорт;
Перем шКомментарий Экспорт;
Перем шРазделитель Экспорт;

Перем МаркерОбъектаМетаданных;
Перем МаркерКоллекцииОбъектовМетаданных;
Перем МаркерCOMОбъекта Экспорт;

//#Если Клиент Или ВнешнееСоединение Тогда
Перем ИдентификаторПроцессаОС Экспорт;
Перем VBScript Экспорт;
Перем JavaScript Экспорт;
Перем ДеревоТипов Экспорт;
Перем ТаблицаОбщихТипов Экспорт;
Перем ТаблицаИменЭлементовКоллекций Экспорт;
Перем ТаблицаКонтекстов Экспорт;
Перем ТаблицаРасширенийТипов Экспорт;
Перем ТаблицаШаблоновКонтекстов Экспорт;
Перем ТаблицаТиповМетаОбъектов Экспорт;
Перем ТаблицаПараметров Экспорт;
Перем СлужебноеПолеТекстовогоДокумента Экспорт;
Перем СлужебноеПолеHtmlДокумента Экспорт;
Перем МассивОбычныхЭлементовУправления Экспорт;
Перем МассивУправляемыхЭлементовУправления Экспорт;
Перем мМассивТиповЭлементовУправления Экспорт;
Перем ТаблицаСтатистикиВыбора Экспорт;
Перем мМассивТиповВключающихМетаданные Экспорт;
Перем мТаблицаСтруктурТипа; // Образец таблицы структур типа
Перем мТаблицаСоответствияВидов;
Перем мТаблицаЗамеров Экспорт;
Перем мТаблицаИндикаторов Экспорт;
Перем мИменаОсновныхКлассовБиблиотекCOM; // Кэш имен классов, например Exel - Application
Перем мОбразцыCOMОбъектов; // Для вычисления свойств
Перем мADOUtils; // GameWithFire.ADOUtils

Перем СлужебнаяФорма;
Перем COMНавигатор Экспорт;
Перем ТаблицаШаблоновТекста Экспорт;
Перем КартинкиТипов;

Перем МассивИсключенийИменКоллекций;

Перем ФайлЗапаковщика1С Экспорт;
Перем ФайлБиблиотекиЗапаковщика;
Перем ФайлОткрывателя1С Экспорт;
Перем ФайлРаспаковщикаZIP Экспорт;
Перем ФайлСтилейСинтаксПомощника Экспорт;
Перем АрхивСинтаксПомощника Экспорт;
Перем Парсеры;
Перем БуферСравнения Экспорт;

Перем ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов Экспорт;
Перем СинтаксическийКонтрольПередЗаписью Экспорт;
Перем ОтложенноеОткрытиеИсточникаОшибки Экспорт;
Перем ЛиНизкоуровневоеПолучениеОписанийОбъектов Экспорт;

///////////////////////////////////////////////////////////////////
// Информатор. Начало

Перем ScrptCtrl;
Перем ИМЯ_КЛАССА_DynamicWrapperX;
Перем СТРОКА_ОПИСАНИЕ_МЕТОДА_БЕЗ_ПАРАМЕТРОВ Экспорт;
Перем СТРОКА_МЕТОДЫ Экспорт;
Перем СТРОКА_СВОЙСТВА Экспорт;
Перем СТРОКА_ГЛОБАЛЬНЫЙ_КОНТЕКСТ;

//Флаг = 0 - проверить, есть ли хотя бы одно(-ин) свойство/метод
//Флаг = 1 - проверить, есть ли хотя бы одно свойство
//Флаг = 2 - проверить, есть ли хотя бы один метод
//Флаг = 3 - заполнить свойства
//Флаг = 4 - заполнить методы
Перем	ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ_И_МЕТОДОВ Экспорт;
Перем	ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ;
Перем	ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_МЕТОДОВ;
Перем	ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_СВОЙСТВА;
Перем	ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_МЕТОДЫ;

// Информатор. Конец
///////////////////////////////////////////////////////////////////


// Инициализирует, если необходимо, большие таблицы платформы.
// К ним относятся таблицы методов и свойств.
//
// Параметры:
//  Нет.
//
Процедура ИнициализацияОписанияМетодовИСвойств() Экспорт

	Если ТипЗнч(ТаблицаКонтекстов) = Тип("ТаблицаЗначений") Тогда
		Возврат;
	КонецЕсли;
	#Если Клиент Тогда	
		Состояние("Инициализация таблицы методов и свойств...");
	#КонецЕсли
	МассивТаблиц = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ТаблицаМетодовИСвойств").ПолучитьТекст());
	ТаблицаКонтекстов = МассивТаблиц.ТаблицаКонтекстов;
	ТаблицаКонтекстов.Индексы.Добавить("ТипКонтекста");
	ТаблицаКонтекстов.Индексы.Добавить("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка");
	ТаблицаШаблоновКонтекстов = МассивТаблиц.ТаблицаШаблоновКонтекстов;
	ТаблицаШаблоновКонтекстов.Индексы.Добавить("ТипКонтекста");
	ТаблицаШаблоновКонтекстов.Индексы.Добавить("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка");
		
	#Если Клиент Тогда
		Состояние("");
	#КонецЕсли

КонецПроцедуры

// Инициализирует, если необходимо, малые таблицы платформы.
// К ним относятся таблицы типов и коллекций.
// 
// Параметры:
//  Нет.
//
Процедура ИнициализацияОписанияПараметровИТипов() Экспорт

	Если ТипЗнч(ТаблицаОбщихТипов) = Тип("ТаблицаЗначений") Тогда
		Возврат;
	КонецЕсли;
	МассивТаблиц = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ТаблицаИменЭлементовКоллекций").ПолучитьТекст());
	ТаблицаИменЭлементовКоллекций = МассивТаблиц.ТаблицаИменЭлементовКоллекций;
	ТаблицаИменЭлементовКоллекций.Индексы.Добавить("ИмяКоллекции");
	ТаблицаИменЭлементовКоллекций.Индексы.Добавить("ИмяЭлементаКоллекции");
	ТаблицаИменЭлементовКоллекций.Индексы.Добавить("ИмяОбщегоТипа, ИмяЭлементаКоллекции");
	ТаблицаРасширенийТипов = МассивТаблиц.ТаблицаРасширений;
	ТаблицаРасширенийТипов.Индексы.Добавить("Расширение");
	МассивТаблиц = ЗначениеИзСтрокиВнутр(ПолучитьМакет("ТаблицаПараметровИТипов").ПолучитьТекст());
	ТаблицаОбщихТипов = МассивТаблиц.ТаблицаОбщихТипов;
	ТаблицаОбщихТипов.Индексы.Добавить("Слово, ЯзыкПрограммы");
	ТаблицаОбщихТипов.Индексы.Добавить("Слово, ТипТипа");
	//ТаблицаОбщихТипов.Индексы.Добавить("Слово, ЯзыкПрограммы, ТипТипа");
	ТаблицаОбщихТипов.Индексы.Добавить("Представление, ТипТипа");
	ТаблицаПараметров = МассивТаблиц.ТаблицаПараметров;
	ТаблицаПараметров.Индексы.Добавить("ТипКонтекста, ЯзыкПрограммы, Слово, Номер");
	
КонецПроцедуры 

// Добавляет дополнительные Свойства для типов контекстов платформы.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ДобавитьСловоВОписаниеТипаКонтекста(ТипКонтекста, Слово, ТипСлова, ТипЗначения) Экспорт 

	ИнициализацияОписанияМетодовИСвойств();
	НоваяСтрока = ТаблицаКонтекстов.Добавить();
	НоваяСтрока.ТипКонтекста = ТипКонтекста;
	НоваяСтрока.Слово        = Слово;
	НоваяСтрока.НСлово       = НРег(Слово);
	НоваяСтрока.ТипСлова     = ТипСлова;
	НоваяСтрока.ТипЗначения  = ТипЗначения;

КонецПроцедуры // ДобавитьСловоВОписаниеТипаКонтекста()

// Добавляет в список значений коллекцию объектов метаданных.
//
// Параметры:
//  пСписокМетаданных – СписокЗначений – куда добавляем объекты;
//  пИмяМетаданных – Строка – имя коллекции объектов метаданных или имя корневого типа;
//  *ЛиПолноеИмя - Булево, *Истина - добавлять полные имена, иначе краткие;
//  *ЛиДобавлятьКартинки - Булево, *Истина - добавлять картинки;
//  *ОтборПоПраву - Строка, *Неопределено - проверять перед добавлением право текущего пользователя.
//
Процедура ДобавитьВСписокКоллекциюМетаданных(пСписокМетаданных, пИмяМетаданных, ЛиПолноеИмя = Истина,
	ЛиДобавлятьКартинки = Истина, ОтборПоПраву = Неопределено) Экспорт
	
	Картинка = Неопределено;
	СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(пИмяМетаданных, , 0);
	Если СтрокаКорневогоТипа <> Неопределено Тогда
		ИмяКоллекцииМетаданных = СтрокаКорневогоТипа.Множественное;
		#Если Клиент Тогда
			Если ЛиДобавлятьКартинки Тогда 
				КорневойТип = пИмяМетаданных;
				Картинка = ирОбщий.ПолучитьКартинкуКорневогоТипаЛкс(КорневойТип);
			КонецЕсли;
		#КонецЕсли
	Иначе
		ИмяКоллекцииМетаданных = пИмяМетаданных;
		#Если Клиент Тогда
			Если ЛиДобавлятьКартинки Тогда 
				КорневойТип = ПолучитьСтрокуТипаМетаОбъектов(, пИмяМетаданных, 0).Единственное;
				Картинка = ирОбщий.ПолучитьКартинкуКорневогоТипаЛкс(КорневойТип);
			КонецЕсли;
		#КонецЕсли
	КонецЕсли;
	Для Каждого Объект ИЗ мМетаданные[ИмяКоллекцииМетаданных] Цикл
		Если Истина
			И ОтборПоПраву <> Неопределено
			И Не ПравоДоступа(ОтборПоПраву, Объект)
		Тогда
			Продолжить;
		КонецЕсли;
		Если ЛиПолноеИмя Тогда
			ИмяМетаОбъекта = Объект.ПолноеИмя();
		Иначе
			ИмяМетаОбъекта = Объект.Имя;
		КонецЕсли;
		пСписокМетаданных.Добавить(ИмяМетаОбъекта, Объект.Представление(), , Картинка);
	КонецЦикла;
	
КонецПроцедуры // ДобавитьВСписокКоллекциюМетаданных

// Получает список ключевых слов языка запросов.
//
// Параметры:
//  *Расширение  - Тип, *Неопределено - для определения расширения языка запросов.
//
// Возвращаемое значение:
//  СписокЗначений - где значение содержит слово.
//
Функция ПолучитьСписокКлючевыхСловЯзыкаЗапросов(РежимКомпоновкиДанных = Ложь, Русские = Истина, Английские = Ложь) Экспорт

	Список = Новый СписокЗначений;
	
	Если Русские Тогда
		Список.Добавить("АВТОУПОРЯДОЧИВАНИЕ");
		Список.Добавить("ВНУТРЕННЕЕ");
		Список.Добавить("ВОЗР");
		Список.Добавить("ВСЕ");
		Список.Добавить("ВЫБРАТЬ");
		Список.Добавить("ГДЕ");
		Список.Добавить("ДЛЯ");
		Список.Добавить("ИЗ");
		Список.Добавить("ИЗМЕНЕНИЯ");
		Список.Добавить("ИМЕЮЩИЕ");
		Список.Добавить("ИНДЕКСИРОВАТЬ");
		Список.Добавить("ИТОГИ");
		Список.Добавить("КАК");
		Список.Добавить("ЛЕВОЕ");
		Список.Добавить("ОБЩИЕ");
		Список.Добавить("ОБЪЕДИНИТЬ");
		Список.Добавить("ПЕРВЫЕ");
		Список.Добавить("ПО");
		Список.Добавить("ПОЛНОЕ");
		Список.Добавить("ПОМЕСТИТЬ");
		Список.Добавить("ПРАВОЕ");
		Список.Добавить("РАЗЛИЧНЫЕ");
		Список.Добавить("РАЗРЕШЕННЫЕ");
		Список.Добавить("СГРУППИРОВАТЬ");
		Список.Добавить("СОЕДИНЕНИЕ");
		Список.Добавить("УБЫВ");
		Список.Добавить("УНИЧТОЖИТЬ");
		Список.Добавить("УПОРЯДОЧИТЬ");
		
		Список.Добавить("НЕ");
		Список.Добавить("И");
		Список.Добавить("ИЛИ");
		Список.Добавить("ВЫБОР");
		Список.Добавить("КОГДА");
		Список.Добавить("ТОГДА");
		Список.Добавить("ИНАЧЕ");
		Список.Добавить("КОНЕЦ");
		Список.Добавить("ЕСТЬ");
		Список.Добавить("NULL");
		Список.Добавить("МЕЖДУ");
		Список.Добавить("В");
		Список.Добавить("ПОДОБНО");
		Список.Добавить("СПЕЦСИМВОЛ");
		Список.Добавить("ИЕРАРХИЯ");
		Список.Добавить("ИЕРАРХИИ");
		Список.Добавить("ССЫЛКА");
		
		Если РежимКомпоновкиДанных Тогда
			// Видимо это устаревшие слова
			Список.Добавить("ЗНАЧЕНИЕ");
			Список.Добавить("ЗНАЧЕНИЯ");
			Список.Добавить("ИДЕНТИФИКАТОР");
			Список.Добавить("ИМЯ");
			Список.Добавить("ОБЪЕКТ");
			Список.Добавить("СПИСОК");
			Список.Добавить("ТИПЗНАЧЕНИЯ");
			Список.Добавить("ХАРАКТЕРИСТИКА");
			// Это новые слова
			Список.Добавить("ЗНАЧЕНИЯХАРАКТЕРИСТИК");
			Список.Добавить("ПОЛЕИМЕНИ");
			Список.Добавить("ПОЛЕКЛЮЧА");
			Список.Добавить("ПОЛЕЗНАЧЕНИЯ");
			Список.Добавить("ПОЛЕВИДА");
			Список.Добавить("ПОЛЕТИПАЗНАЧЕНИЯ");
			Список.Добавить("ПОЛЕОБЪЕКТА");
			Список.Добавить("ВИДЫХАРАКТЕРИСТИК");
		КонецЕсли;
	КонецЕсли; 
	Если Английские Тогда
		Список.Добавить("AUTOORDER");
		Список.Добавить("INNER");
		Список.Добавить("ASC");
		Список.Добавить("ALL");
		Список.Добавить("SELECT");
		Список.Добавить("WHERE");
		Список.Добавить("FOR");
		Список.Добавить("FROM");
		Список.Добавить("UPDATE");
		Список.Добавить("HAVING");
		Список.Добавить("INDEX");
		Список.Добавить("TOTALS");
		Список.Добавить("AS");
		Список.Добавить("LEFT");
		//Список.Добавить("ОБЩИЕ"); // ЗАБЫЛ перевод
		Список.Добавить("UNION");
		Список.Добавить("FIRST");
		Список.Добавить("BY");
		Список.Добавить("ON");
		Список.Добавить("FULL");
		Список.Добавить("INTO");
		Список.Добавить("RIGHT");
		Список.Добавить("DISTINCT");
		Список.Добавить("ALLOWED");
		Список.Добавить("GROUP");
		Список.Добавить("JOIN");
		Список.Добавить("DESC");
		Список.Добавить("DROP");
		Список.Добавить("ORDER");
		
		Список.Добавить("NOT");
		Список.Добавить("AND");
		Список.Добавить("OR");
		Список.Добавить("CASE");
		Список.Добавить("WHEN");
		Список.Добавить("THEN");
		Список.Добавить("ELSE");
		Список.Добавить("END");
		Список.Добавить("IS");
		Список.Добавить("NULL");
		Список.Добавить("BETWEEN");
		Список.Добавить("IN");
		Список.Добавить("LIKE");
		Список.Добавить("СПЕЦСИМВОЛ");
		Список.Добавить("HIERARCHY");
		Список.Добавить("REFS");
		
		//Если РежимКомпоновкиДанных Тогда
		//	// Видимо это устаревшие слова
		//	Список.Добавить("VALUE");
		//	Список.Добавить("VALUES");
		//	Список.Добавить("IDENTIFICATOR");
		//	Список.Добавить("NAME");
		//	Список.Добавить("OBJECT");
		//	Список.Добавить("LIST");
		//	Список.Добавить("VALUETYPE");
		//	Список.Добавить("CHARACTERISTIC");
		//	// Это новые слова
		//	Список.Добавить("ЗНАЧЕНИЯХАРАКТЕРИСТИК");
		//	Список.Добавить("ПОЛЕИМЕНИ");
		//	Список.Добавить("ПОЛЕКЛЮЧА");
		//	Список.Добавить("ПОЛЕЗНАЧЕНИЯ");
		//	Список.Добавить("ПОЛЕВИДА");
		//	Список.Добавить("ПОЛЕТИПАЗНАЧЕНИЯ");
		//	Список.Добавить("ПОЛЕОБЪЕКТА");
		//	Список.Добавить("ВИДЫХАРАКТЕРИСТИК");
		//КонецЕсли;
	КонецЕсли; 
	Возврат Список;
	
КонецФункции // ПолучитьСписокСловЯзыкаЗапросов()

// Получает список ключевых встроенного языка.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  СписокЗначений - где значение содержит слово.
//
Функция ПолучитьСписокКлючевыхСловВстроенногоЯзыка() Экспорт

	Список = Новый СписокЗначений;
	Список.Добавить("Возврат");
	Список.Добавить("ВызватьИсключение");
	Список.Добавить("Выполнить");
	Список.Добавить("Для");
	Список.Добавить("Если");
	Список.Добавить("И");
	Список.Добавить("Из");
	Список.Добавить("Или");
	Список.Добавить("Иначе");
	Список.Добавить("ИначеЕсли");
	Список.Добавить("Исключение");
	Список.Добавить("Каждого");
	Список.Добавить("КонецЕсли");
	Список.Добавить("КонецПопытки");
	Список.Добавить("КонецПроцедуры");
	Список.Добавить("КонецФункции");
	Список.Добавить("КонецЦикла");
	Список.Добавить("Не");
	Список.Добавить("Новый");
	Список.Добавить("Перейти");
	Список.Добавить("Перем");
	Список.Добавить("По");
	Список.Добавить("Пока");
	Список.Добавить("Попытка");
	Список.Добавить("Прервать");
	Список.Добавить("Продолжить");
	Список.Добавить("Процедура");
	Список.Добавить("Тогда");
	Список.Добавить("Функция");
	Список.Добавить("Цикл");
	Список.Добавить("Экспорт");
	
	//// Директивы препроцессора. Добавлено 28.01.2012
	//// Здесь им не место, т.к. по этому списку проверяется валидность имен переменных
	//Список.Добавить("Клиент");
	//Список.Добавить("Сервер");
	//Список.Добавить("ВнешнееСоединение");
	//Список.Добавить("ТолстыйКлиентУправляемоеПриложение");
	//Список.Добавить("ТолстыйКлиентОбычноеПриложение");
	//Список.Добавить("ТонкийКлиент");
	//Список.Добавить("ВебКлиент");
	
	Список.Добавить("Истина");
	Список.Добавить("Ложь");
	Список.Добавить("Неопределено");
	Список.Добавить("Null");
	Возврат Список;
	
КонецФункции // ПолучитьСписокСловЯзыкаЗапросов()

// Размаскирует обращения к временным таблицам в тексте запроса.
//
// Параметры:
//  ТекстЗапроса – Строка;
//  МассивВременныхТаблиц – Массив – элементами являются имена временных таблиц, замаскированных ранее.
//
// Возвращаемое значение:
//  Строка - новые текст запроса.
//
Функция РазмаскироватьВременныеТаблицы(ТекстЗапроса, МассивВременныхТаблиц) Экспорт 

	Если МассивВременныхТаблиц.Количество() = 0 Тогда
		Возврат ТекстЗапроса;
	КонецЕсли;
	// Допустимы 2 уровня скобок внутри имитатора временной таблицы.
	RegExp.Global = Истина;
	RegExp.MultiLine = Истина;
	RegExp.IgnoreCase = Истина;
	шИмяВременнойТаблицы = "";
	Для Каждого ПодмененнаяВременнаяТаблица Из МассивВременныхТаблиц Цикл
		шИмяВременнойТаблицы = шИмяВременнойТаблицы + "|" + ПодмененнаяВременнаяТаблица;
	КонецЦикла;
	шИмяВременнойТаблицы = Сред(шИмяВременнойТаблицы, 2);
	//RegExp.Pattern = "\(ВЫБРАТЬ(?:" + шСкобки + "|[^$\(\)])*?""ВременнаяТаблица"" = ""(" + шИмяВременнойТаблицы + ")""\)";
	RegExp.Pattern = "\(ВЫБРАТЬ(?:[^\(\)]*(?:" + шСкобки + "[^\(\)]*)*)""ВременнаяТаблица"" = ""(" 
		+ шИмяВременнойТаблицы + ")""\s*\)";
	НовыйТекстЗапроса = RegExp.Replace(ТекстЗапроса, "$2");
	Возврат НовыйТекстЗапроса;

КонецФункции // РазмаскироватьВременныеТаблицы()

// Получает текст запроса, где каждая временная таблица заменена своим имитатором.
//
// Параметры:
//  ОбъектЗапроса – Запрос;
//  *ТекстЗапроса  – Строка, *Неопределено;
//  *МассивВременныхТаблиц - Массив, *Неопределено - все подменяемые таблицы заносятся сюда.
//
// Возвращаемое значение:
//  Строка - новый текст запроса.
//
Функция ЗамаскироватьВременныеТаблицы(ОбъектЗапроса, Знач ТекстЗапроса = Неопределено,
	МассивВременныхТаблиц = Неопределено) Экспорт 

	Если ТекстЗапроса = Неопределено Тогда
		ТекстЗапроса = ОбъектЗапроса.Текст;
	КонецЕсли;
	ВременныйЗапрос = Новый Запрос;
	ВременныйЗапрос.МенеджерВременныхТаблиц = ОбъектЗапроса.МенеджерВременныхТаблиц;
	ПроверочныйЗапрос = Новый ПостроительЗапроса;
	
	//// Исключительная ситуация должна быть обработана сверху
	//ПараметрыЗапроса = ВременныйЗапрос.НайтиПараметры();

	Если ТипЗнч(МассивВременныхТаблиц) <> Тип("Массив") Тогда
		МассивВременныхТаблиц = Новый Массив;
	КонецЕсли; 
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстЗапроса);
	Пока Истина Цикл
		Попытка
			ПроверочныйЗапрос.Текст = ТекстЗапроса;
			//ПроверочныйЗапрос.НайтиПараметры();
			Прервать;
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			//ИмяВременнойТаблицы = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИнформацияОбОшибке.Причина.Описание, """", """");
			ИмяВременнойТаблицы = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИнформацияОбОшибке.Причина.Описание, "Таблица не найдена """, """", Ложь);
			Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
				ВременныйЗапрос.Текст = "ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы;
				Попытка
					КолонкиВременнойТаблицы = ВременныйЗапрос.Выполнить().Колонки;
				Исключение
					Прервать;
				КонецПопытки;
			КонецЕсли; 
			// В 8.2.15 такой прием лишен смысла, т.к. движок запросов потом не сможет обработать обращения к дочерним полям
			//Если Не ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
			//	ИмяВременнойТаблицы = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИнформацияОбОшибке.Причина.Описание, "Неверные параметры """, """", Ложь);
			//	Если ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
			//		Попытка
			//			КолонкиВременнойТаблицы = ОбъектЗапроса.Параметры[ИмяВременнойТаблицы].Колонки;
			//		Исключение
			//			Попытка
			//				КолонкиВременнойТаблицы = ВременныйЗапрос.Выполнить().Колонки;
			//			Исключение
			//				Прервать;
			//			КонецПопытки;
			//		КонецПопытки;
			//		ИмяВременнойТаблицы = "&" + ИмяВременнойТаблицы;
			//	КонецЕсли; 
			//КонецЕсли; 
			Если Не ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
				Прервать;
			КонецЕсли;
			ИмитаторВременнойТаблицы = ирОбщий.ПолучитьЗапросИмитаторКоллекцииПолейЛкс(КолонкиВременнойТаблицы) 
				+ " ГДЕ ""ВременнаяТаблица"" = """ + ИмяВременнойТаблицы +  """";
			КоординатыОбращения = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИнформацияОбОшибке.Причина.Описание, "{(", ")}");
			НомерСтроки = Число(ирОбщий.ПолучитьПервыйФрагментЛкс(КоординатыОбращения, ", "));    
			НомерКолонки = Число(ирОбщий.ПолучитьПоследнийФрагментЛкс(КоординатыОбращения, ","));
			СтрокаЗапроса = СтрПолучитьСтроку(ТекстЗапроса, НомерСтроки);
			ТекстПосле = Сред(СтрокаЗапроса, НомерКолонки + СтрДлина(ИмяВременнойТаблицы));
			СтрокаКАК = "КАК";
			Если Не ирОбщий.СтрокиРавныЛкс(Лев(СокрЛ(ТекстПосле), СтрДлина(СтрокаКАК)), СтрокаКАК) Тогда
				ТекстПосле = " КАК " + ИмяВременнойТаблицы + " " + ТекстПосле;
			КонецЕсли; 
			НоваяСтрока = Лев(СтрокаЗапроса, НомерКолонки - 1) + "(" + ИмитаторВременнойТаблицы + ")" + ТекстПосле;
			ТекстовыйДокумент.ЗаменитьСтроку(НомерСтроки, НоваяСтрока);
			ТекстЗапроса = ТекстовыйДокумент.ПолучитьТекст();
			МассивВременныхТаблиц.Добавить(ИмяВременнойТаблицы);
		КонецПопытки;
	КонецЦикла;
	Возврат ТекстЗапроса;

КонецФункции // ЗамаскироватьВременныеТаблицы()

// Результат - Массив
Функция НайтиВозможныеИменаВременныхТаблиц(ТекстЗапроса) Экспорт
	
	Имена = Новый Структура;
	RegExp.Global = Истина;
	RegExp.pattern = "(?:ИЗ|СОЕДИНЕНИЕ)\s+(" + шИмя + ")(?:\s|$|[^\._\d" + шБуква + "])";
	РезультатПоиска = RegExp.Execute(ТекстЗапроса);
	Для Каждого Вхождение Из РезультатПоиска Цикл
		Имена.Вставить(Вхождение.SubMatches(0));
	КонецЦикла;
	Результат = Новый Массив();
	Для Каждого КлючИЗначение Из Имена Цикл
		Результат.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Добавляет (или заменяет) предложение ПОМЕСТИТЬ в запросе.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса – Строка;
//  ИмяВременнойТаблицы – Строка.
//
// Возвращаемое значение:
//  Строка - исправленный текст запроса.
//
Функция ДобавитьПредложениеПоместитьВЗапрос(ТекстЗапроса, ИмяВременнойТаблицы) Экспорт 

	RegExp.Global = Истина;
	шСтрокаЗапроса       = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)";
	ШаблонПОМЕСТИТЬИЗ = "(" + шСтрокаЗапроса + ")|(" + шРазделитель + "+(?:" + "ПОМЕСТИТЬ" + шРазделитель + "+" + шИмя + шРазделитель + "+)"
		+ "|((?:ИЗ|ГДЕ|СГРУППИРОВАТЬ|УПОРЯДОЧИТЬ|ИМЕЮЩИЕ|ОБЪЕДИНИТЬ)" + шРазделитель + "+))|(.|\r|\n)";
	RegExp.Pattern = ШаблонПОМЕСТИТЬИЗ;
	Результат = RegExp.Execute(ТекстЗапроса);
	Текст = "";
	ПредложениеДобавлено = Ложь;
	Для Каждого Match Из Результат Цикл
		Если Ложь
			Или ПредложениеДобавлено
			Или Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match.SubMatches(0))
			Или Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match.SubMatches(3))
		Тогда
			Текст = Текст + Match.Value;
		Иначе
			Текст = Текст + "
			|ПОМЕСТИТЬ
			|	" + ИмяВременнойТаблицы;
			Если Match.SubMatches(2) <> 0 Тогда // Видимо здесь ошибка
				Текст = Текст + Символы.ПС + Match.SubMatches(2);
			КонецЕсли;
			ПредложениеДобавлено = Истина;
		КонецЕсли;
	КонецЦикла;
	Если Не ПредложениеДобавлено Тогда
		Текст = Текст + "
		|ПОМЕСТИТЬ
		|	" + ИмяВременнойТаблицы;
	КонецЕсли;
	Возврат Текст;

КонецФункции // ДобавитьПредложениеПоместитьВЗапрос()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция РазбитьГрубоТекстПакетногоЗапросаНаТекстыЗапросов(ТекстПакета) Экспорт 

	МассивТекстовЗапросов = Новый Массив;
	шСтрокаЗапроса    = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)";
	
	RegExp.Global = Истина;
	ШаблонЗапроса = "(?:" + шСтрокаЗапроса + ")|;|$";
	RegExp.Pattern = ШаблонЗапроса;
	
	Результат = RegExp.Execute(ТекстПакета);
	НачалоЗапроса = 1;
	ОстальнойТекст = ТекстПакета;
	МассивТаблиц = Новый Массив;
	ДлинаТекстаПакета = СтрДлина(ТекстПакета);
	Для Каждого Match Из Результат Цикл
		Если Истина
			И Match.Value <> ";"
			И Match.FirstIndex <> ДлинаТекстаПакета
		Тогда
			Продолжить;
		КонецЕсли;
		ИмяВременнойТаблицы = "";
		ДлинаТекстаЗапроса = Match.FirstIndex + Match.Length;
		ТекстЗапроса = Сред(ТекстПакета, НачалоЗапроса, ДлинаТекстаЗапроса - НачалоЗапроса + 1);
		Если ПустаяСтрока(ТекстЗапроса) Тогда
			Продолжить;
		КонецЕсли;
		//Если ТекстЗапроса = ";" Тогда
		//	Продолжить;
		//КонецЕсли; 
		ОстальнойТекст = Сред(ОстальнойТекст, ДлинаТекстаЗапроса + 1);
		НачалоЗапроса = НачалоЗапроса + СтрДлина(ТекстЗапроса);
		МассивТекстовЗапросов.Добавить(ТекстЗапроса);
	КонецЦикла;
	
	Возврат МассивТекстовЗапросов;

КонецФункции // РазбитьГрубоТекстПакетногоЗапросаНаТекстыЗапросов()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПреобразоватьЗапросВПодзапрос(Текст, ТекстВыбранныхПолей = "*", ПсевдонимВложенногоЗапроса = "ВложенныйЗапрос",
	ОбрезатьНачинаяСУпорядочивания = Ложь) Экспорт

	//RegExp.Pattern = "^(?:\s|" + шКомментарий + ")*(ВЫБРАТЬ\s+(РАЗРЕШЕННЫЕ\s+)?)((?:(?:.|\r|\n)*\s(УПОРЯДОЧИТЬ\s+ПО\s))*)((?:.|\r|\n)*)$";
	//RegExp.Pattern = "^(?:\s|" + шКомментарий + ")*(ВЫБРАТЬ\s+(РАЗРЕШЕННЫЕ\s+)?)((?:(?:.|\r|\n)*\s(УПОРЯДОЧИТЬ\s+ПО|АВТОУПОРЯДОЧИВАНИЕ))*)((?:.|\r|\n)*)$";
	RegExp.Pattern = "^(?:\s|" + шКомментарий + ")*(ВЫБРАТЬ\s+(РАЗРЕШЕННЫЕ\s+)?)((?:(?:.|\r|\n)*\s(УПОРЯДОЧИТЬ\s+ПО\s+" + шИмя 
		+ "(?:\s*,\s*" + шИмя + ")*(?:\s+АВТОУПОРЯДОЧИВАНИЕ)?|АВТОУПОРЯДОЧИВАНИЕ))*)((?:.|\r|\n)*)$";
	РезультатПоиска = RegExp.Execute(Текст).Item(0);
	Результат = "ВЫБРАТЬ";
	Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(РезультатПоиска.SubMatches(1)) Тогда
		Результат = Результат + " РАЗРЕШЕННЫЕ";
	КонецЕсли; 
	Результат = Результат + " " + ТекстВыбранныхПолей + " ИЗ (ВЫБРАТЬ ";
	ТекстДоПоследнегоУПОРЯДОЧИТЬ = РезультатПоиска.SubMatches(2);
	Если ЗначениеЗаполнено(ТекстДоПоследнегоУПОРЯДОЧИТЬ) Тогда
		ТекстДоПоследнегоУПОРЯДОЧИТЬ = ирОбщий.ПолучитьСтрокуБезКонцаЛкс(ТекстДоПоследнегоУПОРЯДОЧИТЬ, СтрДлина(РезультатПоиска.SubMatches(3)));
		Результат = Результат + ТекстДоПоследнегоУПОРЯДОЧИТЬ;
	Иначе
		Результат = Результат + РезультатПоиска.SubMatches(4);
	КонецЕсли; 
	Результат = Результат + ") КАК " + ПсевдонимВложенногоЗапроса;
	Если Истина
		//И ТекстДоПоследнегоУПОРЯДОЧИТЬ <> Неопределено 
		И Не ПустаяСтрока(ТекстДоПоследнегоУПОРЯДОЧИТЬ)
		И Не ОбрезатьНачинаяСУпорядочивания 
	Тогда
		Результат = Результат + Символы.ПС + РезультатПоиска.SubMatches(3) + РезультатПоиска.SubMatches(4);
	КонецЕсли; 
	Возврат Результат;

КонецФункции // ПолучитьТекстЗапросаДоУпорядочивания()
  
// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьГрубоКоличествоСтрокВРезультатеЗапроса(ЗапросИлиПостроитель, ЛиЗамерВремени = Ложь, МодальныйРежим = Ложь, ИмяЗапроса = "") Экспорт

	Если ТипЗнч(ЗапросИлиПостроитель) = Тип("ПостроительЗапроса") Тогда
		Запрос = ЗапросИлиПостроитель.ПолучитьЗапрос();
	Иначе
		Запрос = ЗапросИлиПостроитель;
	КонецЕсли; 
	ОригинальныйТекстЗапроса = Запрос.Текст;
	
	// Исключаем тяжелые типы из финальной выборки
	МассивИменВременныхТаблиц = Новый Массив();
	ТекстПостроителя = ирКэш.Получить().ЗамаскироватьВременныеТаблицы(Запрос, , МассивИменВременныхТаблиц);
	ПостроительЗапроса = Новый ПостроительЗапроса;
	Попытка
		ПостроительЗапроса.Текст = ТекстПостроителя;
	Исключение
		ОписаниеОшибки = ОписаниеОшибки();
		Возврат ОписаниеОшибки;
	КонецПопытки; 
	ПостроительЗапроса.ДобавлениеПредставлений = ТипДобавленияПредставлений.НеДобавлять;
	ПостроительЗапроса.ЗаполнитьНастройки();
	УдаляемыеВыбранныеПоля = Новый Массив;
	Для Каждого ВыбранноеПоле Из ПостроительЗапроса.ВыбранныеПоля Цикл
		ДоступноеПоле = ПостроительЗапроса.ДоступныеПоля.Найти(ВыбранноеПоле.Имя);
		ТипЗначенияПоля = ДоступноеПоле.ТипЗначения;
		Если Ложь
			Или (Истина
				И ТипЗначенияПоля.СодержитТип(Тип("Строка"))
				И ТипЗначенияПоля.КвалификаторыСтроки.Длина = 0)
			Или ТипЗначенияПоля.СодержитТип(Тип("ХранилищеЗначения"))
		Тогда
			УдаляемыеВыбранныеПоля.Добавить(ВыбранноеПоле);
		КонецЕсли; 
	КонецЦикла;
	Для Каждого ВыбранноеПоле Из УдаляемыеВыбранныеПоля Цикл
		ПостроительЗапроса.ВыбранныеПоля.Удалить(ВыбранноеПоле);
	КонецЦикла;
	ПромежуточныйТекстЗапроса = ПостроительЗапроса.ПолучитьЗапрос().Текст;
	ПромежуточныйТекстЗапроса = ирКэш.Получить().РазмаскироватьВременныеТаблицы(ПромежуточныйТекстЗапроса, МассивИменВременныхТаблиц);
	
	МассивТекстовЗапросов = РазбитьГрубоТекстПакетногоЗапросаНаТекстыЗапросов(ПромежуточныйТекстЗапроса); // разбивка производится второй раз. можно оптимизировать
	ТекстПоследнегоЗапроса = МассивТекстовЗапросов[МассивТекстовЗапросов.ВГраница()];
	ТекстДоПоследнегоЗапроса = "";
	Для Индекс = 0 По МассивТекстовЗапросов.ВГраница() - 1 Цикл
		ТекстДоПоследнегоЗапроса = ТекстДоПоследнегоЗапроса + МассивТекстовЗапросов[Индекс];
	КонецЦикла;
	ТекстПоследнегоЗапроса = ПреобразоватьЗапросВПодзапрос(ТекстПоследнегоЗапроса, "КОЛИЧЕСТВО(1) КАК КоличествоСтрок",, Истина);
	Запрос.Текст = ТекстДоПоследнегоЗапроса + ТекстПоследнегоЗапроса;
	#Если Клиент Тогда
		НачалоПредварительногоВыполнения = ПолучитьТекущееВремяВМиллисекундах();
	#КонецЕсли 
	Попытка
		РезультатПредварительногоЗапроса = Запрос.Выполнить();
		ПредварительныйЗапросБылиОшибки = Ложь;
	Исключение
		ПредварительныйЗапросБылиОшибки = Истина;
		КоличествоСтрок = ОписаниеОшибки();
	КонецПопытки;
	#Если Клиент Тогда
		Если Истина
			И ЛиЗамерВремени 
			И Не ПредварительныйЗапросБылиОшибки
		Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Время формирования предварительного результата """ + ИмяЗапроса + """ - " 
				+ Строка(ПолучитьТекущееВремяВМиллисекундах() - НачалоПредварительногоВыполнения) + " мс", МодальныйРежим);
			КонецЕсли;
	#КонецЕсли 
	Если Не ПредварительныйЗапросБылиОшибки Тогда
		КоличествоСтрок = РезультатПредварительногоЗапроса.Выгрузить()[0].КоличествоСтрок;
	КонецЕсли;
	Запрос.Текст = ОригинальныйТекстЗапроса;
	Возврат КоличествоСтрок;

КонецФункции // ПолучитьГрубоКоличествоСтрокВРезультатеЗапроса()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьГрубоКоличествоСтрокВРезультатеКомпоновки(МакетКомпоновкиДанныхВКоллекциюЗначений, БылиОшибки = Ложь, ЛиЗамерВремени = Ложь,
	МодальныйРежим = Ложь) Экспорт

	КоличествоСтрокВсего = 0;
	Запрос = Новый Запрос;
	Для Каждого ЗначениеПараметра Из МакетКомпоновкиДанныхВКоллекциюЗначений.ЗначенияПараметров Цикл
		Запрос.Параметры.Вставить(ЗначениеПараметра.Имя, ЗначениеПараметра.Значение);
	КонецЦикла;
	Для Каждого НаборДанных Из МакетКомпоновкиДанныхВКоллекциюЗначений.НаборыДанных Цикл
		Если ТипЗнч(НаборДанных) <> Тип("НаборДанныхЗапросМакетаКомпоновкиДанных") Тогда
			Продолжить;
		КонецЕсли;
		Запрос.Текст = НаборДанных.Запрос;
		КоличествоСтрок = ПолучитьГрубоКоличествоСтрокВРезультатеЗапроса(Запрос, ЛиЗамерВремени, МодальныйРежим, НаборДанных.Имя);
		Если ТипЗнч(КоличествоСтрок) = Тип("Число") Тогда
			КоличествоСтрокВсего = КоличествоСтрокВсего + КоличествоСтрок;
		Иначе
			БылиОшибки = Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат КоличествоСтрокВсего;

КонецФункции // ПолучитьГрубоКоличествоСтрокВРезультатеКомпоновки()

// Получает имя создаваемой временной таблицы из текста запроса.
// Это неточный метод, основанный на regexp.
//
// Параметры:
//  ТекстЗапроса – Строка.
//
// Возвращаемое значение:
//  Строка, Неопределено.
//
Функция ПолучитьМассивСоздаваемыхВременныхТаблицПакета(ТекстПакета) Экспорт 

	МассивТекстовЗапросов = РазбитьГрубоТекстПакетногоЗапросаНаТекстыЗапросов(ТекстПакета);
	RegExp2.Global = Истина;
	// Ищем в очередном запросе предложение ПОМЕСТИТЬ
	шСтрокаЗапроса    = """(?:(?:"""")|[^""\n$])*(?:" + шРазделитель + "*(?:(?:"""")|[^""\n$])*)*(?:""|$)";
	ШаблонПОМЕСТИТЬИЗ = "(?:" + шСтрокаЗапроса + ")|(?:" + шРазделитель + "+" + "(?:ПОМЕСТИТЬ|INTO\s+TABLE|INTO)" + шРазделитель 
		+ "+(" + шИмя + ")(" + шРазделитель + "|;))";
	RegExp2.Pattern = ШаблонПОМЕСТИТЬИЗ;
	МассивТаблиц = Новый Массив;
	Для Каждого ТекстЗапроса Из МассивТекстовЗапросов Цикл
		Результат2 = RegExp2.Execute(ТекстЗапроса);
		ИмяВременнойТаблицы = Неопределено;
		Для Каждого Match2 Из Результат2 Цикл
			Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Match2.SubMatches(0)) Тогда
				ИмяВременнойТаблицы = Match2.SubMatches(0);
				Прервать;
			КонецЕсли;
		КонецЦикла;
		МассивТаблиц.Добавить(ИмяВременнойТаблицы);
	КонецЦикла;
	Возврат МассивТаблиц;
	
КонецФункции // ПолучитьМассивСоздаваемыхВременныхТаблицПакета()

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ТИПАМИ

// Получает чистую внутреннюю таблицу предопределенных слов.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов".
//
Функция ПолучитьНовуюВнутреннююТаблицуСлов()

	ВнутренняяТаблицаСлов = Новый ТаблицаЗначений;
	ВнутренняяТаблицаСлов.Колонки.Добавить("Слово");
	ВнутренняяТаблицаСлов.Колонки.Добавить("ТипСлова");
	ВнутренняяТаблицаСлов.Колонки.Добавить("ТаблицаСтруктурТипов");
	Возврат ВнутренняяТаблицаСлов;

КонецФункции // ПолучитьНовуюВнутреннююТаблицуСлов()

// Получение объекта МД с внутренним кэшированием.
Функция ПолучитьОбъектМДПоПолномуИмени(ПолноеИмя) Экспорт
	
	ОбъектМД = ОбъектыМДПоПолномуИмени[ПолноеИмя];
	Если ОбъектМД = Неопределено Тогда
		ОбъектМД = мМетаданные.НайтиПоПолномуИмени(ПолноеИмя);
		ОбъектыМДПоПолномуИмени[ПолноеИмя] = ОбъектМД;
	КонецЕсли;
	Возврат ОбъектМД;
	
КонецФункции

#Если Клиент Тогда

// Позволяет пользователю выбрать один из возможных вариантов описания слова.
//
// Параметры:
//  СтруктураЦикла – Соответствие – где ключи - имена ветвей дерева, а значения - таблицы структур типов;
//  *ВключатьПутьКОписаниюТипаЗначения - Булево, *Неопределено - признак добавления в список выбора тип значения слова.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений, Структура - описание слова.
//
Функция ВыбратьСтрокуОписанияИзМассиваСтруктурТипов(СтруктураЦикла, ВключатьПутьКОписаниюТипаЗначения = Ложь, ФормаВладелец = Неопределено, Слово = "",
	НомерПараметраМетода = 0, БезусловнаяАктивизацияРезультатов = Истина) Экспорт

	ДеревоВыбора = Новый ДеревоЗначений;
	ДеревоВыбора.Колонки.Добавить("Ключ");
	ДеревоВыбора.Колонки.Добавить("Представление");
	ДеревоВыбора.Колонки.Добавить("ТипСлова");
	СчетчикСтрокВторогоУровня = 0;
	НачальнаяСтрокаВыбора = Неопределено;
	Для Каждого ЭлементЦикла Из СтруктураЦикла Цикл
		СтрокаЭлементаЦикла = ДеревоВыбора.Строки.Добавить();
		СтрокаЭлементаЦикла.Представление = ЭлементЦикла.Ключ;
	КонецЦикла;
	ДеревоВыбора.Строки.Сортировать("Представление");
	Для Каждого СтрокаЭлементаЦикла Из ДеревоВыбора.Строки Цикл
		Для Каждого СтруктураТипаКонтекста Из СтруктураЦикла[СтрокаЭлементаЦикла.Представление] Цикл
			//Если СтруктураТипаКонтекста.СтрокаОписания = Неопределено Тогда 
			//	Продолжить;
			//КонецЕсли;
			Если СтруктураТипаКонтекста.ИмяОбщегоТипа = "Неизвестный контекст" Тогда
				Продолжить;
			КонецЕсли;
			СтрокаОписания = СтруктураТипаКонтекста.СтрокаОписания;
			
			// Ранее среди параметров были: ПутьКСлову = "", ТекущееСлово = "",
			//// Добавим строку описания слова
			//ЭтоИмяТипа = Ложь;
			//Попытка
			//	Если СтрокаОписания.ТипЯзыка = "ИмяТипа" Тогда
			//		ЭтоИмяТипа = Истина;
			//	КонецЕсли;
			//Исключение
			//КонецПопытки;
			//
			//Если ЭтоИмяТипа Тогда
			//	
			//	Если Прав(ПутьКСлову, 1) = "(" Тогда 
			//		ЧистыйПутьКСлову = Лев(ПутьКСлову, СтрДлина(ПутьКСлову) - 1);
			//	Иначе
			//		ЧистыйПутьКСлову = ТекущееСлово;
			//	КонецЕсли;
			//	
			//	БазовыйТип = ирОбщий.ПолучитьПервыйФрагментЛкс(ЧистыйПутьКСлову);
			//	Если БазовыйТип = "" Тогда
			//		// Неизвестный контекст
			//		СтрокаОписания = Неопределено;
			//	Иначе
			//		СтрокаОписания = ТаблицаОбщихТипов.Найти(БазовыйТип, "БазовыйТип");
			//	КонецЕсли;
			//КонецЕсли;
			
			Если Истина
				И СтрокаОписания <> Неопределено
				И СтрокаЭлементаЦикла.Строки.Найти(СтрокаОписания, "Ключ") = Неопределено
				И (Ложь
					Или СтрокаОписания.Владелец().Колонки.Найти("ТипЯзыка") = Неопределено
					Или СтрокаОписания.ТипЯзыка <> "ИмяТипа")
			Тогда
				ПредставлениеТипа = СтрокаОписания.Слово;
				Если Истина
					И СтрокаОписания.Владелец().Колонки.Найти("ТипКонтекста") <> Неопределено
					И ЗначениеЗаполнено(СтрокаОписания.ТипКонтекста)
				Тогда
					ПредставлениеТипа = СтрокаОписания.ТипКонтекста + "." + ПредставлениеТипа;
				КонецЕсли;
				СтрокаДереваВыбора = СтрокаЭлементаЦикла.Строки.Добавить();
				СтрокаДереваВыбора.Ключ = СтрокаОписания;
				Попытка
					СтрокаДереваВыбора.ТипСлова = СтрокаОписания.ТипСлова;
				Исключение
					СтрокаДереваВыбора.ТипСлова = "Тип";
				КонецПопытки;
				СтрокаДереваВыбора.Представление = ПредставлениеТипа;
			КонецЕсли;
			
			Если ВключатьПутьКОписаниюТипаЗначения Тогда
				// Добавим строку описания типа значения
				СтрокаОписанияТипаЗначения = ТаблицаОбщихТипов.Найти(НРег(СтруктураТипаКонтекста.ИмяОбщегоТипа), "НСлово");
				Если СтрокаОписанияТипаЗначения <> Неопределено Тогда
					Если СтрокаЭлементаЦикла.Строки.Найти(СтрокаОписанияТипаЗначения, "Ключ") = Неопределено Тогда
						ПредставлениеТипа = СтрокаОписанияТипаЗначения.Слово;
						СтрокаДереваВыбора = СтрокаЭлементаЦикла.Строки.Добавить();
						СтрокаДереваВыбора.Ключ = СтрокаОписанияТипаЗначения;
						СтрокаДереваВыбора.ТипСлова = "Тип";
						СтрокаДереваВыбора.Представление = ПредставлениеТипа;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		СчетчикСтрокВторогоУровня = СчетчикСтрокВторогоУровня + СтрокаЭлементаЦикла.Строки.Количество();
		Если Истина
			И НачальнаяСтрокаВыбора = Неопределено
			И СтрокаЭлементаЦикла.Строки.Количество() > 0
		Тогда
			НачальнаяСтрокаВыбора = СтрокаЭлементаЦикла.Строки[0];
		КонецЕсли;
		СтрокаЭлементаЦикла.Строки.Сортировать("Представление");
	КонецЦикла;
	Если СчетчикСтрокВторогоУровня > 0 Тогда
		ФормаВыбора = ирОбщий.ПолучитьФормуЛкс("Обработка.ирСинтаксПомощник.Форма");
		ФормаВыбора.ДеревоТиповСлова = ДеревоВыбора;
		ФормаВыбора.ИскомоеСлово = Слово;
		ФормаВыбора.ПоискСУчетомТипаСлова = Истина;
		ФормаВыбора.НомерИскомогоПараметра = НомерПараметраМетода;
		ФормаВыбора.ВладелецФормы = ФормаВладелец;
		ФормаВыбора.ВыбратьИскомуюСтроку(НачальнаяСтрокаВыбора, БезусловнаяАктивизацияРезультатов);
		ФормаВыбора.ВладелецФормы = Неопределено;
	КонецЕсли; 
	Если Ложь
		Или СчетчикСтрокВторогоУровня = 1
		Или (Истина
			И СчетчикСтрокВторогоУровня = 2
			И ДеревоВыбора.Строки[0].Строки.Количество() = 1
			И НачальнаяСтрокаВыбора.Ключ = ДеревоВыбора.Строки[1].Строки[0].Ключ)
	Тогда 
		ВыбранныйЭлементТипа = НачальнаяСтрокаВыбора;
	ИначеЕсли СчетчикСтрокВторогоУровня > 1 Тогда
		//ФормаВыбора = ПолучитьФорму("ФормаВыбораСправкиПоСлову");
		//ФормаВыбора.ДеревоТиповСлова = ДеревоВыбора;
		//ФормаВыбора.НачальноеЗначениеВыбора = НачальнаяСтрокаВыбора;
		//ВыбранныйЭлементТипа = ФормаВыбора.ОткрытьМодально();
		ВыбранныйЭлементТипа = НачальнаяСтрокаВыбора;
	Иначе
		ВыбранныйЭлементТипа = Неопределено;
	КонецЕсли;
	Если ВыбранныйЭлементТипа = Неопределено Тогда
		СтрокаОписания = Неопределено;
	Иначе
		СтрокаОписания = ВыбранныйЭлементТипа.Ключ;
	КонецЕсли;
	
	Возврат СтрокаОписания;

КонецФункции // ВыбратьСтрокуОписанияИзМассиваСтруктурТипов()

#КонецЕсли

// Формирует построитель запроса по структуре типа.
//
// Параметры:
//  СтруктураТипа – Структура - описатель типа.
//
// Возвращаемое значение:
//   ПостроительЗапроса.
//
Функция ПолучитьПостроительЗапросаПоСтруктуреТипа(СтрокаОбщегоТипа, ВиртуальнаяТаблица = Неопределено)

	МетаданныеРодителя = СтрокаОбщегоТипа.Метаданные;
	ТипМетаданныхРодителя = ТипЗнч(МетаданныеРодителя);
	Если ТипМетаданныхРодителя = Тип("ОбъектМетаданных") Тогда
		ПолноеИмя = МетаданныеРодителя.ПолноеИмя();
	Иначе
		ПолноеИмя = ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(КэшОбъект(МетаданныеРодителя).ПолноеИмя);
	КонецЕсли; 
	МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмя);
	КорневойТипРодителя = МассивФрагментов[0];
	ПостроительЗапроса = Новый ПостроительЗапроса;
	Если ПолучитьСтрокуТипаМетаОбъектов(КорневойТипРодителя, , 0) <> Неопределено Тогда
		Если Ложь
			Или (Истина
				И МассивФрагментов.Количество() = 2
				И МассивФрагментов[0] <> "ВнешнийИсточникДанных")
			Или (Истина
				И МассивФрагментов.Количество() = 4
				И МассивФрагментов[2] = "ТабличнаяЧасть")
		Тогда
			Если ТипМетаданныхРодителя = Тип("ОбъектМетаданных") Тогда
				Если КорневойТипРодителя = "Константа" Тогда
					ОпределениеТаблицы = "ВЫБРАТЬ Константы." + МассивФрагментов[1];
				Иначе
					//ИмяТаблицы = КорневойТипРодителя + "." + МассивФрагментов[1];
					//Если МассивФрагментов.Количество() > 2 Тогда
					//	ИмяТаблицы = ИмяТаблицы + "." + МассивФрагментов[3];
					//КонецЕсли;
					ИмяТаблицы = ирОбщий.ПолучитьИмяТаблицыИзМетаданныхЛкс(ПолноеИмя, Ложь, ВиртуальнаяТаблица = Неопределено); // Добавлено 14.04.2012
					
					УникальноеИмяТаблицы = "______________________";
					ОпределениеТаблицы = "ВЫБРАТЬ * ИЗ " + ИмяТаблицы ;
					Если ВиртуальнаяТаблица <> Неопределено Тогда
						ОпределениеТаблицы = ОпределениеТаблицы + ВиртуальнаяТаблица.Выражение;
					КонецЕсли; 
					ОпределениеТаблицы = ОпределениеТаблицы + " КАК " + УникальноеИмяТаблицы;
				КонецЕсли;
				Попытка
					// Тормоз
					ПостроительЗапроса.Текст = ОпределениеТаблицы;
				Исключение
					ВызватьИсключение "ОшибкаВычисленияВиртуальнойТаблицы";
				КонецПопытки;
				// Тормоз
				ПостроительЗапроса.ЗаполнитьНастройки();
			Иначе
				ЗапросРеквизитов = Новый Запрос("ВЫБРАТЬ Имя, ТипыСтрокой ИЗ Справочник.СвойстваМетаданных ГДЕ Владелец = &СсылкаМД");
				ЗапросРеквизитов.УстановитьПараметр("СсылкаМД", МетаданныеРодителя);
				ТаблицаРеквизитов = ЗапросРеквизитов.Выполнить().Выгрузить();
				Для Каждого СтрокаРеквизита Из ТаблицаРеквизитов Цикл
					ДоступноеПоле = ПостроительЗапроса.ДоступныеПоля.Добавить(СтрокаРеквизита.Имя);
					Для Каждого СтрокаТипа Из СтрокаРеквизита.Типы Цикл
						МассивТипов = Новый Массив;
						ОбъектМД = КэшОбъект(СтрокаТипа.Объект);
						МассивТипов.Добавить(Тип(ОбъектМД.Наименование));
					КонецЦикла; 
					ДоступноеПоле.ТипЗначения = Новый ОписаниеТипов(МассивТипов);
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 

	Возврат ПостроительЗапроса;

КонецФункции // ПолучитьПостроительЗапросаПоСтруктуреТипа()

// Получает массив общих типов, дополняя исходный тип расширениями.
//
// Параметры:
//  СтруктураТипа – Структура.
//
// Возвращаемое значение:
//  Массив - структур типа.
//
Функция ПолучитьТаблицуОбщихТиповСтруктурыТипа(СтруктураТипа) Экспорт 

	МассивОбщихТипов = ПолучитьНовуюТаблицуДополнительныхТипов();
	ЗаполнитьЗначенияСвойств(МассивОбщихТипов.Добавить(), СтруктураТипа);
	Если Найти(СтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧасть.") > 0 Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Табличная часть";
	ИначеЕсли Найти(СтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧастьСтрока.") > 0 Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Строка табличной части";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеТекстовогоДокумента" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "ТекстовыйДокумент";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеГрафическойСхемы" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "ГрафическаяСхема";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "ПолеТабличногоДокумента" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "ТабличныйДокумент";
	//ИначеЕсли Найти(СтруктураТипа.ИмяОбщегоТипа, "Расширение формы") > 0 Тогда
	//	НоваяСтрока = МассивОбщихТипов.Добавить();
	//	ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
	//	НоваяСтрока.ИмяОбщегоТипа = "Форма";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "Локальный контекст" Тогда
		Если ТипЗнч(СтруктураТипа.Метаданные) <> Тип("COMОбъект") Тогда // 31.07.2013
			НоваяСтрока = МассивОбщихТипов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
			НоваяСтрока.ИмяОбщегоТипа = "Глобальный контекст";
			НоваяСтрока = МассивОбщихТипов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
			НоваяСтрока.ИмяОбщегоТипа = "Общее";
		КонецЕсли; 
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "Automation сервер" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Глобальный контекст";
	ИначеЕсли СтруктураТипа.ИмяОбщегоТипа = "COM-соединитель" Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Глобальный контекст";
	Иначе
		ОбщийТипМетаданных = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(СтруктураТипа.ИмяОбщегоТипа, , ": ", Ложь);
		//Если ОбщийТипМетаданных <> "" Тогда
		Если ЗначениеЗаполнено(ОбщийТипМетаданных) Тогда
			НоваяСтрока = МассивОбщихТипов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
			НоваяСтрока.ИмяОбщегоТипа = ОбщийТипМетаданных;
		КонецЕсли;
	КонецЕсли;
	
	// Расширения, образованные элементом управления и типом связанных с ним данных
	СтрокаРасширения = ТаблицаРасширенийТипов.Найти(СтруктураТипа.ИмяОбщегоТипа, "Расширение");
	Если СтрокаРасширения <> Неопределено Тогда
		Если Истина
			И СтрокаРасширения.ОсновнойТип = "Форма"
			И СтруктураТипа.ДополнительныеТипы = Неопределено
		Тогда
			НоваяСтрока = МассивОбщихТипов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
			НоваяСтрока.ИмяОбщегоТипа = СтрокаРасширения.РасширяющийТип;
			//НоваяСтрока.НеВключатьМетоды = Истина; // Закомментировал 30.09.2010
			#Если Клиент Тогда
				Если ТипЗнч(СтруктураТипа.Метаданные) = Тип("Форма") Тогда
					ОсновнойРеквизитФормы = ПолучитьИмяОсновногоРеквизитаФормы(СтруктураТипа.Метаданные);
					НоваяСтрока.Метаданные = ирОбщий.ПолучитьМетаданныеЛкс(СтруктураТипа.Метаданные[ОсновнойРеквизитФормы]);
				КонецЕсли;
			#КонецЕсли 
		КонецЕсли;
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = СтрокаРасширения.ОсновнойТип;
	КонецЕсли;
	
	// Общие расширения элементов управления
	лИмяОбщегоТипа = МассивОбщихТипов[МассивОбщихТипов.Количество() - 1].ИмяОбщегоТипа;
	Если Ложь
		Или МассивОбычныхЭлементовУправления.Найти(лИмяОбщегоТипа) <> Неопределено
		Или МассивУправляемыхЭлементовУправления.Найти(лИмяОбщегоТипа) <> Неопределено
	Тогда
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		НоваяСтрока.ИмяОбщегоТипа = "Расширение элементов управления, расположенных в форме";
		НоваяСтрока = МассивОбщихТипов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураТипа);
		// Эту синтаксическую ошибку исправили только в 13-м релизе.
		//НоваяСтрока.ИмяОбщегоТипа = "Расширение элементов управления, расположенных на панели";
		НоваяСтрока.ИмяОбщегоТипа = "Расширение элементов управления расположенных на панели";
	КонецЕсли;

	Если СтруктураТипа.ДополнительныеТипы <> Неопределено Тогда
		ирОбщий.ЗагрузитьВТаблицуЗначенийЛкс(СтруктураТипа.ДополнительныеТипы, МассивОбщихТипов);
	КонецЕсли;
	Возврат МассивОбщихТипов;

КонецФункции // ПолучитьТаблицуОбщихТиповСтруктурыТипа()

// Получает внутреннюю таблицу метаданных слов заданного родительского типа.
//
// Параметры:
//  РодительскаяСтруктураТипа – Структура;
//  *Слово       – Строка, *Неопределено – для отбора;
//  *ТипСлова    – Строка, *Неопределено – для отбора;
//  *ВиртуальнаяТаблица - Структура, *Неопределено - описание виртуальной таблицы;
//  *ЯзыкПрограммы - *Число, 0;
//  *ТекущийИндекс - Строка - выражение в квадратных скобках.
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов".
//
Функция ПолучитьВнутреннююТаблицуМетаданныхСлов(РодительскаяСтруктураТипа, Слово = Неопределено, ТипСлова = Неопределено,
	ВиртуальнаяТаблица = Неопределено, ЯзыкПрограммы = 0, ТекущийИндекс = Неопределено, ВнешниеФункцииКомпоновкиДанных = Истина) Экспорт 
	
	ВнутренняяТаблицаСлов = ПолучитьНовуюВнутреннююТаблицуСлов();
	КонкретныйТип = ПолучитьСтрокуКонкретногоТипа(РодительскаяСтруктураТипа);
	Если Найти(КонкретныйТип, "<") > 0 Тогда
		// Такой конкретный тип не разрешен
		Возврат ВнутренняяТаблицаСлов;
	КонецЕсли;
	
	ТаблицуОбщихТиповСтруктурыТипа = ПолучитьТаблицуОбщихТиповСтруктурыТипа(РодительскаяСтруктураТипа);
	
	Если Истина
		И Слово <> Неопределено
		И ТекущийИндекс <> Неопределено
	Тогда
		RegExp.Global = Ложь;
		RegExp.Pattern = "^""(" + шИмя + ")""$";
		РезультатСтроковойКонстанты = RegExp.Execute(Слово);
		Если РезультатСтроковойКонстанты.Count > 0 Тогда
			Слово = РезультатСтроковойКонстанты.Item(0).SubMatches(0);
		КонецЕсли;
		RegExp.Pattern = "^(" + шИмя + ")$";
		ЛиСловоИдентификатор = RegExp.Test(Слово);
		Если Не ЛиСловоИдентификатор Тогда
			// Это элемент универсальной коллекции
			СтруктураКлюча = Новый Структура("Слово, ЯзыкПрограммы",
				РодительскаяСтруктураТипа.ИмяОбщегоТипа, ЯзыкПрограммы);
			НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
			Если НайденныеСтроки.Количество() > 0 Тогда
				СтруктураКлюча = Новый Структура("БазовыйТип, ЯзыкПрограммы", НайденныеСтроки[0].ТипЭлементаКоллекции, ЯзыкПрограммы);
				НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
				Если НайденныеСтроки.Количество() > 0 Тогда
					СтрокаТипа = НайденныеСтроки[0];
					СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
					СтруктураТипа.СтрокаОписания = СтрокаТипа;
					СтруктураТипа.ИмяОбщегоТипа  = СтрокаТипа.Слово;
					СтруктураТипа.Метаданные = РодительскаяСтруктураТипа.Метаданные;
					ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
					ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаТипа.Слово, "Свойство", ТаблицаСтруктурТипов);
				КонецЕсли;
			КонецЕсли;
			Возврат ВнутренняяТаблицаСлов;
		КонецЕсли;
	КонецЕсли;
		
	Для Каждого СтрокаОбщегоТипа Из ТаблицуОбщихТиповСтруктурыТипа Цикл
        ИмяОбщегоТипа = СтрокаОбщегоТипа.ИмяОбщегоТипа;
		Если ирОбщий.СтрокиРавныЛкс(СтрокаОбщегоТипа.ИмяОбщегоТипа, "COMОбъект.{WbemScripting.SwbemLocator}.ISWbemObject") Тогда
			Если ТипЗнч(СтрокаОбщегоТипа.Метаданные) = Тип("COMОбъект") Тогда
				СтруктураЦикла = Новый Структура();
				СтруктураЦикла.Вставить("Свойство", СтрокаОбщегоТипа.Метаданные.Properties_);
				СтруктураЦикла.Вставить("Метод", СтрокаОбщегоТипа.Метаданные.Methods_);
				Для Каждого КлючИЗначение Из СтруктураЦикла Цикл
					КоллекцияСвойств = КлючИЗначение.Значение;
					лТипСлова = КлючИЗначение.Ключ;
					Если Истина
						И ТипСлова <> Неопределено
						И Не ирОбщий.СтрокиРавныЛкс(лТипСлова, ТипСлова)
					Тогда
						Продолжить;
					КонецЕсли; 
					Для Каждого Свойство Из КоллекцияСвойств Цикл
						ИмяСвойства = Свойство.Name;
						Если Истина
							И Слово <> Неопределено 
							И Не ирОбщий.СтрокиРавныЛкс(ИмяСвойства, Слово)
						Тогда
							Продолжить;
						КонецЕсли;
						ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
						СтруктураТипа = ТаблицаСтруктурТипов.Добавить();
						СтруктураТипа.СтрокаОписания = Свойство;
						СтруктураТипа.ИмяОбщегоТипа  = ирОбщий.ПолучитьИмяТипаИзКвалификаторовWMIЛкс(Свойство);
						СтруктураТипа.Метаданные = РодительскаяСтруктураТипа.Метаданные;
						ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, ИмяСвойства, лТипСлова, ТаблицаСтруктурТипов);
					КонецЦикла;
				КонецЦикла; 
			КонецЕсли; 
		КонецЕсли;
		МетаданныеРодителя = СтрокаОбщегоТипа.Метаданные;
		КорневойТипРодителя = Неопределено;
		ПостроительЗапросаРодителя = Неопределено;
		Если РодительскаяСтруктураТипа.ТипЯзыка <> "ИмяТипа" Тогда 
			ТипМетаданныхРодителя = ТипЗнч(МетаданныеРодителя);
			Если Ложь
				Или ТипМетаданныхРодителя = Тип("ОбъектМетаданных")
				Или (Истина
					И Это2iS
					И (Ложь
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.ОбъектыМетаданных2iS")
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.СвойстваМетаданных2iS")))
				Или (Истина
					И ЭтоИнтеграция
					И (Ложь
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.МетаданныеИис")
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.СвойстваМетаданныхИис")))
			Тогда
				Если ТипМетаданныхРодителя = Тип("ОбъектМетаданных") Тогда
					КорневойТипРодителя = ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(МетаданныеРодителя);
				Иначе
					КорневойТипРодителя = ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(КэшОбъект(МетаданныеРодителя).ПолноеИмя);
				КонецЕсли; 
				ПостроительЗапросаРодителя = ПолучитьПостроительЗапросаПоСтруктуреТипа(СтрокаОбщегоТипа,
					РодительскаяСтруктураТипа.ВиртуальнаяТаблица);
			КонецЕсли;
		КонецЕсли;
		
		Если Истина
			И ЯзыкПрограммы = 2
			И ВнешниеФункцииКомпоновкиДанных
		Тогда
			СтруктураКлюча = Новый Структура("ТипКонтекста, Слово, ЯзыкПрограммы, ТипЯзыка",
				ИмяОбщегоТипа, "<Имя общего модуля>", 0, РодительскаяСтруктураТипа.ТипЯзыка);
		Иначе
			СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка",
				ИмяОбщегоТипа, ЯзыкПрограммы, РодительскаяСтруктураТипа.ТипЯзыка);
		КонецЕсли; 
		Если ТипСлова <> Неопределено Тогда
			СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
		КонецЕсли;
		НайденныеСтроки = ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча);
		
		Если Истина
			//И ИмяОбщегоТипа <> "Глобальный контекст" // Для того, чтобы постоянно не присваивался тип <ОбщийМодуль> // закомментировал 25.12.2011
			//И НайденныеСтроки.Количество() > 0 
		Тогда
			Для Каждого СтрокаВида Из НайденныеСтроки Цикл
				СхемаКоллекции = Новый Соответствие;
				КоллекцияЗначений = Неопределено;
				ИмяЭлементаКоллекции = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(СтрокаВида.Слово, "<", ">", Ложь, Истина);
				
				КлючПоиска = Новый Структура("ИмяОбщегоТипа, ИмяЭлементаКоллекции", ИмяОбщегоТипа, ИмяЭлементаКоллекции);
				СтрокаОписанияВида = Неопределено;
				НайденныеСтрокиКоллекций = ТаблицаИменЭлементовКоллекций.НайтиСтроки(КлючПоиска);
				Если НайденныеСтрокиКоллекций.Количество() > 0 Тогда
					СтрокаОписанияВида = НайденныеСтрокиКоллекций[0];
				КонецЕсли; 
				Если СтрокаОписанияВида = Неопределено Тогда
					КлючПоиска.Удалить("ИмяОбщегоТипа");
					НайденныеСтрокиКоллекций = ТаблицаИменЭлементовКоллекций.НайтиСтроки(КлючПоиска);
					Если НайденныеСтрокиКоллекций.Количество() > 0 Тогда
						СтрокаОписанияВида = НайденныеСтрокиКоллекций[0];
					КонецЕсли; 
				КонецЕсли; 
				//// Исправление кривоты платформенной справки (неуникальные имена шаблона элемента коллекции между разными типами коллекций)
				//Если ИмяЭлементаКоллекции = "<Имя элемента управления>" Тогда
				//	СтруктураОтбора = Новый Структура("ИмяЭлементаКоллекции, ИмяКоллекции", ИмяЭлементаКоллекции);
				//	Если ИмяОбщегоТипа = "ВсеЭлементыФормы" Тогда
				//		СтруктураОтбора.ИмяКоллекции = "Элементы";
				//	Иначе//Если ИмяОбщегоТипа = "ЭлементыФормы" Тогда
				//		СтруктураОтбора.ИмяКоллекции = "ЭлементыФормы";
				//	КонецЕсли; 
				//	СтрокаОписанияВида = ТаблицаИменЭлементовКоллекций.НайтиСтроки(СтруктураОтбора)[0];
				//ИначеЕсли ИмяЭлементаКоллекции = "<Имя колонки>" Тогда
				//	СтруктураОтбора = Новый Структура("ИмяЭлементаКоллекции, ИмяКоллекции", ИмяЭлементаКоллекции);
				//	Если ИмяОбщегоТипа = "Ячейки" Тогда
				//		СтруктураОтбора.ИмяКоллекции = "ОформленияЯчеек";
				//	Иначе//Если ИмяОбщегоТипа = "СтрокаТаблицыЗначений" Тогда
				//		СтруктураОтбора.ИмяКоллекции = "Колонки";
				//	КонецЕсли; 
				//	СтрокаОписанияВида = ТаблицаИменЭлементовКоллекций.НайтиСтроки(СтруктураОтбора)[0];
				//КонецЕсли; 
				Если Слово <> Неопределено Тогда 
					МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(СтрокаВида.Слово, ИмяЭлементаКоллекции);
					НачалоТекущегоСлова = Лев(Слово, СтрДлина(МассивФрагментов[0]));
					КонецТекущегоСлова = Прав(Слово, СтрДлина(МассивФрагментов[1]));
					ИмяТекущегоСлова = Сред(Слово, СтрДлина(НачалоТекущегоСлова) + 1,
						СтрДлина(Слово) - СтрДлина(КонецТекущегоСлова));
					Если НачалоТекущегоСлова + ИмяЭлементаКоллекции + КонецТекущегоСлова <> СтрокаВида.Слово Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				Если СтрокаОписанияВида = Неопределено Тогда
					// Имя элемента коллекции не внесено в служебную таблицу
					Продолжить;
				КонецЕсли; 
				Если Истина
					И СтрокаОписанияВида.ИмяКоллекции = "Предопределенные"
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных") //
				Тогда
					Запрос = Новый Запрос;
					Запрос.Текст = "ВЫБРАТЬ Таблица.Ссылка ИЗ " + МетаданныеРодителя.ПолноеИмя() + " КАК Таблица
					|ГДЕ Таблица.Предопределенный
					|";
					Результат = Запрос.Выполнить().Выгрузить();
					МенеджерТипа = ирОбщий.ПолучитьМенеджерЛкс(МетаданныеРодителя);
					Для Каждого СтрокаРезультата Из Результат Цикл
						СхемаКоллекции.Вставить(МенеджерТипа.ПолучитьИмяПредопределенного(СтрокаРезультата.Ссылка),
							Новый ОписаниеТипов(ирОбщий.БыстрыйМассивЛкс(ТипЗнч(СтрокаРезультата.Ссылка))));
					КонецЦикла;
				ИначеЕсли Ложь
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Поля" 
						И ТипЗнч(МетаданныеРодителя) = Тип("РезультатЗапроса"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Колонки" 
						И (Ложь
							Или ТипЗнч(МетаданныеРодителя) = Тип("РезультатЗапроса")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ТаблицаЗначений")
							Или ТипЗнч(МетаданныеРодителя) = Тип("ДеревоЗначений")))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Колонки" 
						И ТипЗнч(МетаданныеРодителя) = Тип("ТабличноеПоле"))
				Тогда
					// %%%% Некрасиво, но работает.
					Если Найти(ИмяОбщегоТипа, "Колон") = 0 Тогда
						Если СтрокаОписанияВида.ИмяЭлементаКоллекции = "<Имя колонки списка>" Тогда
							ДинамическийСписок = МетаданныеРодителя.Значение;
							ПостроительСписка = ПолучитьПостроительЗапросаПоСтруктуреТипа(ПолучитьСтруктуруТипаИзЗначения(ДинамическийСписок));
							КоллекцияКолонок = ДинамическийСписок.Колонки;
							Для Каждого Колонка Из КоллекцияКолонок Цикл
								Если Колонка.Имя = "" Тогда
									// Антибаг платформы 8.2.16 Замечено на форме списка РС.ООП_ВаучерыТез
									Продолжить;
								КонецЕсли; 
								СхемаКоллекции.Вставить(Колонка.Имя, ПостроительСписка.ДоступныеПоля[Колонка.Имя].ТипЗначения);
							КонецЦикла;
						Иначе
							Для Каждого Колонка Из МетаданныеРодителя.Колонки Цикл
								СхемаКоллекции.Вставить(Колонка.Имя, Колонка.ТипЗначения);
							КонецЦикла;
						КонецЕсли;
					Иначе
						КоллекцияЗначений = МетаданныеРодителя.Колонки;
					КонецЕсли;
				ИначеЕсли Истина
					И ТипЗнч(МетаданныеРодителя) = Тип("ПостроительЗапроса")
					И (Ложь
						Или СтрокаОписанияВида.ИмяКоллекции = "Поля" 
						Или СтрокаОписанияВида.ИмяКоллекции = "Колонки")
				Тогда
					Для Каждого ВыбранноеПоле Из МетаданныеРодителя.ВыбранныеПоля Цикл
						лДоступноеПоле = МетаданныеРодителя.ДоступныеПоля.Найти(ВыбранноеПоле.Имя);
						СхемаКоллекции.Вставить(ВыбранноеПоле.Имя, лДоступноеПоле.ТипЗначения);
					КонецЦикла;
				ИначеЕсли Ложь
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Структура" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Структура"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "НастройкаОформления" 
						И ТипЗнч(МетаданныеРодителя) = Тип("НастройкаОформления"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Отбор" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Отбор"))
				Тогда
					КоллекцияЗначений = МетаданныеРодителя;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "Структура" 
					И ТипЗнч(МетаданныеРодителя) = Тип("Форма")
				Тогда
					КоллекцияЗначений = МетаданныеРодителя[РодительскаяСтруктураТипа.СтрокаОписания.Слово];
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "Колонки" 
					И (Ложь
						Или ТипЗнч(МетаданныеРодителя) = Тип("ДоступноеПолеКомпоновкиДанных")
						Или ТипЗнч(МетаданныеРодителя) = Тип("ДоступноеПолеОтбораКомпоновкиДанных"))
				Тогда
					Для Каждого ДоступноеПоле Из МетаданныеРодителя.Элементы Цикл
						СхемаКоллекции.Вставить(ирОбщий.ПолучитьПоследнийФрагментЛкс("" + ДоступноеПоле.Поле), ДоступноеПоле.ТипЗначения);
					КонецЦикла;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "ОбщиеРеквизиты" 
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
				Тогда
					Попытка
						ОбщиеРеквизиты = Метаданные.ОбщиеРеквизиты;
					Исключение
						// Платформа 8.2.13 и ниже
						ОбщиеРеквизиты = Новый Массив;
					КонецПопытки; 
					СхемаКоллекции = Новый Массив();
					Для Каждого ОбщийРеквизит Из ОбщиеРеквизиты Цикл
						Если ирОбщий.ЛиОбщийРеквизитИспользуетсяВОбъектеМетаданныхЛкс(ОбщийРеквизит, МетаданныеРодителя) Тогда
							СхемаКоллекции.Добавить(ОбщийРеквизит);
						КонецЕсли; 
					КонецЦикла;
				ИначеЕсли Истина //
					И СтрокаОписанияВида.ИмяКоллекции = "Свойства" 
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектXDTO")
				Тогда
					СхемаКоллекции = МетаданныеРодителя.Свойства();
				ИначеЕсли Истина //
					И СтрокаОписанияВида.ИмяКоллекции = "Свойства" 
					И ТипЗнч(МетаданныеРодителя) = Тип("СвойствоXDTO")
				Тогда
					//СхемаКоллекции = МетаданныеРодителя.ОбъектВладелец[МетаданныеРодителя.Имя].Свойства(); // Исправлено 31.07.2012
					СхемаКоллекции = МетаданныеРодителя.Тип.Свойства;
				#Если Клиент Тогда
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "Реквизиты" 
					И ТипЗнч(МетаданныеРодителя) = Тип("Форма")
				Тогда
					МассивИмен = ПолучитьМассивИменРеквизитовФормы(МетаданныеРодителя);
					КоллекцияЗначений = Новый Структура;
					Для Каждого ИмяРеквизита Из МассивИмен Цикл
						КоллекцияЗначений.Вставить(ИмяРеквизита, МетаданныеРодителя[ИмяРеквизита]);
					КонецЦикла;
				ИначеЕсли Ложь
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "ЭлементыФормы" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Форма"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "ВсеЭлементыФормы" 
						И ТипЗнч(МетаданныеРодителя) = Тип("УправляемаяФорма"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Страницы" 
						И ТипЗнч(МетаданныеРодителя) = Тип("Панель"))
					Или (Истина
						И СтрокаОписанияВида.ИмяКоллекции = "Кнопки" 
						И (Ложь
							Или ТипЗнч(МетаданныеРодителя) = Тип("КнопкаКоманднойПанели")
							Или ТипЗнч(МетаданныеРодителя) = Тип("КнопкиКоманднойПанели")))
				Тогда
					КоллекцияЗначений = МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции];
				#КонецЕсли 
				//ИначеЕсли СтрокаОписанияВида.ИмяКоллекции = "Оформление" Тогда
				//	Для Каждого МетаОбщийМодуль Из МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции] Цикл
				//		Если МетаОбщийМодуль.Глобальный Тогда
				//			Продолжить;
				//		КонецЕсли;
				//		СхемаКоллекции.Вставить(МетаОбщийМодуль.Имя);
				//	КонецЦикла;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "ОбщиеМодули"
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданныхКонфигурация") //
				Тогда
					КоллекцияЗначений = Новый Структура();
					Для Каждого МетаОбщийМодуль Из МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции] Цикл
						Если МетаОбщийМодуль.Глобальный Тогда
							Продолжить;
						КонецЕсли;
						Если ирОбщий.СтрокиРавныЛкс(МетаОбщийМодуль.Имя, Слово) Тогда
							Попытка
								ОбщийМодуль = Вычислить(МетаОбщийМодуль.Имя);
							Исключение
								ОбщийМодуль = Неопределено;
							КонецПопытки; 
						Иначе
							// В больших или содержащих ошибки конфигурациях компиляция неглобальных общих модулей неудобна
							//Попытка
							//	ОбщийМодуль = Вычислить(МетаОбщийМодуль.Имя);
							//Исключение
							//	ОбщийМодуль = Неопределено;
							//КонецПопытки; 
							//КоллекцияЗначений.Вставить(МетаОбщийМодуль.Имя, ОбщийМодуль);
							//
							Попытка
								Выполнить("Если Ложь Тогда "  + МетаОбщийМодуль.Имя + ".Й() КонецЕсли");
								ОбщийМодуль = Неопределено;
							Исключение
								Продолжить;
							КонецПопытки;
						КонецЕсли; 
						КоллекцияЗначений.Вставить(МетаОбщийМодуль.Имя, ОбщийМодуль);
					КонецЦикла;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "ВидыСубконто"
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")  //
				Тогда
					Для Счетчик = 1 По МетаданныеРодителя.ПланСчетов.МаксКоличествоСубконто Цикл
						СхемаКоллекции.Вставить(Строка(Счетчик), МетаданныеРодителя.ПланСчетов.ВидыСубконто);
					КонецЦикла;
				ИначеЕсли СтрокаОписанияВида.ИмяКоллекции = "Движения" Тогда
					Если ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных") Тогда
						Для Каждого Движение Из МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции] Цикл
							МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(Движение.ПолноеИмя());
							СхемаКоллекции.Вставить(Движение.Имя, 
								Новый ОписаниеТипов(МассивФрагментов[0] + "НаборЗаписей." + МассивФрагментов[1]));
						КонецЦикла;
					ИначеЕсли Истина
						И Слово <> Неопределено
						И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданныхКонфигурация") //
					Тогда 
						МетаданныеРегистра = Метаданные.РегистрыСведений.Найти(Слово);
						Если МетаданныеРегистра = Неопределено Тогда
							МетаданныеРегистра = Метаданные.РегистрыНакопления.Найти(Слово);
						КонецЕсли;  
						Если МетаданныеРегистра = Неопределено Тогда
							МетаданныеРегистра = Метаданные.РегистрыБухгалтерии.Найти(Слово);
						КонецЕсли;  
						Если МетаданныеРегистра = Неопределено Тогда
							МетаданныеРегистра = Метаданные.РегистрыРасчета.Найти(Слово);
						КонецЕсли;  
						Если МетаданныеРегистра <> Неопределено Тогда
							МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(МетаданныеРегистра.ПолноеИмя());
							СхемаКоллекции.Вставить(МассивФрагментов[1], 
								Новый ОписаниеТипов(МассивФрагментов[0] + "НаборЗаписей." + МассивФрагментов[1]));
						КонецЕсли;  
					КонецЕсли;
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "ТочкиМаршрута"
					И ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
				Тогда
					КоллекцияЗначений = ирОбщий.ПолучитьМенеджерЛкс(МетаданныеРодителя)[СтрокаОписанияВида.ИмяКоллекции];
				ИначеЕсли Истина
					И СтрокаОписанияВида.ИмяКоллекции = "<Имя коллекции метаданных>"
					И (Ложь
						Или ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных")
						Или ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданныхКонфигурация"))
				Тогда
					ИмяКоллекцииОбъектовМетаданных = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИмяОбщегоТипа,
						МаркерКоллекцииОбъектовМетаданных + ": ", , Ложь);
					Если ЗначениеЗаполнено(ИмяКоллекцииОбъектовМетаданных) Тогда
						СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(, ИмяКоллекцииОбъектовМетаданных);
						Если СтрокаКорневогоТипа <> Неопределено Тогда
							//КоллекцияЗначений = МетаданныеРодителя[ИмяКоллекцииОбъектовМетаданных];
							Попытка
								КоллекцияЗначений = МетаданныеРодителя[РодительскаяСтруктураТипа.СтрокаОписания.Слово];
							Исключение
								ИнформацияОбОшибке = ИнформацияОбОшибке(); // Для отладки
							КонецПопытки;
						КонецЕсли;
					Иначе 
						КоллекцияЗначений = МетаданныеРодителя;
					КонецЕсли;
				ИначеЕсли Истина
					//И СтрокаОписанияВида.ИмяКоллекции = "<Имя коллекции метаданных>"
					И Это2iS
					И (Ложь
						Или ТипЗнч(МетаданныеРодителя) = Тип("СправочникСсылка.КонфигурацииМетаданных2iS")
						Или ТипЗнч(МетаданныеРодителя) = Тип("СправочникСсылка.ОбъектыМетаданных2iS"))
				Тогда
					Если СтрокаОписанияВида.ИмяКоллекции = "<Имя коллекции метаданных>" Тогда 
						ИмяКоллекцииОбъектовМетаданных = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИмяОбщегоТипа,
							МаркерКоллекцииОбъектовМетаданных + ": ", , Ложь);
					Иначе
						ИмяКоллекцииОбъектовМетаданных = СтрокаОписанияВида.ИмяКоллекции;
					КонецЕсли;
					Если ЗначениеЗаполнено(ИмяКоллекцииОбъектовМетаданных) Тогда
						СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(, ИмяКоллекцииОбъектовМетаданных);
						Запрос = Новый Запрос;
						Если СтрокаКорневогоТипа <> Неопределено Тогда
							//лИмяКоллекции = РодительскаяСтруктураТипа.СтрокаОписания.Слово;
							Если ИмяКоллекцииОбъектовМетаданных = "Реквизиты" Тогда
								ТекстЗапроса = "ВЫБРАТЬ Наименование КАК Имя, Типы Как Значение ИЗ Справочник.СвойстваМетаданных2iS 
								|ГДЕ Владелец = &Владелец И Вид <> ЗНАЧЕНИЕ(Перечисление.ВидыСвойств.Свойство)";
								Запрос.Текст = ТекстЗапроса;
								Запрос.УстановитьПараметр("Владелец", МетаданныеРодителя);
								Выборка = Запрос.Выполнить().Выбрать();
								Пока Выборка.Следующий() Цикл
									СхемаКоллекции[Выборка.Имя] = Выборка.Значение.Выгрузить().ВыгрузитьКолонку("Тип");
								КонецЦикла;
							Иначе
								ТекстЗапроса = "ВЫБРАТЬ Имя, Ссылка КАК Значение ИЗ Справочник.ОбъектыМетаданных2iS 
								|ГДЕ Владелец = &Владелец И Родитель.Наименование = &ИмяРодителя";
								Запрос.УстановитьПараметр("ИмяРодителя", ИмяКоллекцииОбъектовМетаданных);
								Запрос.Текст = ТекстЗапроса;
								Запрос.УстановитьПараметр("Владелец", МетаданныеРодителя);
								Выборка = Запрос.Выполнить().Выбрать();
								Пока Выборка.Следующий() Цикл
									СхемаКоллекции[Выборка.Имя] = Выборка.Значение;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
					Иначе
						//КоллекцияЗначений = МетаданныеРодителя;
					КонецЕсли;
				ИначеЕсли Истина
					//И СтрокаОписанияВида.ИмяКоллекции = "<Имя коллекции метаданных>"
					И ЭтоИнтеграция
					И (Ложь
						Или ТипЗнч(МетаданныеРодителя) = Тип("СправочникСсылка.КонфигурацииМетаданныхИис")
						Или ТипЗнч(МетаданныеРодителя) = Тип("СправочникСсылка.МетаданныеИис"))
				Тогда
					Если СтрокаОписанияВида.ИмяКоллекции = "<Имя коллекции метаданных>" Тогда 
						ИмяКоллекцииОбъектовМетаданных = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИмяОбщегоТипа,
							МаркерКоллекцииОбъектовМетаданных + ": ", , Ложь);
					Иначе
						ИмяКоллекцииОбъектовМетаданных = СтрокаОписанияВида.ИмяКоллекции;
					КонецЕсли;
					Если ЗначениеЗаполнено(ИмяКоллекцииОбъектовМетаданных) Тогда
						СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(, ИмяКоллекцииОбъектовМетаданных);
						Запрос = Новый Запрос;
						Если СтрокаКорневогоТипа <> Неопределено Тогда
							//лИмяКоллекции = РодительскаяСтруктураТипа.СтрокаОписания.Слово;
							Если ИмяКоллекцииОбъектовМетаданных = "Реквизиты" Тогда
								ТекстЗапроса = "ВЫБРАТЬ Наименование КАК Имя, Типы Как Значение ИЗ Справочник.СвойстваМетаданныхИис 
								|ГДЕ КонфигурацияМетаданных = &Владелец И Вид <> ЗНАЧЕНИЕ(Перечисление.ВидыСвойствМетаданныхИис.Свойство)";
								Запрос.Текст = ТекстЗапроса;
								Запрос.УстановитьПараметр("Владелец", МетаданныеРодителя);
								Выборка = Запрос.Выполнить().Выбрать();
								Пока Выборка.Следующий() Цикл
									СхемаКоллекции[Выборка.Имя] = Выборка.Значение.Выгрузить().ВыгрузитьКолонку("Тип");
								КонецЦикла;
							Иначе
								ТекстЗапроса = "ВЫБРАТЬ Имя, Ссылка КАК Значение ИЗ Справочник.МетаданныеИис 
								|ГДЕ КонфигурацияМетаданных = &Владелец И ТипМетаданных.ИмяМножественное = &ИмяРодителя";
								Запрос.УстановитьПараметр("ИмяРодителя", ИмяКоллекцииОбъектовМетаданных);
								Запрос.Текст = ТекстЗапроса;
								Запрос.УстановитьПараметр("Владелец", МетаданныеРодителя);
								Выборка = Запрос.Выполнить().Выбрать();
								Пока Выборка.Следующий() Цикл
									СхемаКоллекции[Выборка.Имя] = Выборка.Значение;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
					Иначе
						//КоллекцияЗначений = МетаданныеРодителя;
					КонецЕсли;
				Иначе
					Если МассивИсключенийИменКоллекций.НайтиПоЗначению(СтрокаОписанияВида.ИмяКоллекции) <> Неопределено Тогда 
						Продолжить;
					КонецЕсли;
					Попытка
						СхемаКоллекции = МетаданныеРодителя[СтрокаОписанияВида.ИмяКоллекции];
					Исключение
						Продолжить;
					КонецПопытки;
				КонецЕсли;
				
				Если КоллекцияЗначений = Неопределено Тогда
					КоллекцияЗначений = СхемаКоллекции;
					Если Слово <> Неопределено Тогда 
						ЭлементСхемы = Неопределено;
						Если Ложь
							Или ТипЗнч(КоллекцияЗначений) = Тип("Структура")
							Или ТипЗнч(КоллекцияЗначений) = Тип("Соответствие")
						Тогда
							Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
								Если ЭлементКоллекции.Ключ = ИмяТекущегоСлова Тогда
									ЭлементСхемы = ЭлементКоллекции.Значение;
									Прервать;
								КонецЕсли;
							КонецЦикла;
						Иначе
							Попытка
								ЭлементСхемы = КоллекцияЗначений.Найти(ИмяТекущегоСлова);
							Исключение КонецПопытки;
							Если ЭлементСхемы = Неопределено Тогда
								Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
									Если ЭлементКоллекции.Имя = ИмяТекущегоСлова Тогда
										ЭлементСхемы = ЭлементКоллекции;
										Прервать;
									КонецЕсли;
								КонецЦикла;
							КонецЕсли;
						КонецЕсли;
						КоллекцияЗначений = Новый Структура;
						Если ЭлементСхемы <> Неопределено Тогда
							КоллекцияЗначений.Вставить(ИмяТекущегоСлова, ЭлементСхемы); 
						КонецЕсли;
					КонецЕсли;
				Иначе
					Если Слово <> Неопределено Тогда
						Попытка
							ЭлементСхемы = КоллекцияЗначений[ИмяТекущегоСлова];
						Исключение
						КонецПопытки;
						КоллекцияЗначений = Новый Структура;
						Если ЭлементСхемы <> Неопределено Тогда
							КоллекцияЗначений.Вставить(ИмяТекущегоСлова, ЭлементСхемы); 
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				// 18.03.2012
				Если КоллекцияЗначений = Неопределено Тогда
					КоллекцияЗначений = Новый Массив();
				КонецЕсли; 
				
				Для Каждого ЭлементКоллекции Из КоллекцияЗначений Цикл
					Если ТипЗнч(ЭлементКоллекции) = Тип("КлючИЗначение") Тогда 
						ИмяСвойства = ЭлементКоллекции.Ключ;
						ЗначениеСвойства = ЭлементКоллекции.Значение;
					Иначе 
						ИмяСвойства = ЭлементКоллекции.Имя;
						ЗначениеСвойства = ЭлементКоллекции;
					КонецЕсли;
					КонечноеСлово = СтрЗаменить(СтрокаВида.Слово, ИмяЭлементаКоллекции, ИмяСвойства);
					МассивТипов = Новый Массив;
					ОписаниеТиповЗначения = Неопределено;
					Если СхемаКоллекции.Количество() > 0 Тогда
						Если Ложь
							Или СтрокаВида.ТипЗначения = "Произвольный"
							Или СтрокаВида.ТипЗначения = "Набор записей регистра"
							Или Найти(СтрокаВида.ТипЗначения, "<") > 0
						Тогда 
							Если ТипЗнч(ЗначениеСвойства) = Тип("ОписаниеТипов") Тогда
								ОписаниеТиповЗначения = ЗначениеСвойства;
							КонецЕсли;
							Если Истина
								И ЯзыкПрограммы = 1
								И РодительскаяСтруктураТипа.ТипЯзыка <> "ЗначениеВЗапросе"
								И КорневойТипРодителя <> Неопределено
							Тогда 
								ДоступноеПолеСлова = ПостроительЗапросаРодителя.ДоступныеПоля.Найти(КонечноеСлово);
								Если ДоступноеПолеСлова = Неопределено Тогда
									Продолжить;
								КонецЕсли;
								Если ДоступноеПолеСлова.ТипЗначения <> Новый ОписаниеТипов("ТаблицаЗначений") Тогда
									ОписаниеТиповЗначения = ДоступноеПолеСлова.ТипЗначения;
								КонецЕсли; 
							КонецЕсли;
							Если Истина 
								И ОписаниеТиповЗначения = Неопределено
								И СтрокаОписанияВида.ИмяКоллекции <> "КритерииОтбора"
								И СтрокаОписанияВида.ИмяКоллекции <> "ПланыВидовХарактеристик"
							Тогда
								Попытка 
									ОписаниеТиповЗначения = ЗначениеСвойства.Тип;
								Исключение
								КонецПопытки;
								Если ТипЗнч(ОписаниеТиповЗначения) <> Тип("ОписаниеТипов") Тогда
									ОписаниеТиповЗначения = Неопределено;
								КонецЕсли;
							КонецЕсли;
							Если ТипЗнч(ОписаниеТиповЗначения) = Тип("ОписаниеТипов") Тогда
								МассивТипов = ОписаниеТиповЗначения.Типы();
							ИначеЕсли ТипЗнч(ЗначениеСвойства) = Тип("Массив") Тогда
								МассивТипов = ЗначениеСвойства;
							КонецЕсли;
						КонецЕсли;
					Иначе
						МассивТипов = ирОбщий.БыстрыйМассивЛкс(ТипЗнч(ЗначениеСвойства));
					КонецЕсли;
					ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
					Если Истина
						//И ОписаниеТиповЗначения <> Неопределено
						И МассивТипов.Количество() > 0
						И СтрокаОписанияВида.ИмяКоллекции <> "<Имя коллекции метаданных>"
						И (Ложь
							Или СтрокаОписанияВида.ИмяКоллекции <> "Константы"
							Или ЯзыкПрограммы = 1)
					Тогда
						ШаблонСтруктурыТипа = Новый Структура("СтрокаОписания, ТипЯзыка, Метаданные, ДержательМетаданных");
						ШаблонСтруктурыТипа.СтрокаОписания = СтрокаВида;
						ШаблонСтруктурыТипа.ТипЯзыка = РодительскаяСтруктураТипа.ТипЯзыка;
						ШаблонСтруктурыТипа.ДержательМетаданных = РодительскаяСтруктураТипа.ДержательМетаданных;
						//ШаблонСтруктурыТипа.Метаданные = МетаданныеРодителя;
						Для Каждого Тип Из МассивТипов Цикл
							
							//Если Истина
							//	И Тип = ТипЗнч(ЗначениеСвойства)
							//	И (Ложь
							//		Или мМассивТиповВключающихМетаданные.Найти(Тип) <> Неопределено 
							//		Или мМассивТиповЭлементовУправления.Найти(Тип) <> Неопределено)
							//Тогда 
							//	ШаблонСтруктурыТипа.Метаданные = ЗначениеСвойства;
							//	СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзЗначения(ЗначениеСвойства, ЯзыкПрограммы, ШаблонСтруктурыТипа);
							//Иначе
							//	ШаблонСтруктурыТипа.Метаданные = МетаданныеРодителя;
							//	СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, ЯзыкПрограммы, ШаблонСтруктурыТипа);
							//КонецЕсли;
							Если Истина
								И Тип = ТипЗнч(ЗначениеСвойства)
								//И (Ложь
								//	Или мМассивТиповВключающихМетаданные.Найти(Тип) <> Неопределено 
								//	Или мМассивТиповЭлементовУправления.Найти(Тип) <> Неопределено)
							Тогда 
								ШаблонСтруктурыТипа.Метаданные = ЗначениеСвойства;
								СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзЗначения(ЗначениеСвойства, ЯзыкПрограммы, ШаблонСтруктурыТипа);
							ИначеЕсли Истина
								И Это2iS
								И ТипЗнч(Тип) = Тип("СправочникСсылка.ОбъектыМетаданных2iS") 
							Тогда 
								СтруктураТипаСвойства = ПолучитьНовуюСтруктуруТипа();
								СтруктураТипаСвойства.Метаданные = Тип;
								ТипОбъект = КэшОбъект(Тип);
								ОбъектСистемы = ТипОбъект.ОбъектСистемы;
								Расширение = Вычислить("Ядро2iS.ПолучитьРасширениеСсылкиОбъектаСистемы(ОбъектСистемы)");
								Если ЗначениеЗаполнено(Расширение) Тогда
									СтруктураТипаСвойства.ИмяОбщегоТипа = Расширение.ИмяОбщегоТипа;
								Иначе
									СтруктураТипаСвойства.ИмяОбщегоТипа = ТипОбъект.Наименование;
								КонецЕсли; 
							ИначеЕсли Истина
								И ЭтоИнтеграция
								И ТипЗнч(Тип) = Тип("СправочникСсылка.МетаданныеИис") 
							Тогда 
								СтруктураТипаСвойства = ПолучитьНовуюСтруктуруТипа();
								СтруктураТипаСвойства.Метаданные = Тип;
								ТипОбъект = КэшОбъект(Тип);
								//ОбъектСистемы = ТипОбъект.ОбъектСистемы;
								//Расширение = Вычислить("Ядро2iS.ПолучитьРасширениеСсылкиОбъектаСистемы(ОбъектСистемы)");
								//Если ЗначениеЗаполнено(Расширение) Тогда
								//	СтруктураТипаСвойства.ИмяОбщегоТипа = Расширение.ИмяОбщегоТипа;
								//Иначе
									СтруктураТипаСвойства.ИмяОбщегоТипа = ТипОбъект.Наименование;
								//КонецЕсли; 
							Иначе
								ШаблонСтруктурыТипа.Метаданные = МетаданныеРодителя;
								СтруктураТипаСвойства = ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, ЯзыкПрограммы, ШаблонСтруктурыТипа);
							КонецЕсли;
							
							ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипаСвойства);
						КонецЦикла;
					Иначе
						СтруктураТипаСвойства = ПолучитьНовуюСтруктуруТипа();
						ЗаполнитьЗначенияСвойств(СтруктураТипаСвойства, РодительскаяСтруктураТипа, "ТипЯзыка");
						Если РодительскаяСтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда
							СтруктураТипаСвойства.ИмяОбщегоТипа = СтрокаВида.Слово;
							Если СтрокаВида.ТипКонтекста <> "" Тогда
								СтруктураТипаСвойства.ИмяОбщегоТипа = СтрокаВида.ТипКонтекста + "." + СтруктураТипаСвойства.ИмяОбщегоТипа;
							КонецЕсли;
						Иначе
							СтруктураТипаСвойства.ИмяОбщегоТипа = СтрокаВида.ТипЗначения;
							СтруктураТипаСвойства.СтрокаОписания = СтрокаВида;
						КонецЕсли;
						СтруктураТипаСвойства.Метаданные = ЗначениеСвойства;
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипаСвойства);
					КонецЕсли;
					ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, КонечноеСлово, СтрокаВида.ТипСлова, ТаблицаСтруктурТипов);
				КонецЦикла;
			КонецЦикла;
			//
		КонецЕсли;
	КонецЦикла;
	Если Истина
		// Для того, чтобы постоянно не присваивался тип <ОбщийМодуль>
		И ИмяОбщегоТипа <> "Глобальный контекст"
		И НайденныеСтроки.Количество() > 0 
	Тогда
		Если Истина
			И Слово <> Неопределено
			И ВнутренняяТаблицаСлов.Количество() = 0
			И НайденныеСтроки.Количество() = 1 
		Тогда
			// Шаблон только один. Берем его даже если имя элемента коллекции не подошло.
			СтрокаВида = НайденныеСтроки[0];
			СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
			СтруктураТипа.ИмяОбщегоТипа = СтрокаВида.ТипЗначения;
			СтруктураТипа.СтрокаОписания = СтрокаВида;
			СтруктураТипа.Метаданные = МетаданныеРодителя;
			ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
			ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
			ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаВида.Слово, СтрокаВида.ТипСлова, ТаблицаСтруктурТипов);
		КонецЕсли;
	КонецЕсли;
	Возврат ВнутренняяТаблицаСлов;
	
КонецФункции // ПолучитьВнутреннююТаблицуМетаданныхСлов()

// Получает внутреннюю таблицу предопределенных слов заданного родительского типа.
//
// Параметры:
//  РодительскаяСтруктураТипа – Структура;
//  *Слово       – Строка, *Неопределено – для отбора;
//  *ТипСлова    – Строка, *Неопределено – для отбора;
//  *ВиртуальнаяТаблица - Структура, *Неопределено - описание виртуальной таблицы;
//  *ЯзыкПрограммы - *Число, 0;
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов".
//
Функция ПолучитьВнутреннююТаблицуПредопределенныхСлов(РодительскаяСтруктураТипа,
	Слово = Неопределено, ТипСлова = Неопределено, ВиртуальнаяТаблица = Неопределено, ЯзыкПрограммы = 0,
	Конфигурация = Неопределено) Экспорт 
	
	ВнутренняяТаблицаСлов = ПолучитьНовуюВнутреннююТаблицуСлов();
	
	КлючПоискаКонструктора = Новый Структура;
	Если РодительскаяСтруктураТипа.Конструктор Тогда
		КлючПоискаКонструктора = Новый Структура("ЕстьКонструктор, ЯзыкПрограммы, НСлово", Истина, ЯзыкПрограммы);
	КонецЕсли;
	
	ИмяОбщегоТипа = РодительскаяСтруктураТипа.ИмяОбщегоТипа; 
	Если НРег(ИмяОбщегоТипа) = НРег(МаркерCOMОбъекта + ".{V" + ИДВерсииПлатформы + ".COMConnector}") Тогда 
		РодительскаяСтруктураТипа.ИмяОбщегоТипа = "COM-соединитель";
	ИначеЕсли НРег(ИмяОбщегоТипа) = НРег(МаркерCOMОбъекта + ".{V" + ИДВерсииПлатформы + ".Application}") Тогда 
		РодительскаяСтруктураТипа.ИмяОбщегоТипа = "Automation сервер";
	КонецЕсли;
	МассивОбщихТипов = ПолучитьТаблицуОбщихТиповСтруктурыТипа(РодительскаяСтруктураТипа);
	
	Для Каждого СтрокаОбщегоТипа Из МассивОбщихТипов Цикл
		ИмяОбщегоТипа = СтрокаОбщегоТипа.ИмяОбщегоТипа;
		МетаданныеРодителя = СтрокаОбщегоТипа.Метаданные;
		КорневойТипРодителя = Неопределено;
		ПостроительЗапросаРодителя = Неопределено;
		ТипМетаданныхРодителя = ТипЗнч(МетаданныеРодителя);
		Если Истина
			//И
			И (Ложь
				Или ТипМетаданныхРодителя = Тип("ОбъектМетаданных")
				Или (Истина
					И Это2iS
					И (Ложь
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.ОбъектыМетаданных2iS")
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.СвойстваМетаданных2iS")))
				Или (Истина
					И ЭтоИнтеграция
					И (Ложь
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.МетаданныеИис")
						Или ТипМетаданныхРодителя = Тип("СправочникСсылка.СвойстваМетаданныхИис"))))
			И РодительскаяСтруктураТипа.ТипЯзыка <> "ИмяТипа"
		Тогда 
			Если ТипМетаданныхРодителя = Тип("ОбъектМетаданных") Тогда
				КорневойТипРодителя = ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(МетаданныеРодителя);
			Иначе
				КорневойТипРодителя = ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(КэшОбъект(МетаданныеРодителя).ПолноеИмя);
			КонецЕсли; 
			ПостроительЗапросаРодителя = ПолучитьПостроительЗапросаПоСтруктуреТипа(СтрокаОбщегоТипа,
				РодительскаяСтруктураТипа.ВиртуальнаяТаблица);
		КонецЕсли;
		
		НайденныеСтроки = Неопределено;
		
		#Если Клиент Тогда	
		// COM-объекты
		Если Найти(ИмяОбщегоТипа, МаркерCOMОбъекта) = 1 Тогда
			ИмяБиблиотеки = "";
			ИнфоТипа = ПолучитьИнфоТипаCOMОбъекта(МетаданныеРодителя, ИмяОбщегоТипа, ИмяБиблиотеки);
			Если ИнфоТипа = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			//Если ИмяCOMКласса = "" Тогда 
			//	Если Описатель.Parent.Name = "V" + ИДВерсииПлатформы Тогда 
			//		ИмяОбщегоТипа = "COM-соединитель";
			//	КонецЕсли;
			//КонецЕсли;
			НайденныеСтроки = ТаблицаКонтекстов.СкопироватьКолонки();
			//Для Счетчик = 1 По ИнфоТипа.Members.Count Цикл
			//	Член = ИнфоТипа.Members(Счетчик);
			Если НРег(ИнфоТипа.TypeKindString) = "coclass" Тогда
				МассивИнфоТипа = ИнфоТипа.Interfaces;
			Иначе
				МассивИнфоТипа = Новый Массив;
				МассивИнфоТипа.Добавить(ИнфоТипа);
			КонецЕсли;
			Для Каждого ИнфоТипа Из МассивИнфоТипа Цикл
				Для Каждого Член Из ИнфоТипа.Members Цикл
					ИмяЧлена = Член.Name;
					Если Член.InvokeKind = 1 Тогда 
						лТипСлова = "Метод";
					Иначе
						лТипСлова = "Свойство";
					КонецЕсли;
					Если Слово <> Неопределено Тогда
						Если Не ирОбщий.СтрокиРавныЛкс(Слово, ИмяЧлена) Тогда
							Продолжить;
						КонецЕсли; 
						Если Не ирОбщий.СтрокиРавныЛкс(ТипСлова, лТипСлова) Тогда
							Продолжить;
						КонецЕсли; 
					КонецЕсли; 
					Если Член.AttributeMask = 1 Тогда
						// Это члены IDispatch
						Продолжить;
					КонецЕсли; 
					СтруктураКлюча = Новый Структура("НСлово, ТипСлова", НРег(ИмяЧлена), лТипСлова);
					НайденныеСтроки2 = НайденныеСтроки.НайтиСтроки(СтруктураКлюча);
					Если НайденныеСтроки2.Количество() > 0 Тогда
						СтрокаКонтекста = НайденныеСтроки2[0];
						//СтрокаКонтекста.ТипЗначения = СтрокаКонтекста.ТипЗначения + ", " + Член.ReturnType.VarType;
					Иначе
						СтрокаКонтекста = НайденныеСтроки.Добавить();
						ЗаполнитьЗначенияСвойств(СтрокаКонтекста, СтруктураКлюча);
						СтрокаКонтекста.Слово = ИмяЧлена;
						СтрокаКонтекста.ТипЗначения = ПолучитьТипЗначенияЧленаИнтерфейса(ИмяБиблиотеки, Член.ReturnType);
					КонецЕсли;
					//Член.Parameters.Count + " // " + 
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		#КонецЕсли
		
		Если НайденныеСтроки = Неопределено Тогда 
			СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы, ТипЯзыка",
				ИмяОбщегоТипа, ЯзыкПрограммы, РодительскаяСтруктураТипа.ТипЯзыка);
			Если ТипСлова <> Неопределено Тогда
				СтруктураКлюча.Вставить("ТипСлова", ТипСлова);
			КонецЕсли;
			Если Слово <> Неопределено Тогда
				СтруктураКлюча.Вставить("НСлово", НРег(Слово));
			КонецЕсли;
			НайденныеСтроки = ТаблицаКонтекстов.НайтиСтроки(СтруктураКлюча);
		КонецЕсли;
		Для Каждого СтрокаСлова Из НайденныеСтроки Цикл
			Если Истина
				И СтрокаСлова.ТипСлова = "Метод" 
				И СтрокаОбщегоТипа.НеВключатьМетоды
			Тогда
				Продолжить;
			КонецЕсли;
			Если РодительскаяСтруктураТипа.Конструктор Тогда 
				КлючПоискаКонструктора.НСлово = НРег(СтрокаСлова.Слово);
				Если ТаблицаОбщихТипов.НайтиСтроки(КлючПоискаКонструктора).Количество() = 0 Тогда 
					Продолжить;
				КонецЕсли;
			КонецЕсли; 
			Если Ложь
				Или СтрокаСлова.ТипСлова = "Событие"
				Или СтрокаСлова.ТипСлова = "Параметр"
				Или СтрокаСлова.ТипСлова = "Конструктор"
			Тогда
				// Это пока не нужно
				Продолжить;
			КонецЕсли;
			ЛиДобавляемСлово = Истина;
			ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
			МассивТиповЗначения = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(СтрокаСлова.ТипЗначения, ", ");
			Для Каждого ИмяОбщегоТипа Из МассивТиповЗначения Цикл
				СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
				СтруктураТипа.СтрокаОписания = СтрокаСлова;
				ЗаполнитьЗначенияСвойств(СтруктураТипа, РодительскаяСтруктураТипа, , "ИмяОбщегоТипа, СтрокаОписания, Метаданные");
				Если Истина
					И ТипЗнч(МетаданныеРодителя) <> Тип("COMОбъект")
					//И ИмяОбщегоТипа <> 
					//И СтрокаСлова.ТипСлова = "Свойство"
				Тогда
					ЗаполнитьЗначенияСвойств(СтруктураТипа, СтрокаОбщегоТипа, "Метаданные");
				КонецЕсли; 
				Если ИмяОбщегоТипа = "ОбъектМетаданныхКонфигурация" Тогда
					СтруктураТипа.Метаданные = Конфигурация;
				ИначеЕсли ИмяОбщегоТипа = "Отбор" Тогда 
					// %%%% Недокументированная особенность платформы
					КонкретныйТип = ПолучитьСтрокуКонкретногоТипа(СтрокаОбщегоТипа);
					Если Найти(КонкретныйТип, "<") = 0 Тогда
						Попытка
							Образователь = Новый (КонкретныйТип);
							СтруктураТипа.Метаданные = Образователь;
						Исключение
							// Срабатывает для табличных полей
						КонецПопытки;
					КонецЕсли; 
				КонецЕсли;
				СтруктураТипа.ИмяОбщегоТипа = ИмяОбщегоТипа;
				Если ВиртуальнаяТаблица <> Неопределено Тогда
					ЗаполнитьЗначенияСвойств(СтруктураТипа.ВиртуальнаяТаблица, ВиртуальнаяТаблица);
				КонецЕсли;
				
				Если РодительскаяСтруктураТипа.ТипЯзыка = "ИмяТипа" Тогда
					СтруктураТипа.ИмяОбщегоТипа = СтрокаСлова.Слово;
					Если СтрокаСлова.ТипКонтекста <> "" Тогда
						СтруктураТипа.ИмяОбщегоТипа = СтрокаСлова.ТипКонтекста + "." + СтруктураТипа.ИмяОбщегоТипа;
					КонецЕсли;
				КонецЕсли;
				
				Если Истина
					И СтруктураТипа.ИмяОбщегоТипа = "Строка табличной части"
					И Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧасть.") > 0
				Тогда
					СтруктураТипа.ИмяОбщегоТипа = СтрЗаменить(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "ТабличнаяЧасть.", "ТабличнаяЧастьСтрока.");
				КонецЕсли;
				
				МаркерРасширений = "Расширение ";
				Если Истина
					И Лев(РодительскаяСтруктураТипа.ИмяОбщегоТипа, СтрДлина(МаркерРасширений)) = МаркерРасширений
					И СтрокаСлова.Слово = "Значение"
				Тогда
					Если РодительскаяСтруктураТипа.Метаданные <> Неопределено Тогда
						СтруктураТипа = ПолучитьСтруктуруТипаИзЗначения(РодительскаяСтруктураТипа.Метаданные.Значение);
					Иначе
						СтрокаРасширения = ТаблицаРасширенийТипов.Найти(РодительскаяСтруктураТипа.ИмяОбщегоТипа, "Расширение");
						//Если СтрокаРасширения <> Неопределено Тогда
							СтруктураТипа.ИмяОбщегоТипа = СтрокаРасширения.РасширяющийТип;
						//КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				Если Истина
					И МетаданныеРодителя <> Неопределено
					И СтрокаСлова.ТипСлова = "Свойство"
				Тогда
					Если Ложь
						Или (Истина // Нельзя допускать неявного выполнения запроса при обращении к свойству "Результат" построителя
							И СтруктураТипа.ИмяОбщегоТипа = "РезультатЗапроса"
							И ТипЗнч(МетаданныеРодителя) = Тип("ПостроительЗапроса"))
						Или (Истина // Здесь свойство есть у объекта метаданных, но имеет другой смысл
							И СтрокаСлова.Слово = "ВидыСубконто"
							И СтруктураТипа.ИмяОбщегоТипа = "ПланСчетовВидыСубконто.<Имя плана счетов>")
					Тогда
						ЗначениеСвойства = МетаданныеРодителя;
					Иначе
						Если Истина
							И ТипЗнч(МетаданныеРодителя) = Тип("ТабличноеПоле")
							И СтрокаСлова.Слово = "ТекущийРодитель"
						Тогда
							// Антибаг платформы 8.2.16. Вывести в чистом виде не удалось. Падает при вычислении свойства ТекущийРодитель в форме списка РС.ООП_ВаучерыТез
							ЗначениеСвойства = Неопределено;
						Иначе
							Попытка
								ЗначениеСвойства = МетаданныеРодителя[СтрокаСлова.Слово];
							Исключение
								ЗначениеСвойства = Неопределено;
							КонецПопытки;
						КонецЕсли; 
					КонецЕсли; 
					Если ЗначениеСвойства <> Неопределено Тогда
						Если мМассивТиповВключающихМетаданные.Найти(ТипЗнч(ЗначениеСвойства)) <> Неопределено Тогда 
							СтруктураТипа.Метаданные = ЗначениеСвойства;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				// Для методов метаданных нужна специфическая обработка для усечения типов
				Если Истина
					И СтрокаСлова.ТипСлова = "Метод"
					И Лев(ИмяОбщегоТипа, СтрДлина(МаркерОбъектаМетаданных)) = МаркерОбъектаМетаданных
					И СтрокаСлова.Слово = "Родитель"
				Тогда
					Родитель = Неопределено;
					Если ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданных") Тогда
						Родитель = МетаданныеРодителя.Родитель();
					КонецЕсли;
					Если Родитель <> Неопределено Тогда
						МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(Родитель.ПолноеИмя());
						СтруктураТипа.ИмяОбщегоТипа = МаркерОбъектаМетаданных + ": " + МассивФрагментов[МассивФрагментов.ВГраница() - 1];
					Иначе
						СтруктураТипа.ИмяОбщегоТипа = "Неопределено";
					КонецЕсли; 
					СтруктураТипа.Метаданные = Родитель;
					ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					Прервать;
				ИначеЕсли Истина
					И СтрокаСлова.ТипСлова = "Метод"
					И Лев(ИмяОбщегоТипа, СтрДлина(МаркерКоллекцииОбъектовМетаданных)) = МаркерКоллекцииОбъектовМетаданных
					И (Ложь
						Или СтрокаСлова.Слово = "Найти"
						Или СтрокаСлова.Слово = "Получить")
				Тогда
					СтруктураКлюча = Новый Структура("БазовыйТип, ЯзыкПрограммы", ИмяОбщегоТипа, ЯзыкПрограммы);
					НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
					СтруктураТипа.ИмяОбщегоТипа = НайденныеСтроки[0].ТипЭлементаКоллекции;
					ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					Прервать;
				КонецЕсли;
				
				Если КорневойТипРодителя <> Неопределено Тогда 
					ДоступноеПолеСлова = ПостроительЗапросаРодителя.ДоступныеПоля.Найти(СтрокаСлова.Слово);
					// Частные случаи
					Если Ложь
						Или СтрокаСлова.ТипСлова = "Поле"
						Или СтрокаСлова.Слово = "Активность"
						Или СтрокаСлова.Слово = "Владелец"
						Или СтрокаСлова.Слово = "ВидДвижения"
						Или СтрокаСлова.Слово = "Период"
						Или СтрокаСлова.Слово = "Регистратор"
						Или СтрокаСлова.Слово = "МоментВремени"
						Или СтрокаСлова.Слово = "НомерСтроки"
						//Или СтрокаСлова.Слово = "СубконтоДт" // Закомментировано 14.04.2012
						//Или СтрокаСлова.Слово = "СубконтоКт" // Закомментировано 14.04.2012
						Или СтрокаСлова.Слово = "СчетДт"
						Или СтрокаСлова.Слово = "СчетКт"
					Тогда
						Если ДоступноеПолеСлова = Неопределено Тогда
							ЛиДобавляемСлово = Ложь;
						Иначе
							ТипыЗначенияСлова = ДоступноеПолеСлова.ТипЗначения.Типы();
							Для Каждого ТипЗначенияСлова Из ТипыЗначенияСлова Цикл
								ШаблонСтруктурыТипа = Новый Структура("СтрокаОписания, ТипЯзыка");
								ШаблонСтруктурыТипа.СтрокаОписания = СтрокаСлова;
								ЗаполнитьЗначенияСвойств(ШаблонСтруктурыТипа, РодительскаяСтруктураТипа, "ТипЯзыка");
								СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипЗначенияСлова, ЯзыкПрограммы, ШаблонСтруктурыТипа);
								ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
							КонецЦикла;
						КонецЕсли;
						Прервать;
					ИначеЕсли Ложь
						Или (Истина
							И ИмяОбщегоТипа = "КонстантаМенеджер.<Имя константы>" 
							И СтрокаСлова.Слово = "Получить")
						Или (Истина
							И ИмяОбщегоТипа = "КонстантаМенеджерЗначения.<Имя константы>" 
							И СтрокаСлова.Слово = "Значение")
					Тогда
						ТипыЗначенияКонстанты = МетаданныеРодителя.Тип.Типы();
						Для Каждого ТипЗначенияКонстанты Из ТипыЗначенияКонстанты Цикл
							ШаблонСтруктурыТипа = Новый Структура("СтрокаОписания, ТипЯзыка");
							ШаблонСтруктурыТипа.СтрокаОписания = СтрокаСлова;
							ЗаполнитьЗначенияСвойств(ШаблонСтруктурыТипа, РодительскаяСтруктураТипа, "ТипЯзыка");
							СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипЗначенияКонстанты, ЯзыкПрограммы, ШаблонСтруктурыТипа);
							ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
						КонецЦикла;
					ИначеЕсли Истина
						И СтрокаСлова.ТипСлова = "Метод"
						И (Ложь
							Или СтрокаСлова.Слово = "Выгрузить"
							Или СтрокаСлова.Слово = "ВыгрузитьКолонки")
					Тогда 
						КонкретныйТип = ПолучитьСтрокуКонкретногоТипа(СтрокаОбщегоТипа);
						Образователь = Неопределено;
						Если Истина
							И НРег(КонкретныйТип) = Нрег("Табличная часть")
							И ТипЗнч(СтрокаОбщегоТипа.Метаданные) = Тип("ОбъектМетаданных")
						Тогда
							МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(СтрокаОбщегоТипа.Метаданные.ПолноеИмя());
							СсылочныйОбъект = Новый (МассивФрагментов[0] + "Объект." + МассивФрагментов[1]);
							Образователь = СсылочныйОбъект[МассивФрагментов[3]];
						//ИначеЕсли Истина
						//	И НРег(СтрокаОбщегоТипа.ИмяОбщегоТипа) = Нрег("ПланСчетовВидыСубконто.<Имя плана счетов>")
						//	И ТипЗнч(СтрокаОбщегоТипа.Метаданные) = Тип("ОбъектМетаданных")
						//Тогда
						// Тут метаданные от ПВХ уже, а надо сделать чтобы были от плана счетов
						//	МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(СтрокаОбщегоТипа.Метаданные.ПолноеИмя());
						//	СчетОбъект = Новый (МассивФрагментов[0] + "Объект." + МассивФрагментов[1]);
						//	Образователь = Вычислить("СчетОбъект.ВидыСубконто");
						ИначеЕсли Найти(КонкретныйТип, "<") = 0 Тогда
							Попытка
								Образователь = Новый (КонкретныйТип);
							Исключение
								// Срабатывает например для ВидыСубконто
							КонецПопытки;
						КонецЕсли;
						Если Образователь <> Неопределено Тогда
							СтруктураТипа.Метаданные = Образователь.ВыгрузитьКолонки();
						КонецЕсли; 
					ИначеЕсли Истина
						И (Ложь
							Или СтрокаСлова.Слово = "СрезПервых"
							Или СтрокаСлова.Слово = "СрезПоследних")
						И КорневойТипРодителя = "РегистрСведений"
						И МетаданныеРодителя.ПериодичностьРегистраСведений = мМетаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический
					Тогда
						ЛиДобавляемСлово = Ложь;
						Прервать;
					ИначеЕсли Истина
						И (Ложь
							Или СтрокаСлова.Слово = "Остатки"
							Или СтрокаСлова.Слово = "ОстаткиИОбороты")
						И КорневойТипРодителя = "РегистрНакопления"
						И МетаданныеРодителя.ВидРегистра = мМетаданные.СвойстваОбъектов.ВидРегистраНакопления.Обороты
					Тогда
						ЛиДобавляемСлово = Ложь;
						Прервать;
					ИначеЕсли Истина
						И (Ложь
							Или СтрокаСлова.Слово = "ОборотыДтКт")
						И КорневойТипРодителя = "РегистрБухгалтерии"
						И Не МетаданныеРодителя.Корреспонденция
					Тогда
						ЛиДобавляемСлово = Ложь;
						Прервать;
					Иначе
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
					КонецЕсли;
				Иначе
					Если Истина
						И ИмяОбщегоТипа = "Форма" 
						И СтрокаСлова.Слово = "ЭтаФорма"
					Тогда
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, РодительскаяСтруктураТипа, Истина);
					Иначе
						ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа, Ложь);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			Если Не ЛиДобавляемСлово Тогда
				Продолжить;
			КонецЕсли;
			Если ТаблицаСтруктурТипов.Количество() = 0 Тогда
				ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
			КонецЕсли;
			ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаСлова.Слово, СтрокаСлова.ТипСлова, ТаблицаСтруктурТипов);
		КонецЦикла;
	КонецЦикла;
	Возврат ВнутренняяТаблицаСлов;

КонецФункции // ПолучитьВнутреннююТаблицуПредопределенныхСлов()

Функция ПолучитьТипЗначенияЧленаИнтерфейса(ИмяБиблиотеки, ОписаниеРезультата) Экспорт

	//Тест = ПолучитьИмяТипаCOMVariant(Член);
	ИнфоТипаРезультата = ОписаниеРезультата.TypeInfo;
	Если ИнфоТипаРезультата <> Неопределено Тогда
		ТипЗначенияРезультата = ПолучитьПолноеИмяТипаCOMОбъектаИзИнфоТипа(ИнфоТипаРезультата, ИмяБиблиотеки);
	Иначе
		НомерТипа = ОписаниеРезультата.VarType;
		Если НомерТипа = 0 Тогда
			ТипЗначенияРезультата = Неопределено;
		ИначеЕсли НомерТипа = 1 Тогда
			ТипЗначенияРезультата = Null;
		ИначеЕсли НомерТипа >= 2 И НомерТипа <= 5 Тогда
			ТипЗначенияРезультата = "Число";
		ИначеЕсли НомерТипа = 7 Тогда
			ТипЗначенияРезультата = "Дата";
		ИначеЕсли НомерТипа = 8 Тогда
			ТипЗначенияРезультата = "Строка";
		ИначеЕсли НомерТипа = 11 Тогда
			ТипЗначенияРезультата = "Булево";
		ИначеЕсли НомерТипа >= 14 И НомерТипа <= 23 Тогда
			ТипЗначенияРезультата = "Число";
		ИначеЕсли НомерТипа = 24 Тогда
			ТипЗначенияРезультата = "";
		Иначе
			ТипЗначенияРезультата = "Произвольный" + ", " + НомерТипа;
		КонецЕсли; 
	КонецЕсли;

	Возврат ТипЗначенияРезультата;

 //'OLE Automation VARIANT types
 // Enum TliVarType
 // VT_EMPTY = 0  '&H0
 // VT_NULL = 1  '&H1
 // VT_I2 = 2  '&H2
 // VT_I4 = 3  '&H3
 // VT_R4 = 4  '&H4
 // VT_R8 = 5  '&H5
 // VT_CY = 6  '&H6
 // VT_DATE = 7  '&H7
 // VT_BSTR = 8  '&H8
 // VT_DISPATCH = 9  '&H9
 // VT_ERROR = 10  '&HA
 // VT_BOOL = 11  '&HB
 // VT_VARIANT = 12  '&HC
 // VT_UNKNOWN = 13  '&HD
 // VT_DECIMAL = 14  '&HE
 // VT_I1 = 16  '&H10
 // VT_UI1 = 17  '&H11
 // VT_UI2 = 18  '&H12
 // VT_UI4 = 19  '&H13
 // VT_I8 = 20  '&H14
 // VT_UI8 = 21  '&H15
 // VT_INT = 22  '&H16
 // VT_UINT = 23  '&H17
 // VT_VOID = 24  '&H18
 // VT_HRESULT = 25  '&H19
 // VT_PTR = 26  '&H1A
 // VT_SAFEARRAY = 27  '&H1B
 // VT_CARRAY = 28  '&H1C
 // VT_USERDEFINED = 29  '&H1D
 // VT_LPSTR = 30  '&H1E
 // VT_LPWSTR = 31  '&H1F
 // VT_RECORD = 36  '&H24
 // VT_FILETIME = 64  '&H40
 // VT_BLOB = 65  '&H41
 // VT_STREAM = 66  '&H42
 // VT_STORAGE = 67  '&H43
 // VT_STREAMED_OBJECT = 68  '&H44
 // VT_STORED_OBJECT = 69  '&H45
 // VT_BLOB_OBJECT = 70  '&H46
 // VT_CF = 71  '&H47
 // VT_CLSID = 72  '&H48
 // VT_VECTOR = 4096  '&H1000
 // VT_ARRAY = 8192  '&H2000
 // VT_BYREF = 16384  '&H4000
 // VT_RESERVED = 32768  '&H8000
  
КонецФункции

Функция ПолучитьПолноеИмяТипаCOMОбъектаИзИнфоТипа(ИнфоИнтерфейса, ИмяБиблиотеки) Экспорт

	Результат = "COMОбъект.{" + ИмяБиблиотеки + "}." + ИнфоИнтерфейса.Name;
	Возврат Результат;

КонецФункции

Функция ПолучитьПолноеИмяТипаCOMОбъекта(COMОбъект, Знач ПолноеИмяОсновногоКласса = "") Экспорт

	ИнфоИнтерфейса = ПолучитьИнфоТипаCOMОбъекта(COMОбъект, , ПолноеИмяОсновногоКласса);
	Если ИнфоИнтерфейса <> Неопределено Тогда
		Результат = ПолучитьПолноеИмяТипаCOMОбъектаИзИнфоТипа(ИнфоИнтерфейса, ПолноеИмяОсновногоКласса);
	Иначе
		Результат = "COMОбъект";
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьИнфоТипаCOMОбъекта(выхCOMОбъект, Знач ИмяОбщегоТипа = Неопределено, выхПолноеИмяОсновногоКласса = "") Экспорт

	ПолучитьCOMНавигатор();
	Если COMНавигатор = "Отказ" Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(выхCOMОбъект) = Тип("COMОбъект") Тогда 
		Попытка
			COMНавигатор.ResolveAliases = Ложь; // Тут бывает кривой объект без свойств и методов и при выводе строки эта ошибка очень раздражает
			//ИнфоКласса = COMНавигатор.ClassInfoFromObject(выхCOMОбъект); // Этот способ не поддерживается в большинстве классов
			ИнфоИнтерфейса = COMНавигатор.InterfaceInfoFromObject(выхCOMОбъект); // Тут падает для некоторых объектов (например ADODB.Recorset.Fields(*).Precision
		Исключение
			ОписаниеОшибки = ОписаниеОшибки();
			//Сообщить(ОписаниеОшибки);
			Возврат Неопределено;
		КонецПопытки; 
	КонецЕсли; 
	Если ЗначениеЗаполнено(ИмяОбщегоТипа) Тогда
		выхПолноеИмяОсновногоКласса = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ИмяОбщегоТипа, "{", "}", Ложь);
		ИмяОбщегоТипа = СтрЗаменить(ИмяОбщегоТипа, ".{" + выхПолноеИмяОсновногоКласса + "}", ""); 
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(выхПолноеИмяОсновногоКласса) Тогда
		Если ТипЗнч(выхCOMОбъект) = Тип("COMОбъект") Тогда 
			ИмяБиблиотеки = ИнфоИнтерфейса.Parent.Name;
			ИмяОсновногоКласса = мИменаОсновныхКлассовБиблиотекCOM[ИмяБиблиотеки];
			Если ИмяОсновногоКласса = Неопределено Тогда
				ПробныйОбъект = Неопределено;
				Для Каждого Претендент Из ИнфоИнтерфейса.Parent.CoClasses Цикл
					Попытка
						ПробныйОбъект = Новый COMОбъект(ИмяБиблиотеки + "." + Претендент.Name);
					Исключение
						Продолжить;
					КонецПопытки;
					Прервать;
				КонецЦикла;
				Если ПробныйОбъект <> Неопределено Тогда
					ПробныйОбъект = Неопределено;
					ИмяОсновногоКласса = Претендент.Name;
				Иначе
					ИмяОсновногоКласса = "?";
				КонецЕсли; 
				мИменаОсновныхКлассовБиблиотекCOM[ИмяБиблиотеки] = ИмяОсновногоКласса;
			КонецЕсли; 
			выхПолноеИмяОсновногоКласса = ИмяБиблиотеки + "." + ИмяОсновногоКласса;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	Если ИнфоИнтерфейса = Неопределено Тогда
		выхCOMОбъект = ПолучитьОбразецCOMОбъекта(выхПолноеИмяОсновногоКласса);
		Попытка
			ИнфоИнтерфейса = COMНавигатор.InterfaceInfoFromObject(выхCOMОбъект);
		Исключение
			//Сообщить(ОписаниеОшибки());
			Возврат Неопределено;
		КонецПопытки; 
		МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ИмяОбщегоТипа);
		Если МассивФрагментов.Количество() > 1 Тогда
			лИнфоИнтерфейса = ИнфоИнтерфейса.Parent.TypeInfos.NamedItem(МассивФрагментов[1]);
			Если лИнфоИнтерфейса <> Неопределено Тогда
				ИнфоИнтерфейса = лИнфоИнтерфейса;
			Иначе
				// Например для Shell.Application выполняется
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли;
	Возврат ИнфоИнтерфейса;

КонецФункции

Функция ПолучитьОбразецCOMОбъекта(ПолноеИмяОсновногоКлассаCOM) Экспорт

	КлючКэша = НРег(ПолноеИмяОсновногоКлассаCOM);
	Результат = мОбразцыCOMОбъектов[КлючКэша];
	Если Результат <> Неопределено Тогда
		ИнфоИнтерфейса = ПолучитьИнфоТипаCOMОбъекта(Результат,,ПолноеИмяОсновногоКлассаCOM);
		Если ИнфоИнтерфейса = Неопределено Тогда
			// Объект испорчен
			Результат = Неопределено;
		КонецЕсли; 
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		Попытка
			Результат = Новый COMОбъект(ПолноеИмяОсновногоКлассаCOM);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
		мОбразцыCOMОбъектов[КлючКэша] = Результат;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция ПолучитьCOMНавигатор() Экспорт

	Если COMНавигатор = "НеИнициализирован" Тогда
		COMНавигатор = ПолучитьCOMОбъектИзМакета("TLBINF32", "TLI.TLIApplication");
	КонецЕсли;
	Возврат COMНавигатор;

КонецФункции // ПолучитьCOMНавигатор()

Функция ПолучитьТипыЭлементовКоллекции(СтруктураТипаКоллекции, ЯзыкПрограммы = 0) Экспорт
	
	ТипыЭлементовКоллекции = Новый Массив();
	Если Найти(СтруктураТипаКоллекции.ИмяОбщегоТипа, МаркерCOMОбъекта) = 1 Тогда
		ИмяОбщегоТипа = СтруктураТипаКоллекции.ИмяОбщегоТипа;
		ТаблицаСтруктурТипаЭлемента = ПолучитьНовуюТаблицуСтруктурТипа();
		ИмяБиблиотеки = "";
		МетаданныеОбъекта = СтруктураТипаКоллекции.Метаданные;
		ИнфоТипа = ПолучитьИнфоТипаCOMОбъекта(МетаданныеОбъекта, ИмяОбщегоТипа, ИмяБиблиотеки);
		Если ИнфоТипа = Неопределено Тогда
			Возврат ТаблицаСтруктурТипаЭлемента;
		КонецЕсли; 
		Если НРег(ИнфоТипа.TypeKindString) = "coclass" Тогда
			МассивИнфоТипа = ИнфоТипа.Interfaces;
		Иначе
			МассивИнфоТипа = Новый Массив;
			МассивИнфоТипа.Добавить(ИнфоТипа);
		КонецЕсли;
		Для Каждого ИнфоТипа Из МассивИнфоТипа Цикл
			Для Каждого Член Из ИнфоТипа.Members Цикл
				Если Истина
					//И Член.InvokeKind = 1 // метод // почему то иногда у него стоит 2 (например ADODB.Fields)
					И ирОбщий.СтрокиРавныЛкс(Член.Name, "Item") 
				Тогда
					ИнфоТипаЭлемента = Член.ReturnType.TypeInfo;
					ИмяОбщегоТипаЭлемента = ПолучитьТипЗначенияЧленаИнтерфейса(ИмяБиблиотеки, Член.ReturnType);
					ТипыЭлементовКоллекции.Добавить(ИмяОбщегоТипаЭлемента);
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		КонецЦикла;
	Иначе
		СтруктураКлюча = Новый Структура("Слово, ЯзыкПрограммы", СтруктураТипаКоллекции.ИмяОбщегоТипа, ЯзыкПрограммы);
		НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(СтруктураКлюча);
		Если НайденныеСтроки.Количество() > 0 Тогда
			Если НайденныеСтроки[0].ТипЭлементаКоллекции <> "" Тогда
				ТипыЭлементовКоллекции = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(НайденныеСтроки[0].ТипЭлементаКоллекции, ",", Истина);
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ТипыЭлементовКоллекции;

КонецФункции

// Добавляет и заполяет строку в таблицу слов при условии отсутствия там строк по ключу (Слово, ТипСлова)
//
// Параметры:
//  ТаблицаСлов  – ТаблицаЗначений – ПолучитьНовуюВнутреннююТаблицуСлов();
//  Слово        – Строка;
//  ТипСлова     – Строка;
//  ТаблицаСтруктурТипов - ТаблицаЗначений.
//
Функция ДобавитьВТаблицуСлов(ТаблицаСлов, Слово, ТипСлова, ТаблицаСтруктурТипов =  Неопределено) Экспорт

	КлючПоиска = Новый Структура("Слово, ТипСлова", Слово, ТипСлова);
	НайденныеСтроки = ТаблицаСлов.НайтиСтроки(КлючПоиска);
	Если НайденныеСтроки.Количество() > 0 Тогда
		Возврат НайденныеСтроки[0];
	КонецЕсли;
	СтрокаСлова = ТаблицаСлов.Добавить();
	ЗаполнитьЗначенияСвойств(СтрокаСлова, КлючПоиска);
	Если ТаблицаСтруктурТипов <> Неопределено Тогда
		СтрокаСлова.ТаблицаСтруктурТипов = ТаблицаСтруктурТипов;
	КонецЕсли; 
	Возврат СтрокаСлова;

КонецФункции // ДобавитьВТаблицуСлов()

// Получает таблицу слов указанной структуры типа.
//
// Параметры:
// СтруктураТипа – Структура – описание типа.
//
// Возвращаемое значение:
//  ТаблицаЗначений – с колонками "Слово", "ТипСлова", "ТаблицаСтруктурТипов", "Определение".
//
Функция ПолучитьТаблицуСловСтруктурыТипа(СтруктураТипа, ЯзыкПрограммы = 0, Конфигурация = Неопределено, ВнешниеФункцииКомпоновкиДанных = Истина) Экспорт 

	ИнициализацияОписанияМетодовИСвойств();
	ВнутренняяТаблицаСлов = ПолучитьВнутреннююТаблицуПредопределенныхСлов(СтруктураТипа,,,,ЯзыкПрограммы, Конфигурация);
	ВнутренняяТаблицаСлов.Колонки.Добавить("Определение");
	ВнутренняяТаблицаСлов.ЗаполнитьЗначения("Предопределенный", "Определение");
	ВнутренняяТаблицаМетаданныхСлов = ПолучитьВнутреннююТаблицуМетаданныхСлов(СтруктураТипа,,,,ЯзыкПрограммы,, ВнешниеФункцииКомпоновкиДанных);
	ВнутренняяТаблицаМетаданныхСлов.Колонки.Добавить("Определение");
	ВнутренняяТаблицаМетаданныхСлов.ЗаполнитьЗначения("Метаданные", "Определение");
	// ЗагрузитьВТаблицуЗначений()
	Для каждого СтрокаТаблицыИсточника Из ВнутренняяТаблицаМетаданныхСлов Цикл
		СтрокаТаблицыПриемника = ВнутренняяТаблицаСлов.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
	КонецЦикла;
	#Если Клиент Тогда
		// Дополнительные свойства от информатора
		Если Истина
			//И Не ЗначениеЗаполнено(Конфигурация) 
			//И ИДВерсииПлатформы <> "83" // Антибаг информатора. Падает на 8.3
			И (Ложь
				Или ЯзыкПрограммы = 0
				Или (Истина
					И ЯзыкПрограммы = 2
					И ВнешниеФункцииКомпоновкиДанных
					И ирОбщий.ПолучитьПервыйФрагментЛкс(СтруктураТипа.ИмяОбщегоТипа) = "ОбщийМодуль"))
		Тогда
			ЗначениеПолучено = Ложь;
			Если Ложь
				Или СтруктураТипа.ИмяОбщегоТипа = "Глобальный контекст"
				Или СтруктураТипа.ИмяОбщегоТипа = "Локальный контекст"
				Или ирОбщий.ПолучитьПервыйФрагментЛкс(СтруктураТипа.ИмяОбщегоТипа) = "ОбщийМодуль"
			Тогда
				ЗначениеДляИнформатора = Неопределено;
				Если ирОбщий.ПолучитьПервыйФрагментЛкс(СтруктураТипа.ИмяОбщегоТипа) = "ОбщийМодуль" Тогда
					ЗначениеДляИнформатора = СтруктураТипа.Метаданные;
				КонецЕсли; 
				ЗначениеПолучено = Истина;
			Иначе
				КонкретныйТип = ПолучитьСтрокуКонкретногоТипа(СтруктураТипа);
				Попытка
					ЗначениеДляИнформатора = Новый (КонкретныйТип); // Опасно. Возможны падения.
					ЗначениеПолучено = Истина;
				Исключение
				КонецПопытки; 
			КонецЕсли; 
			Если ЗначениеПолучено Тогда
				ВнутренняяТаблицаСлов.Индексы.Добавить("Слово, ТипСлова");
				ТаблицаМетодовИнформатора = ПолучитьТаблицуСвойствОбъектаИнформатором(ЗначениеДляИнформатора, "Метод");
				Для Каждого СтрокаМетода Из ТаблицаМетодовИнформатора Цикл
					НоваяСтрока = ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаМетода.Name, "Метод");
					Если ЗначениеЗаполнено(НоваяСтрока.Определение) Тогда
						Продолжить;
					КонецЕсли; 
					НоваяСтрока.Определение = "Локальный";
					Если СтрокаМетода.Val > 0 Тогда
						НоваяСтрока.ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
						СтруктураТипаРезультата = ПолучитьНовуюСтруктуруТипа();
						СтруктураТипаРезультата.ИмяОбщегоТипа = "Произвольный";
						ЗаполнитьЗначенияСвойств(НоваяСтрока.ТаблицаСтруктурТипов.Добавить(), СтруктураТипаРезультата);
					КонецЕсли; 
				КонецЦикла; 
				ТаблицаСвойствИнформатора = ПолучитьТаблицуСвойствОбъектаИнформатором(ЗначениеДляИнформатора, "Свойство");
				Для Каждого СтрокаСвойства Из ТаблицаСвойствИнформатора Цикл
					НоваяСтрока = ДобавитьВТаблицуСлов(ВнутренняяТаблицаСлов, СтрокаСвойства.Name, "Свойство");
					Если ЗначениеЗаполнено(НоваяСтрока.Определение) Тогда
						Продолжить;
					КонецЕсли; 
					НоваяСтрока.Определение = "Локальный";
					//НоваяСтрока.ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
				КонецЦикла; 
			КонецЕсли; 
		КонецЕсли; 
	#КонецЕсли
		
	Возврат ВнутренняяТаблицаСлов;

КонецФункции // ПолучитьТаблицуСловОбъекта()

// Получает новую структуру типа.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Структура - "ИмяОбщегоТипа", "Метаданные", "СтрокаОписания", "ТипЯзыка", "ВиртуальнаяТаблица".
//
Функция ПолучитьНовуюТаблицуДополнительныхТипов() Экспорт

	ТаблицаСтруктурТипа = Новый ТаблицаЗначений;
	ТаблицаСтруктурТипа.Колонки.Добавить("ИмяОбщегоТипа", Новый ОписаниеТипов("Строка"));
	ТаблицаСтруктурТипа.Колонки.Добавить("Метаданные");
	//ТаблицаСтруктурТипа.Колонки.Добавить("ВключатьСвойства", Новый  ОписаниеТипов("Булево"));
	ТаблицаСтруктурТипа.Колонки.Добавить("НеВключатьМетоды", Новый  ОписаниеТипов("Булево"));
	Возврат ТаблицаСтруктурТипа;

КонецФункции // ПолучитьНовуюТаблицуДополнительныхТипов()

// Получает допустимые типы (строку) из таблицы структур типа.
//
// Параметры:
//  ТаблицаСтруктурТипов – ТаблицаЗначений.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьДопустимыеТипыИзТаблицыСтруктурТипа(ТаблицаСтруктурТипов) Экспорт

	СтрокаСериализованныхТипов = "";
	Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
		СтрокаСериализованныхТипов = СтрокаСериализованныхТипов + ";" + СтруктураТипаВСтрокуВнутр(СтруктураТипа);
	КонецЦикла;
	СтрокаСериализованныхТипов = Сред(СтрокаСериализованныхТипов, 2);
	Возврат СтрокаСериализованныхТипов;

КонецФункции // ПолучитьДопустимыеТипыИзТаблицыСтруктурТипа()

// Получает представление допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка.
//
// Возвращаемое значение:
//  СтрокаПредставления – Строка.
//
Функция ПолучитьПредставлениеДопустимыхТипов(ДопустимыеТипы) Экспорт

	ТаблицаСтруктурТипов = ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов(ДопустимыеТипы);
	СтрокаПредставления = "";
	Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
		СтрокаПредставления = СтрокаПредставления + ", " + ПолучитьСтрокуКонкретногоТипа(СтруктураТипа);
		ТипМетаданных = ТипЗнч(СтруктураТипа.Метаданные);
		Если ТипМетаданных = Тип("КвалификаторыДаты") Тогда 
			Квалификаторы = СтруктураТипа.Метаданные;
			Если Квалификаторы.ЧастиДаты = ЧастиДаты.Время Тогда
				ПредставлениеСоставаДаты = "В";
			ИначеЕсли Квалификаторы.ЧастиДаты = ЧастиДаты.Дата Тогда
				ПредставлениеСоставаДаты = "Д";
			ИначеЕсли Квалификаторы.ЧастиДаты = ЧастиДаты.ДатаВремя Тогда
				ПредставлениеСоставаДаты = "ДВ";
			КонецЕсли;
			СтрокаПредставления = СтрокаПредставления + "(" + ПредставлениеСоставаДаты + ")";
		ИначеЕсли ТипМетаданных = Тип("КвалификаторыСтроки") Тогда 
			Квалификаторы = СтруктураТипа.Метаданные;
			СтрокаПредставления = СтрокаПредставления + "(" 
				+ Квалификаторы.Длина + "," 
				+ ?(Квалификаторы.ДопустимаяДлина = ДопустимаяДлина.Фиксированная, "Ф", "П") + ")";
		ИначеЕсли ТипМетаданных = Тип("КвалификаторыЧисла") Тогда 
			Квалификаторы = СтруктураТипа.Метаданные;
			СтрокаПредставления = СтрокаПредставления + "("
				+ ?(Квалификаторы.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный, "Н", "")
				+ Квалификаторы.Разрядность + "," 
				+ Квалификаторы.РазрядностьДробнойЧасти + ")";
        КонецЕсли; 
	КонецЦикла;
	СтрокаПредставления = Сред(СтрокаПредставления, 3);
	Возврат СтрокаПредставления;

КонецФункции // ПолучитьПредставлениеДопустимыхТипов()

// Получает структуру типа из значения.
//
// Параметры:
//  Значение – Произвольный;
//  *ЯзыкПрограммы - Число, *0;
//  *ШаблонСтруктурыТипа - Структура, *Неопределено - содержит значения по умолчанию для новой структуры типа.
//
// Возвращаемое значение:
//  Структура – структура типа.
//
Функция ПолучитьСтруктуруТипаИзЗначения(Значение, ЯзыкПрограммы = 0, ШаблонСтруктурыТипа = Неопределено) Экспорт
	
	Если Истина
		И ШаблонСтруктурыТипа = Неопределено
		//И (Ложь
		//	#Если Клиент Тогда
		//	Или ТипЗнч(Значение) = Тип("Форма")
		//	Или ТипЗнч(Значение) = Тип("ПолеВвода")
		//	//Или ТипЗнч(Значение) = Тип("КолонкаТабличногоПоля")
		//	Или ТипЗнч(Значение) = Тип("ТабличноеПоле")
		//	#КонецЕсли 
		//	Или ТипЗнч(Значение) = Тип("Структура")
		//	Или ТипЗнч(Значение) = Тип("ТаблицаЗначений")
		//	Или ТипЗнч(Значение) = Тип("ДеревоЗначений")
		//	Или ТипЗнч(Значение) = Тип("ОбъектМетаданных"))
		И мМассивТиповВключающихМетаданные.Найти(ТипЗнч(Значение)) <> Неопределено

	Тогда
		ШаблонСтруктурыТипа = Новый Структура("Метаданные", Значение);
	КонецЕсли; 
	СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(ТипЗнч(Значение), ЯзыкПрограммы, ШаблонСтруктурыТипа);
	Если СтруктураТипа.ИмяОбщегоТипа = "COMОбъект" Тогда
		СтруктураТипа.ИмяОбщегоТипа = ПолучитьПолноеИмяТипаCOMОбъекта(Значение);
	КонецЕсли; 
	ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
	Если Ложь
		Или (Истина
			И ИмяОбщегоТипа = "СтрокаТаблицыЗначений"
			И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("ТаблицаЗначений"))
		Или (Истина
			И ИмяОбщегоТипа = "СтрокаДереваЗначений"
			И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("ДеревоЗначений"))
		Или (Истина
			И ИмяОбщегоТипа = "ВыборкаИзРезультатаЗапроса"
			И ТипЗнч(СтруктураТипа.Метаданные) <> Тип("РезультатЗапроса"))
	Тогда 
		Попытка
			СтруктураТипа.Метаданные = Значение.Владелец();
		Исключение
			// Строка была удалена из коллекции
		КонецПопытки; 
	КонецЕсли;
	Если Ложь
		Или ИмяОбщегоТипа = "ВнешняяОбработкаОбъект.<Имя внешней обработки>"
		Или ИмяОбщегоТипа = "ВнешнийОтчетОбъект.<Имя внешнего отчета>"
	Тогда
		МетаданныеЗначения = Значение.Метаданные();
		ЛиНеУчитыватьПодтип = (ЯзыкПрограммы <> 0) И СтруктураТипа.ТипЯзыка <> "ЗначениеВЗапросе";
		ИмяОбщегоТипа = ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными(ТипЗнч(Значение), МетаданныеЗначения, ЛиНеУчитыватьПодтип);
		СтруктураТипа.Метаданные = МетаданныеЗначения;
		КлючПоиска = Новый Структура("Слово", ИмяОбщегоТипа);
		НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтруктураТипа.ИмяОбщегоТипа = НайденныеСтроки[0].Слово;
			Если СтруктураТипа.СтрокаОписания = Неопределено Тогда
				СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	#Если Клиент Тогда
	МаркерРасширений = "Расширение ";
	Если Ложь
		Или ИмяОбщегоТипа = "Форма"
		Или ИмяОбщегоТипа = "ПолеВвода"
		//Или ИмяОбщегоТипа = "КолонкаТабличногоПоля"
		Или ИмяОбщегоТипа = "ТабличноеПоле"
	Тогда
		РасширяющийТип = Неопределено;
		Если ИмяОбщегоТипа = "Форма" Тогда
			ОсновнойРеквизитФормы = ПолучитьИмяОсновногоРеквизитаФормы(Значение);
			Если ЗначениеЗаполнено(ОсновнойРеквизитФормы) Тогда
			    СтруктураРасширяющегоТипа = ПолучитьСтруктуруТипаИзЗначения(Значение[ОсновнойРеквизитФормы]);
				РасширяющийТип = СтруктураРасширяющегоТипа.ИмяОбщегоТипа;
			КонецЕсли;
		Иначе
			Попытка
				ДанныеЭлементаФормы = Значение.Значение;
			Исключение
				// Случается из-за особенностей платформы. Иногда она убирает это свойство из элемента управления.
			КонецПопытки;
			СтруктураРасширяющегоТипа = ПолучитьСтруктуруТипаИзЗначения(ДанныеЭлементаФормы);
			РасширяющийТип = СтруктураРасширяющегоТипа.ИмяОбщегоТипа;
			Попытка 
				Пустышка = Тип("Перечисление" + СтруктураРасширяющегоТипа.ИмяОбщегоТипа);
				РасширяющийТип = "Системное перечисление";
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		Если РасширяющийТип <> Неопределено Тогда
			Если РасширяющийТип = "ВнешняяОбработкаОбъект.<Имя внешней обработки>" Тогда 
				РасширяющийТип = "ОбработкаОбъект.<Имя обработки>";
			ИначеЕсли РасширяющийТип = "ВнешнийОтчетОбъект.<Имя внешнего отчета>" Тогда 
				РасширяющийТип = "ОтчетОбъект.<Имя отчета>";
			КонецЕсли;
			СтруктураКлюча = Новый Структура("РасширяющийТип, ОсновнойТип", РасширяющийТип, ИмяОбщегоТипа);
			МассивНайденных = ТаблицаРасширенийТипов.НайтиСтроки(СтруктураКлюча);
			Если МассивНайденных.Количество() > 0 Тогда
				СтруктураТипа.ИмяОбщегоТипа = МассивНайденных[0].Расширение;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ИмяОбщегоТипа = "Форма" Тогда 
		СтруктураТипа.ДержательМетаданных = Значение;
	КонецЕсли;

	#КонецЕсли

	Возврат СтруктураТипа;

КонецФункции // ПолучитьСтруктуруТипаИзЗначения()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьУникальныйИдентификаторИзСтроки(Текст) Экспорт

	Цифра = "[a-fA-F0-9]";
	RegExp.Pattern = "(" + ирОбщий.ПолучитьСтрокуПовторомЛкс(Цифра, 32) + ")|(" 
		+ ирОбщий.ПолучитьСтрокуПовторомЛкс(Цифра, 8) + "-" 
		+ ирОбщий.ПолучитьСтрокуПовторомЛкс(Цифра, 4) + "-"
		+ ирОбщий.ПолучитьСтрокуПовторомЛкс(Цифра, 4) + "-"
		+ ирОбщий.ПолучитьСтрокуПовторомЛкс(Цифра, 4) + "-"
		+ ирОбщий.ПолучитьСтрокуПовторомЛкс(Цифра, 12) + ")";
	Вхождения = RegExp.Execute(Текст);
	Если Вхождения.Count > 0 Тогда
		Вхождение = Вхождения.Item(0);
		Если Не ирОбщий.ЛиПустаяПодгруппаRegExpЛкс(Вхождение.SubMatches(1)) Тогда
			УникальныйИдентификатор = Новый УникальныйИдентификатор(Вхождение.SubMatches(1));
		Иначе
			УникальныйИдентификатор = Новый УникальныйИдентификатор(ирОбщий.ПолучитьГУИДПрямойИзИнверсногоЛкс(Вхождение.SubMatches(0)));
		КонецЕсли;
	КонецЕсли;
	Возврат УникальныйИдентификатор;

КонецФункции // ПолучитьУникальныйИдентификаторИзСтроки()

// Неполный сериализатор структуры типа.
//
// Параметры:
// СтруктураТипа – Структура.
//
// Возвращаемое значение:
//  Строка.
//
Функция СтруктураТипаВСтрокуВнутр(СтруктураТипа) Экспорт

	ОписательТипа = Новый Структура("ИмяОбщегоТипа, Метаданные");
	ЗаполнитьЗначенияСвойств(ОписательТипа, СтруктураТипа, "ИмяОбщегоТипа");
	ТипМетаданных = ТипЗнч(СтруктураТипа.Метаданные);
	Если ТипМетаданных = Тип("ОбъектМетаданныхКонфигурация") Тогда
		//ОписательТипа.Метаданные = СтруктураТипа.Метаданные.ПолноеИмя();
	ИначеЕсли ТипМетаданных = Тип("ОбъектМетаданных") Тогда
		ОписательТипа.Метаданные = СтруктураТипа.Метаданные.ПолноеИмя();
	ИначеЕсли Ложь
		Или ТипМетаданных = Тип("КвалификаторыДаты")
		Или ТипМетаданных = Тип("КвалификаторыСтроки")
		Или ТипМетаданных = Тип("КвалификаторыЧисла")
	Тогда
		Поток = Новый ЗаписьXML;
		Поток.УстановитьСтроку();
		СериализаторXDTO.ЗаписатьXML(Поток, СтруктураТипа.Метаданные);
		ОписательТипа.Метаданные = Новый ХранилищеЗначения(Поток.Закрыть());
	Иначе
		//ОписательТипа.Метаданные = СтруктураТипа.Метаданные;
	КонецЕсли;
	Результат = ЗначениеВСтрокуВнутр(ОписательТипа);
	Возврат Результат;

КонецФункции // СтруктураТипаВСтрокуВнутр()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными(Знач КонкрентыйТип, МетаданныеТипа, ЛиНеУчитыватьПодтип)

	КонкрентыйТип = НРег(КонкрентыйТип);
	Если Ложь
		Или Найти(КонкрентыйТип, "(точка маршрута)") > 0
		Или Найти(КонкрентыйТип, "(route point)") > 0
	Тогда
		ИмяОбщегоТипа = "ТочкаМаршрутаБизнесПроцессаСсылка";
		Возврат ИмяОбщегоТипа;
	КонецЕсли;
	ИмяОбщегоТипа = ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(МетаданныеТипа);
	Подтип = "";
	ИмяЭлементаПодтипа = "";
	Если ЛиНеУчитыватьПодтип Тогда 
		Подтип = "";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "объект:") > 0 
		Или Найти(КонкрентыйТип, "object:") > 0 
	Тогда
		//Если Истина
		//	И Не ИмяОбщегоТипа = "ВнешняяОбработка"
		//	И Не ИмяОбщегоТипа = "ВнешнийОтчет"
		//Тогда
			Подтип = "Объект";
		//КонецЕсли;
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "выборка:") > 0 
		Или Найти(КонкрентыйТип, "selection:") > 0 
	Тогда
		Подтип = "Выборка";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "список:") > 0 
		Или Найти(КонкрентыйТип, "list:") > 0 
	Тогда
		Подтип = "Список";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "менеджер:") > 0 
		Или Найти(КонкрентыйТип, "manager:") > 0 
	Тогда
		Подтип = "Менеджер";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "табличная часть:") > 0 
		Или Найти(КонкрентыйТип, "tabular section:") > 0 
	Тогда
		Подтип = "ТабличнаяЧасть";
		ИмяЭлементаПодтипа = "<Имя табличной части>";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "табличная часть строка:") > 0 
		Или Найти(КонкрентыйТип, "tabular section row:") > 0 
	Тогда
		Подтип = "ТабличнаяЧастьСтрока";
		ИмяЭлементаПодтипа = "<Имя табличной части>";
	ИначеЕсли Ложь                                         // Связано со следующим условием!
		Или Найти(КонкрентыйТип, "виды субконто:") > 0 
		Или Найти(КонкрентыйТип, "ext dimension types:") > 0 
	Тогда
		Подтип = "ВидыСубконто";
	ИначеЕсли Ложь                                         // Связано со следующим условием!
		Или Найти(КонкрентыйТип, "ext dimensions:") > 0 
		Или Найти(КонкрентыйТип, "субконто:") > 0 
	Тогда
		Подтип = "Субконто";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "виды субконто строка:") > 0 
		Или Найти(КонкрентыйТип, "ext dimension types row:") > 0 
	Тогда
		Подтип = "ВидыСубконтоСтрока";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "набор записей:") > 0 
		Или Найти(КонкрентыйТип, "record set:") > 0 
	Тогда
		Подтип = "НаборЗаписей";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "ключ записи:") > 0 
		Или Найти(КонкрентыйТип, "record key:") > 0 
	Тогда
		Подтип = "КлючЗаписи";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "запись:") > 0 
		Или Найти(КонкрентыйТип, "record:") > 0 
	Тогда
		Подтип = "Запись";
	ИначеЕсли Ложь
		Или Найти(КонкрентыйТип, "менеджер записи:") > 0 
		Или Найти(КонкрентыйТип, "record manager:") > 0 
	Тогда
		Подтип = "МенеджерЗаписи";
	// Пришлось сделать так из-за изменения представления ссылочных типов в 8.2 http://partners.v8.1c.ru/forum/thread.jsp?id=830683#830683
	//ИначеЕсли Найти(КонкрентыйТип, "ссылка:") > 0 Тогда 
	Иначе//Если Найти(КонкрентыйТип, ":") = 0 Тогда 
		Подтип = "Ссылка";
	КонецЕсли;
	СтрокаКорневогоТипа = ПолучитьСтрокуТипаМетаОбъектов(ИмяОбщегоТипа);
	СтрокаВида = ТаблицаИменЭлементовКоллекций.Найти(СтрокаКорневогоТипа.Множественное, "ИмяКоллекции");
	Если СтрокаВида <> Неопределено Тогда
		ИмяОбщегоТипа = ИмяОбщегоТипа  + Подтип + "." + СтрокаВида.ИмяЭлементаКоллекции;
	КонецЕсли;
	Если ИмяЭлементаПодтипа <> "" Тогда
		ИмяОбщегоТипа = ИмяОбщегоТипа + "." + ИмяЭлементаПодтипа;
	КонецЕсли;
	
	Возврат ИмяОбщегоТипа;

КонецФункции // ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными()

// Получает структуру типа из конкретного типа.
//
// Параметры:
//  КонкрентыйТип – Тип, Строка - тип либо его представление (для неметаданных типов);
//  *ЯзыкПрограммы - Число, *0;
//  *ШаблонСтруктурыТипа - Структура, *Неопределено - содержит значения по умолчанию для новой структуры типа.
//
// Возвращаемое значение:
//  Структура – структура типа.
//
Функция ПолучитьСтруктуруТипаИзКонкретногоТипа(КонкрентыйТип, ЯзыкПрограммы = 0, ШаблонСтруктурыТипа = Неопределено) Экспорт
	
	СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
	СтруктураТипа.Метаданные = мМетаданные;
	Если ШаблонСтруктурыТипа <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(СтруктураТипа, ШаблонСтруктурыТипа);
	КонецЕсли;
	Если КонкрентыйТип = Тип("ОбъектМетаданных") Тогда
		Если Истина
			И ШаблонСтруктурыТипа <> Неопределено // было закомментировано
			И ТипЗнч(ШаблонСтруктурыТипа.Метаданные) = Тип("ОбъектМетаданных")
		Тогда
			МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ШаблонСтруктурыТипа.Метаданные.ПолноеИмя());
			СтруктураТипа.ИмяОбщегоТипа = МаркерОбъектаМетаданных + ": " + МассивФрагментов[МассивФрагментов.ВГраница() - 1];
		КонецЕсли;
	ИначеЕсли Истина
		И КонкрентыйТип = Тип("КоллекцияОбъектовМетаданных")
		И ШаблонСтруктурыТипа <> Неопределено
		И СтруктураТипа.ИмяОбщегоТипа <> "Неизвестный контекст"
	Тогда 
	Иначе
		Если Истина
			И КонкрентыйТип <> Тип("КонстантыНабор") // Антибаг платформы http://partners.v8.1c.ru/forum/thread.jsp?id=876094#876094
			И ТипЗнч(КонкрентыйТип) = Тип("Тип")
		Тогда 
			МетаданныеТипа = мМетаданные.НайтиПоТипу(КонкрентыйТип);
		КонецЕсли;
		Если МетаданныеТипа = Неопределено Тогда
			ПредставлениеТипа = Строка(КонкрентыйТип);
			Если Найти(ПредставлениеТипа, ":") = 0 Тогда
				ИдентификаторТипа = ирОбщий.ПолучитьИдентификаторТипаЛкс(КонкрентыйТип);
			Иначе
				// Внешние метаданные
				ИдентификаторТипа = "";
				ПредставлениеТипа = ирОбщий.ПолучитьПервыйФрагментЛкс(ПредставлениеТипа, ":");
				Если НРег(ПредставлениеТипа) = Нрег("External data processor") Тогда
					ПредставлениеТипа = "Внешняя обработка";
				ИначеЕсли НРег(ПредставлениеТипа) = Нрег("External data processor tabular section") Тогда
					ПредставлениеТипа = "Внешняя обработка табличная часть";
				КонецЕсли; 
			КонецЕсли; 
			Если ИдентификаторТипа <> "" Тогда
				КлючПоиска = Новый Структура("ИД, ТипТипа", ИдентификаторТипа, "Основной");
			Иначе
				КлючПоиска = Новый Структура("Представление, ТипТипа", ирОбщий.ПолучитьПервыйФрагментЛкс(ПредставлениеТипа, ":"), "Основной");
			КонецЕсли; 
		Иначе
			ЛиНеУчитыватьПодтип = (ЯзыкПрограммы <> 0) И СтруктураТипа.ТипЯзыка <> "ЗначениеВЗапросе";
			ИмяОбщегоТипа = ПолучитьИмяОбщегоТипаПоТипуЗначенияСМетаданными(КонкрентыйТип, МетаданныеТипа, ЛиНеУчитыватьПодтип);
			СтруктураТипа.Метаданные = МетаданныеТипа;
			КлючПоиска = Новый Структура("Слово, ТипТипа", ИмяОбщегоТипа, "Основной");
		КонецЕсли;
		
		НайденныеСтроки = ТаблицаОбщихТипов.НайтиСтроки(КлючПоиска);
		Если НайденныеСтроки.Количество() > 0 Тогда
			СтруктураТипа.ИмяОбщегоТипа = НайденныеСтроки[0].Слово;
			Если СтруктураТипа.СтрокаОписания = Неопределено Тогда
				СтруктураТипа.СтрокаОписания = НайденныеСтроки[0];
			КонецЕсли;
		ИначеЕсли Найти(КонкрентыйТип, " ") = 0 Тогда 
			СтруктураТипа.ИмяОбщегоТипа = Строка(КонкрентыйТип);
		Иначе
			//Сообщить("Невозможно восстановить имя типа """ + КонкрентыйТип + """", СтатусСообщения.Важное);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтруктураТипа;

КонецФункции // ПолучитьСтруктуруТипаИзКонкретногоТипа()

// Получает таблицу структур типов из описания типов.
//
// Параметры:
//  ОписаниеТипов – ОписаниеТипов;
//  *ТаблицаСтруктурТипов - ТаблицаЗначений, *Неопределено - существующая таблица.
//
// Возвращаемое значение:
//  ТаблицаЗначений - структур типов.
//
Функция ПолучитьТаблицуСтруктурТиповИзОписанияТипов(ОписаниеТипов, ТаблицаСтруктурТипов = Неопределено) Экспорт

	Если ТаблицаСтруктурТипов = Неопределено Тогда
		ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
	КонецЕсли;
	Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
		СтруктураТипа = ПолучитьСтруктуруТипаИзКонкретногоТипа(Тип, Ложь);
		ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), СтруктураТипа);
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции // ПолучитьТаблицуСтруктурТиповИзОписанияТипов()

// Получает объект по ссылке, кэшируя результат в соответствии.
//
// Параметры:
//  Ссылка       - Ссылка;
//  ПринудительноОбновить - Булево, *Ложь.
//
// Возвращаемое значение:
//  Объект.
//
Функция КэшОбъект(Ссылка, ПринудительноОбновить = Ложь) Экспорт

	ТипСсылки = ТипЗнч(Ссылка);
	Кэш = КэшОбъектов[ТипСсылки];
	Если Кэш = Неопределено Тогда
		Кэш = Новый Соответствие;
		КэшОбъектов[ТипСсылки] = Кэш;
	КонецЕсли;
	Если Не ПринудительноОбновить Тогда
		Результат = Кэш[Ссылка];
	КонецЕсли;
	Если Результат = Неопределено Тогда
		Результат = Ссылка.ПолучитьОбъект();
		Кэш[Ссылка] = Результат;
	КонецЕсли;
	Возврат Результат;

КонецФункции // КэшОбъект()

// Получает строку конкретного типа.
//
// Параметры:
//  СтруктураТипа - Структура - описание типа.
//
// Возвращаемое значение:
//  Строка - конкрентого типа.
//
Функция ПолучитьСтрокуКонкретногоТипа(СтруктураТипа) Экспорт
	
	КонкретныйТип = СтруктураТипа.ИмяОбщегоТипа;
	МаркерРасширенияФормы = "Расширение формы";
	Если Лев(КонкретныйТип, СтрДлина(МаркерРасширенияФормы)) = МаркерРасширенияФормы Тогда
		КонкретныйТип = "Форма";
	КонецЕсли;
	//Если Лев(КонкретныйТип, СтрДлина(МаркерКоллекцииМетаданных)) = МаркерКоллекцииМетаданных Тогда
	//	КонкретныйТип = МаркерКоллекцииМетаданных;
	//КонецЕсли;
	ТипМетаданных = ТипЗнч(СтруктураТипа.Метаданные);
	Если ТипМетаданных = Тип("ОбъектМетаданных") Тогда
		ПолноеИмя = СтруктураТипа.Метаданные.ПолноеИмя();
		МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмя);
		Если МассивФрагментов[0] = "ТабличнаяЧасть" Тогда
			// Баг платформы. У внешних метаданных полное имя не включает сам внешний метаобъект
			МассивФрагментов.Вставить(0, "Имя");
			МассивФрагментов.Вставить(0, "");
		КонецЕсли;
		Для Счетчик = 0 По МассивФрагментов.Количество() / 2 - 1 Цикл
			ИмяЭлементаКоллекции = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(КонкретныйТип, "<", ">", Ложь, Истина);
			КонкретныйТип = СтрЗаменить(КонкретныйТип, ИмяЭлементаКоллекции, МассивФрагментов[Счетчик * 2 + 1]);
		КонецЦикла;
	ИначеЕсли Истина
		И Это2iS
		И (Ложь
			Или ТипМетаданных = Тип("СправочникСсылка.ОбъектыМетаданных2iS")
			Или ТипМетаданных = Тип("СправочникСсылка.СвойстваМетаданных2iS"))
	Тогда
		ОбъектМД = КэшОбъект(СтруктураТипа.Метаданные);
		ПолноеИмя = ОбъектМД.ПолноеИмя;
		МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПолноеИмя);
		Если МассивФрагментов[0] = "ТабличнаяЧасть" Тогда
			// Баг платформы. У внешних метаданных полное имя не включает сам внешний метаобъект
			МассивФрагментов.Вставить(0, "Имя");
			МассивФрагментов.Вставить(0, "");
		КонецЕсли;
		Для Счетчик = 0 По МассивФрагментов.Количество() / 2 - 1 Цикл
			ИмяЭлементаКоллекции = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(КонкретныйТип, "<", ">", Ложь, Истина);
			КонкретныйТип = СтрЗаменить(КонкретныйТип, ИмяЭлементаКоллекции, МассивФрагментов[Счетчик * 2 + 1]);
		КонецЦикла;
	//ИначеЕсли ТипЗнч(СтруктураТипа.Метаданные) = Тип("Соответствие") Тогда
	//	Для Каждого ЭлементВида Из СтруктураТипа.Метаданные Цикл
	//		КонкретныйТип = СтрЗаменить(КонкретныйТип, ЭлементВида.Ключ, ЭлементВида.Значение);
	//	КонецЦикла;
	КонецЕсли;
    Возврат КонкретныйТип;
	
КонецФункции // ПолучитьСтрокуКонкретногоТипа()

// Получает новую структуру типа.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Структура - "ИмяОбщегоТипа", "Метаданные", "СтрокаОписания", "ТипЯзыка", "ВиртуальнаяТаблица".
//
Функция ПолучитьНовуюСтруктуруТипа() Экспорт

	Возврат Новый Структура("ИмяОбщегоТипа, Метаданные, СтрокаОписания, ТипЯзыка, Конструктор, ВиртуальнаяТаблица, ДополнительныеТипы, ДержательМетаданных",
		"Неизвестный контекст", Неопределено, Неопределено, "", Ложь, Новый Структура("Выражение, НомерСтроки", "", 0));

КонецФункции // ПолучитьНовуюСтруктуруТипа()

// Десериализатор структуры типа из неполной сериализации.
//
// Параметры:
//  СтрокаСтруктурыТипа – Строка.
//
// Возвращаемое значение:
// СтруктураТипа – Структура.
//
Функция СтруктураТипаИзСтрокиВнутр(СтрокаСтруктурыТипа) Экспорт

	СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
	Если ПустаяСтрока(СтрокаСтруктурыТипа) Тогда
		Возврат СтруктураТипа;
	КонецЕсли;
	Успех = Ложь;
	Попытка
		ОписательТипа = ЗначениеИзСтрокиВнутр(СтрокаСтруктурыТипа);
		Успех = Истина;
	Исключение
		ОписательТипа = ПолучитьНовуюСтруктуруТипа();
		ОписательТипа.ИмяОбщегоТипа = "<Ошибка преобразования>";
	КонецПопытки;
	Если Успех Тогда
		СтруктураТипа.ИмяОбщегоТипа = ОписательТипа.ИмяОбщегоТипа;
		Если ТипЗнч(ОписательТипа.Метаданные) = Тип("Строка") Тогда
			//СтруктураТипа.Метаданные = мМетаданные.НайтиПоПолномуИмени(ОписательТипа.Метаданные);
			СтруктураТипа.Метаданные = ПолучитьОбъектМДПоПолномуИмени(ОписательТипа.Метаданные);
		ИначеЕсли ТипЗнч(ОписательТипа.Метаданные) = Тип("ХранилищеЗначения") Тогда
			Поток = Новый ЧтениеXML;
			Поток.УстановитьСтроку(ОписательТипа.Метаданные.Получить());
			// Тут тормоз
			СтруктураТипа.Метаданные = СериализаторXDTO.ПрочитатьXML(Поток);
		Иначе
			СтруктураТипа.Метаданные = ОписательТипа.Метаданные;
		КонецЕсли;
	КонецЕсли; 
	Возврат СтруктураТипа;

КонецФункции // СтруктураТипаВСтрокуВнутр()

// Получает новую структуру типа.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Структура - "ИмяОбщегоТипа", "Метаданные", "СтрокаОписания", "ТипЯзыка", "ВиртуальнаяТаблица".
//
Функция ПолучитьНовуюТаблицуСтруктурТипа() Экспорт

	Возврат мТаблицаСтруктурТипа.СкопироватьКолонки();

КонецФункции // ПолучитьНовуюСтруктуруТипа()

// Добавляет структуру типа в таблицу структур типов.
//
// Параметры:
//  ТаблицаСтруктурТипов – ТаблицаЗначений;
//  СтруктураТипа – Структура.
//
Процедура ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа, ПередаватьДополнительныеТипы = Ложь) Экспорт 

	ИсключаемыеСвойства = Неопределено;
	Если Не ПередаватьДополнительныеТипы Тогда
		ИсключаемыеСвойства = "ДополнительныеТипы";
	КонецЕсли;
	ЗаполнитьЗначенияСвойств(ТаблицаСтруктурТипов.Добавить(), СтруктураТипа, , ИсключаемыеСвойства);

КонецПроцедуры // ДобавитьВТаблицуСтруктурТипов()

// Получает массив структур типов из строки допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка;
//  *ШаблонСтруктурыТипа - Структура, *Неопределено - содержит значения по умолчанию для новой структуры типа.
//
// Возвращаемое значение:
//  Структура – структура типа.
//
Функция ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов(ДопустимыеТипы, ШаблонСтруктурыТипа = Неопределено) Экспорт 

	ТаблицаСтруктурТипов = ПолучитьНовуюТаблицуСтруктурТипа();
	Если ПустаяСтрока(ДопустимыеТипы) Тогда
		Возврат ТаблицаСтруктурТипов;
	КонецЕсли;
	МассивСериализованныхТипов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ДопустимыеТипы, ";");
	Для Каждого СериализованныйТип Из МассивСериализованныхТипов Цикл
		СтруктураТипа = СтруктураТипаИзСтрокиВнутр(СериализованныйТип);
		Если ШаблонСтруктурыТипа <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(СтруктураТипа, ШаблонСтруктурыТипа);
		КонецЕсли;
		ДобавитьВТаблицуСтруктурТипов(ТаблицаСтруктурТипов, СтруктураТипа);
	КонецЦикла;
	Возврат ТаблицаСтруктурТипов;

КонецФункции // ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов()

// Получает описание типов из допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка;
//  ТипЗначенияЭУ  - ОписаниеТипов - все возможные типы из элемента управления.
//
// Возвращаемое значение:
//  ОписаниеТипов.
//
Функция ПолучитьОписаниеТиповИзДопустимыхТипов(ДопустимыеТипы, ТипЗначенияЭУ = Неопределено) Экспорт

	ТаблицаСтруктурТипов = ПолучитьТаблицуСтруктурТиповИзДопустимыхТипов(ДопустимыеТипы);
	ОписаниеТипов = ПолучитьОписаниеТиповИзТаблицыСтруктурТипов(ТаблицаСтруктурТипов, ТипЗначенияЭУ);
	Возврат ОписаниеТипов;

КонецФункции // ПолучитьОписаниеТиповИзДопустимыхТипов()

// Получает описание типов из таблицы структур типов.
//
// Параметры:
//  ДопустимыеТипы – Строка;
//  ТипЗначенияЭУ  - ОписаниеТипов - все возможные типы из элемента управления.
//
// Возвращаемое значение:
//  ОписаниеТипов.
//
Функция ПолучитьОписаниеТиповИзТаблицыСтруктурТипов(ТаблицаСтруктурТипов, ТипЗначенияЭУ = Неопределено) Экспорт

	Если ТаблицаСтруктурТипов = Неопределено Тогда
		Возврат Новый ОписаниеТипов;
	КонецЕсли; 
	МассивТипов = Новый Массив;
	Для Каждого СтруктураТипа Из ТаблицаСтруктурТипов Цикл
		СтрокаКонкретногоТипа = ПолучитьСтрокуКонкретногоТипа(СтруктураТипа);
		Попытка
			ТекущийТип = Тип(СтрокаКонкретногоТипа);
		Исключение
			Продолжить;
		КонецПопытки;
		ТипМетаданных = ТипЗнч(СтруктураТипа.Метаданные);
		Если ТипМетаданных = Тип("КвалификаторыСтроки") Тогда
			КвалификаторыСтроки = СтруктураТипа.Метаданные;
		ИначеЕсли ТипМетаданных = Тип("КвалификаторыЧисла") Тогда
			КвалификаторыЧисла = СтруктураТипа.Метаданные;
		ИначеЕсли ТипМетаданных = Тип("КвалификаторыДаты") Тогда
			КвалификаторыДаты = СтруктураТипа.Метаданные;
		КонецЕсли; 
		Если ТипЗначенияЭУ <> Неопределено Тогда
			Если Не ТипЗначенияЭУ.СодержитТип(ТекущийТип) Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		МассивТипов.Добавить(ТекущийТип);
	КонецЦикла;
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов, КвалификаторыЧисла, КвалификаторыСтроки, КвалификаторыСтроки);
	Возврат ОписаниеТипов;

КонецФункции // ПолучитьОписаниеТиповИзДопустимыхТипов()

// Получает строку типа метаобъектов по единственному или множественному числу.
//
// Параметры:
//  *Единственное – Строка, *Неопределено - единственное число типа;
//  *Множественное – Строка, *Неопределено - множественное число типа.
//  *Категория  – Число, *Неопределено.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - найденная строка типа;
//  Неопределено – корневой тип не найден.
//
Функция ПолучитьСтрокуТипаМетаОбъектов(Единственное = Неопределено, Множественное = Неопределено, Категория = Неопределено) Экспорт
	
	СтруктураПоиска = Новый Структура;
	Если Категория <> Неопределено Тогда
		СтруктураПоиска.Вставить("Категория", Категория);
	КонецЕсли;
	Если Единственное = Неопределено Тогда
		СтруктураПоиска.Вставить("Множественное", Множественное);
	Иначе
		СтруктураПоиска.Вставить("Единственное", Единственное);
	КонецЕсли;
	НайденныеСтроки = ТаблицаТиповМетаОбъектов.НайтиСтроки(СтруктураПоиска);
	Если НайденныеСтроки.Количество() = 0 Тогда
		Результат = Неопределено;
	Иначе
		Результат = НайденныеСтроки[0];
	КонецЕсли;
	Возврат Результат;

КонецФункции // ПолучитьСтрокуТипаМетаОбъектов()

// Открывает диалог выбора ссылочного типа.
//
// Параметры:
//  *пНачальныйТип – Тип, *Неопределено;
//  *пОграничениеТипа - ОписаниеТипов, Массив, *Неопределено - ограничение типа, массив имен корневых типов во множественном числе.
//
// Возвращаемое значение:
//               – Тип – выбранный ссылочный тип;
//  Неопределено – от выбора отказались.
//
Функция мВыбратьТип(пНачальныйТип = Неопределено, пОграничениеТипа = Неопределено) Экспорт

	СписокВыбора = Новый СписокЗначений;
	Если Ложь
		Или пОграничениеТипа = Неопределено
		Или пОграничениеТипа = Новый ОписаниеТипов 
		Или ТипЗнч(пОграничениеТипа) = Тип("Массив")  
	Тогда
		Если ТипЗнч(пОграничениеТипа) = Тип("Массив") Тогда
			Для Каждого КорневойТипМножественное Из пОграничениеТипа Цикл
				ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, КорневойТипМножественное);
			КонецЦикла;
		Иначе
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Справочники");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Документы");
			//ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Перечисления");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыВидовХарактеристик");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыСчетов");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "Задачи");
			ДобавитьВСписокКоллекциюМетаданных(СписокВыбора, "ПланыОбмена");
		КонецЕсли;
	Иначе
		Для Каждого Тип Из пОграничениеТипа.Типы() Цикл
			Объект = мМетаданные.НайтиПоТипу(Тип);
			Если Объект <> Неопределено Тогда 
				#Если Клиент Тогда
					Картинка = ирОбщий.ПолучитьКартинкуКорневогоТипаЛкс(ирОбщий.ПолучитьКорневойТипКонфигурацииЛкс(Объект));
					СписокВыбора.Добавить(Объект.ПолноеИмя(), Объект.Представление(), , Картинка);
				#Иначе
					СписокВыбора.Добавить(Объект.ПолноеИмя(), Объект.Представление());
				#КонецЕсли
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	СписокВыбора.СортироватьПоЗначению();
	Результат = Неопределено;
	Если СписокВыбора.Количество() = 1 Тогда 
		Результат = СписокВыбора[0].Значение;
	Иначе
		ВыбранныйЭлемент = СписокВыбора.ВыбратьЭлемент("Выберите тип", СписокВыбора.НайтиПоЗначению(пНачальныйТип));
		Если ВыбранныйЭлемент <> Неопределено Тогда
			Результат = ВыбранныйЭлемент.Значение;
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;

КонецФункции // мВыбратьТип()

// Проверяет общий тип на агрегатность.
//
// Параметры:
//  ИмяОбщегоТипа - Строка;
//  *ЯзыкПрограммы - *Число, 0.
//
// Возвращаемое значение:
//  Булево.
//
Функция ЭтоАгрегатныйОбщийТип(ИмяОбщегоТипа, ЯзыкПрограммы = 0) Экспорт 

	Если ИмяОбщегоТипа = "" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтруктураКлюча = Новый Структура("ТипКонтекста, ЯзыкПрограммы", ИмяОбщегоТипа, ЯзыкПрограммы);
	Если Истина
		И ТаблицаКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() = 0
		И ТаблицаШаблоновКонтекстов.НайтиСтроки(СтруктураКлюча).Количество() = 0
		И Лев(ИмяОбщегоТипа, СтрДлина(МаркерCOMОбъекта)) <> МаркерCOMОбъекта
	Тогда
		Результат = Ложь;
	Иначе
		Результат = Истина;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции // ЭтоАгрегатныйОбщийТип()

#Если Клиент Тогда

// Инициализирует полное дерево типов платформы.
//
// Параметры:
//  Нет.
//
Процедура ИнициализироватьДеревоТипов() Экспорт

	ИнициализацияОписанияМетодовИСвойств();
	
	Состояние("Инициализация дерева типов...");
	
	Если ДеревоТипов <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	ДеревоТипов = Новый ДеревоЗначений;
	ДеревоТипов.Колонки.Добавить("Пометка", Новый ОписаниеТипов("Булево"));
	ДеревоТипов.Колонки.Добавить("Имя");
	ДеревоТипов.Колонки.Добавить("ИндексКартинки", Новый ОписаниеТипов("Число"));
	ДеревоТипов.Колонки.Добавить("СтруктураТипа");
	лТаблицаТипов = ТаблицаОбщихТипов.Скопировать(Новый Структура("ЯзыкПрограммы", 0), "Слово");
	лТаблицаТипов.Колонки.Слово.Имя = "Имя";
	Для Каждого СтрокаТипа Из лТаблицаТипов Цикл
		ЗаполнитьЗначенияСвойств(ДеревоТипов.Строки.Добавить(), СтрокаТипа);
	КонецЦикла;
	СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
	СтруктураТипа.Метаданные = мМетаданные;
	СтруктураТипа.ТипЯзыка = "ИмяТипа";
	СтруктураТипа.ИмяОбщегоТипа = "";
	ОбработатьСтрокиДереваТипов(ДеревоТипов.Строки, СтруктураТипа);
	ДеревоТипов.Строки.Сортировать("Имя", Истина);
	ТаблицаТипов.Сортировать("Имя");
	МассивВажныйТипов = Новый Массив;
	МассивВажныйТипов.Добавить("Булево");
	МассивВажныйТипов.Добавить("Дата");
	МассивВажныйТипов.Добавить("Строка");
	МассивВажныйТипов.Добавить("Число");
	Для Каждого ВажныйТип Из МассивВажныйТипов Цикл
		СтрокаТипа = ТаблицаТипов.Найти(ВажныйТип, "Имя");
		ТаблицаТипов.Сдвинуть(СтрокаТипа, -ТаблицаТипов.Индекс(СтрокаТипа));
		СтрокаТипа = ДеревоТипов.Строки.Найти(ВажныйТип, "Имя");
		ДеревоТипов.Строки.Сдвинуть(СтрокаТипа, -ДеревоТипов.Строки.Индекс(СтрокаТипа));
	КонецЦикла; 
	Состояние("");

КонецПроцедуры // ИнициализироватьДеревоТипов()

Процедура ОбработатьСтрокиДереваТипов(Строки, КорневаяСтруктураТипа = Неопределено, ОкончаниеСтрокиТипа = "",
	МетаданныеТипа = Неопределено) Экспорт

	МассивСтрокКУдалению = Новый Массив;
	Для Каждого СтрокаТипа Из Строки Цикл
		ТекущееИмяТипа = СтрокаТипа.Имя;
		СтрокаТипа.Имя = СтрокаТипа.Имя + ОкончаниеСтрокиТипа;
		Уровень = СтрокаТипа.Уровень();
		ФрагментыОбщегоТипа = Неопределено;
		Если Уровень = 0 Тогда
			Если Найти(ТекущееИмяТипа, ".") > 0 Тогда
				ФрагментыОбщегоТипа = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ТекущееИмяТипа);
				ТекущееИмяТипа = ФрагментыОбщегоТипа[0];
			КонецЕсли;
			СтрокаТипаМетаОбъектов = ПолучитьСтрокуТипаМетаОбъектов(ТекущееИмяТипа);
			Если СтрокаТипаМетаОбъектов <> Неопределено Тогда
				СтрокаТипа.ИндексКартинки = СтрокаТипаМетаОбъектов.ИндексКартинкиЕдинственное;
			КонецЕсли;
			Уровень = 0;
			//СтрокаТипа.ИмяОбщегоТипа = ТекущееИмяТипа;
		Иначе
			Если КорневаяСтруктураТипа <> Неопределено Тогда
				КорневаяСтруктураТипа.Свойство("ФрагментыОбщегоТипа", ФрагментыОбщегоТипа);
			КонецЕсли; 
			СтрокаТипа.ИндексКартинки = Строки.Родитель.ИндексКартинки;
		КонецЕсли; 
		Если ФрагментыОбщегоТипа <> Неопределено Тогда
			Если ФрагментыОбщегоТипа.ВГраница() > Уровень Тогда
				ТекущийФрагмент = ФрагментыОбщегоТипа[Уровень + 1];
			КонецЕсли; 
			Если Найти(ТекущийФрагмент, "<") > 0 Тогда
				Если Истина
					И КорневаяСтруктураТипа = Неопределено 
				Тогда
					КорневаяСтруктураТипа = ПолучитьНовуюСтруктуруТипа();
					КорневаяСтруктураТипа.Метаданные = мМетаданные;
					КорневаяСтруктураТипа.ТипЯзыка = "ИмяТипа";
					КорневаяСтруктураТипа.ИмяОбщегоТипа = СтрокаТипа.Имя;
				КонецЕсли; 
				Если Уровень = 0 Тогда
					КорневаяСтруктураТипа.Вставить("ФрагментыОбщегоТипа", ФрагментыОбщегоТипа);
					СтруктураТипа = ПолучитьНовуюСтруктуруТипа();
					ЗаполнитьЗначенияСвойств(СтруктураТипа, КорневаяСтруктураТипа);
					СтруктураТипа.ИмяОбщегоТипа = ТекущееИмяТипа;
				Иначе
					СтруктураТипа = СтрокаТипа.СтруктураТипа;
				КонецЕсли;
				
				Попытка
					ВнутренняяТаблицаСлов = ПолучитьВнутреннююТаблицуМетаданныхСлов(СтруктураТипа, , "Свойство");
				Исключение
					ВнутренняяТаблицаСлов = Новый ТаблицаЗначений;
				КонецПопытки;
				Если Истина
					И Уровень > 0
					И ВнутренняяТаблицаСлов.Количество() = 0
				Тогда
					МассивСтрокКУдалению.Добавить(СтрокаТипа);
					Продолжить;
				Иначе
					ОкончаниеСтрокиТипаВниз = "";
					Для Счетчик = Уровень + 2 По ФрагментыОбщегоТипа.ВГраница() Цикл 
						Фрагмент = ФрагментыОбщегоТипа[Счетчик];
						ОкончаниеСтрокиТипаВниз = ОкончаниеСтрокиТипаВниз + "." + Фрагмент;
					КонецЦикла;
					Для Каждого СтрокаСлова Из ВнутренняяТаблицаСлов Цикл
						НоваяСтрока = СтрокаТипа.Строки.Добавить();
						СтруктураТипаВниз = СтрокаСлова.ТаблицаСтруктурТипов[0];
						НоваяСтрока.СтруктураТипа = СтруктураТипаВниз;
						//НоваяСтрока.Имя = ПолучитьСтрокуКонкретногоТипа(СтруктураТипаВниз);
						НоваяСтрока.Имя = ТекущееИмяТипа + "." + СтруктураТипаВниз.Метаданные.Имя;
					КонецЦикла;
					ОбработатьСтрокиДереваТипов(СтрокаТипа.Строки, КорневаяСтруктураТипа, ОкончаниеСтрокиТипаВниз);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
		//ЗаполнитьЗначенияСвойств(СтруктураТипа, КорневаяСтруктураТипа, "ИмяОбщегоТипа");
		ЗаполнитьЗначенияСвойств(ТаблицаТипов.Добавить(), СтрокаТипа);
	КонецЦикла;
	РодительСтрок = Строки.Родитель;
	Для Каждого СтрокаКУдалению Из МассивСтрокКУдалению Цикл
		РодительСтрок.Строки.Удалить(СтрокаКУдалению);
	КонецЦикла;

КонецПроцедуры // ОбработатьСтрокиДерева()

// Открыть диалог для редактирования допустимых типов.
//
// Параметры:
//  ДопустимыеТипы – Строка – сериализованные допустимые типы;
//  *ТолькоПросмотр – Булево, *Истина – открыть только для просмотра.
//
// Возвращаемое значение:
//  Строка - сериализованных допустимых типов;
//  Неопределено - отмена.
//
Функция РедактироватьДопустимыеТипы(ДопустимыеТипы, ТолькоПросмотр = Ложь) Экспорт

	ФормаРедактора = ПолучитьФорму("РедакторДопустимыхТипов");
	ФормаРедактора.ДопустимыеТипы = ДопустимыеТипы;
	ФормаРедактора.ТолькоПросмотр = ТолькоПросмотр;
	Если ФормаРедактора.ОткрытьМодально() = Истина Тогда 
		Возврат ФормаРедактора.ДопустимыеТипы;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // РедактироватьДопустимыеТипы()

// Убирает из строки лишние кавычки.
//
// Параметры:
//  ПервичнаяСтрока – Строка.
//
// Возвращаемое значение:
//  Строка.
//
Функция ИзвлечьСтрокуШаблонаТекста(ПервичнаяСтрока)

	RegExp.Global = Истина;
	СтрокаБезГраниц = Сред(ПервичнаяСтрока, 2, СтрДлина(ПервичнаяСтрока) - 2);
	RegExp.Pattern = "([^""]*"")""";
	Результат = RegExp.Replace(СтрокаБезГраниц, "$1"); 
	Возврат Результат;

КонецФункции // ИзвлечьСтрокуШаблонаТекста ()

// Загружает шаблоны текста из файла.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//   Булево - успешность операции.
//
Функция ПолучитьТаблицуШаблоновТекста(ИмяКласса, мСообщенияЧерезПредупреждения, ПринудительноОбновить = Ложь) Экспорт 

	Если Истина
		И Не ПринудительноОбновить
		И ТаблицаШаблоновТекста <> Неопределено 
	Тогда
		Возврат ТаблицаШаблоновТекста;
	КонецЕсли; 
	ТаблицаШаблоновТекста = Новый ТаблицаЗначений;
	ТаблицаШаблоновТекста.Колонки.Добавить("Шаблон");
	ТаблицаШаблоновТекста.Колонки.Добавить("Замена");
	ТаблицаШаблоновТекста.Индексы.Добавить("Шаблон");
	
	ФайлШаблонов = ВосстановитьЗначение(ИмяКласса + ".ФайлШаблоновТекста");
	Файл = Новый Файл(ФайлШаблонов);
	Если Не Файл.Существует() Тогда
		Если ЗначениеЗаполнено(ФайлШаблонов) Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Не обнаружен файл шаблонов текста """ + ФайлШаблонов + """, указанный в настройках компоненты ""Контекстная подсказка""",
				мСообщенияЧерезПредупреждения);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли;
	Парсер = мПолучитьПарсер("ГрамматикаФайлаШаблоновТекста");
	Если Парсер = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	ТекстовыйДокументФайла = Новый ТекстовыйДокумент;
	ТекстовыйДокументФайла.Прочитать(ФайлШаблонов);
	
	Состояние("Идет загрузка файла шаблонов текста...");
		
	gpMsgReduction			= 2;
	gpMsgAccept				= 3;
	gpMsgNotLoadedError		= 4;
	gpMsgLexicalError		= 5;
	gpMsgSyntaxError 		= 6;
	gpMsgInternalError		= 8;
	
	Парсер.OpenTextString(ТекстовыйДокументФайла.ПолучитьТекст());

	Закончили = Ложь;
    ТекущаяСтрокаТаблицыШаблоновТекста = Неопределено;
	
	Пока Не Закончили Цикл 
		Ответ = Парсер.Parse();
		Если Ложь
			Или Ответ = gpMsgLexicalError
			Или Ответ = gpMsgSyntaxError
			Или Ответ = gpMsgInternalError
			Или Ответ = gpMsgNotLoadedError
			Или Ответ = gpMsgAccept
		Тогда
		    Закончили = Истина;
		ИначеЕсли Ответ = gpMsgReduction Тогда
			ИмяПравила = Парсер.CurrentReduction.ParentRule.RuleNonterminal.Text;
			Если ИмяПравила = "<Match>" Тогда 
				СтартовыйТокен = Парсер.CurrentReduction.Tokens(0);
				ТекущаяСтрокаТаблицыШаблоновТекста = ТаблицаШаблоновТекста.Добавить();
				ТекущаяСтрокаТаблицыШаблоновТекста.Шаблон = Нрег(ИзвлечьСтрокуШаблонаТекста(СтартовыйТокен.Data));
			ИначеЕсли ИмяПравила = "<Replacement>" Тогда 
				СтартовыйТокен = Парсер.CurrentReduction.Tokens(0);
				ТекущаяСтрокаТаблицыШаблоновТекста.Замена = ИзвлечьСтрокуШаблонаТекста(СтартовыйТокен.Data);
			КонецЕсли;  
		КонецЕсли;
	КонецЦикла;
	
	Состояние();
	Если Ответ <> gpMsgAccept Тогда
		ирОбщий.СообщитьСУчетомМодальностиЛкс("Указан неправильный файл шаблонов """ + ФайлШаблонов + """", мСообщенияЧерезПредупреждения);
		ТаблицаШаблоновТекста = Неопределено;
	КонецЕсли;
	Возврат ТаблицаШаблоновТекста;
	
КонецФункции // ЗагрузитьШаблоныТекста()

// Параметры:
//   Параметры - ТаблицаЗначений - колонки "ИмяПараметра, ЗначениеПараметра"
//   ТипЗапроса - Строка, *"Построитель" - "Обычный", "Компоновка", "Построитель"
Функция РедактироватьЗапрос(Текст, Параметры, ТипЗапроса = "Построитель") Экспорт
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("ТекстЗапроса", Текст);
	СтруктураЗапроса.Вставить("Параметры", Параметры);
	СтруктураЗапроса.Вставить("ТипЗапроса", ТипЗапроса);
	СтруктураЗапроса.Вставить("Имя", "Запрос");
	ОбработкаКонсольЗапросов = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКонсольЗапросов");
	РезультатФормы = ОбработкаКонсольЗапросов.РедактироватьСтруктуруЗапроса(, СтруктураЗапроса);
	Результат = РезультатФормы <> Неопределено;
	Если Результат Тогда
		Текст = РезультатФормы.ТекстЗапроса;
		Параметры = РезультатФормы.Параметры;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Параметры:
//   Параметры - ТаблицаЗначений - колонки "ИмяПараметра, ЗначениеПараметра"
//   ТипЗапроса - Строка, *"Построитель" - "Обычный", "Компоновка", "Построитель"
Функция РедактироватьАлгоритм(Текст, Параметры) Экспорт
	
	ОбработкаКонсольКода = ирОбщий.ПолучитьОбъектПоПолномуИмениМетаданныхЛкс("Обработка.ирКонсольКода");
	ФормаКонсоли = ОбработкаКонсольКода.ПолучитьФорму();
	ФормаКонсоли.мСписокВнешнихПараметров = Параметры;
	ФормаКонсоли.Текст = Текст;
	ФормаКонсоли.ОткрытьМодально();
	РезультатФормы = ФормаКонсоли.РезультатФормы;
	Результат = РезультатФормы <> Неопределено;
	Если Результат Тогда
		Текст = РезультатФормы.Текст;
		Параметры = РезультатФормы.Параметры;
	КонецЕсли;
	Возврат Результат;

КонецФункции

#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С АЛГОРИТМАМИ

// Выполняет текст программы.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Функция ВыполнитьЛокально(ТекстДляВыполнения, ЛиСинтаксическийКонтроль = Ложь) Экспорт 
	
	Если ЛиСинтаксическийКонтроль Тогда
		ирОбщий.ВыполнитьАлгоритмБезРезультата(ТекстДляВыполнения);
	Иначе
		ирОбщий.ВыполнитьАлгоритм(ТекстДляВыполнения);
	КонецЕсли; 

КонецФункции // ВыполнитьЛокально()

// Выполняет программный код в контексте.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Функция ВыполнитьПрограммныйКодВКонтексте(КонтекстВыполнения, МетодВыполнения = "ВыполнитьЛокально", ТекстДляВыполнения, ЛиСинтаксическийКонтроль = Ложь) Экспорт 

	Если ПустаяСтрока(МетодВыполнения) Тогда
		ВызватьИсключение "Не указан метод выполнения";
	КонецЕсли; 
	Если КонтекстВыполнения = Неопределено Тогда
		ИнформацияОбОшибке = Вычислить(МетодВыполнения + "(ТекстДляВыполнения, ЛиСинтаксическийКонтроль)");
	Иначе
		ИнформацияОбОшибке = Вычислить("КонтекстВыполнения." + МетодВыполнения + "(ТекстДляВыполнения, ЛиСинтаксическийКонтроль)");
	КонецЕсли;
	Возврат ИнформацияОбОшибке;

КонецФункции // ВыполнитьПрограммныйКодВКонтексте()

//#КонецЕсли

#Если Клиент Тогда

Функция ПолучитьИдентификаторПроцессаОтладчика() Экспорт
	
	Перем Результат;
	ПолучитьПортДляПодключенияОтладчика(Результат);
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПортДляПодключенияОтладчика(ИдентификаторПроцессаОтладчика) Экспорт
		
	ИдентификаторПроцесса = ПолучитьИдентификаторПроцессаОС();
	Команда = "netstat -n -a -o";
	ТекстРезультата = ПолучитьТекстРезультатаКомандыСистемы(Команда);
	RegExp.Global = Истина;
	RegExp.Pattern = "TCP(?:\s+)0\.0\.0\.0:(\d+)(?:\s+)(?:[0-9]{1,3}\.){3}[0-9]{1,3}:(\d+)(?:\s+)LISTENING(?:\s+)"
		+ Формат(ИдентификаторПроцесса, "ЧГ=");
	Вхождения = RegExp.Execute(ТекстРезультата);
	//Сообщить(ТекстРезультата);
	МассивСлушающихПортов = Новый Массив;
	СтрокаПоиска = "";
	// Т.к. неясно какой из портов для отладки, используем все
	Для Каждого Вхождение Из Вхождения Цикл
		МассивСлушающихПортов.Добавить(Вхождение.SubMatches(0));
		СтрокаПоиска = СтрокаПоиска + "|" + Вхождение.SubMatches(0);
	КонецЦикла;
	Если МассивСлушающихПортов.Количество() = 0 Тогда
		Результат = Неопределено;
		Возврат Результат;
	КонецЕсли;
	СтрокаПоиска = Сред(СтрокаПоиска, 2);
	ИдентификаторПроцессаОтладчика = Неопределено;
	RegExp.Pattern = "TCP(?:\s+)127\.0\.0\.1:(?:\d+)(?:\s+)127\.0\.0\.1:(" + СтрокаПоиска + ")(?:\s+)ESTABLISHED(?:\s+)(\d+)";
	Вхождения = RegExp.Execute(ТекстРезультата);
	Для Каждого Вхождение Из Вхождения Цикл
		ИдентификаторПроцессаКорреспондента = Вхождение.SubMatches(1);
		Если ИдентификаторПроцессаКорреспондента <> Формат(ИдентификаторПроцесса, "ЧГ=") Тогда
			ИдентификаторПроцессаОтладчика = ИдентификаторПроцессаКорреспондента;
		Иначе
			МассивСлушающихПортов.Удалить(МассивСлушающихПортов.Найти(Вхождение.SubMatches(0)));
		КонецЕсли;
	КонецЦикла;
	Если МассивСлушающихПортов.Количество() > 0 Тогда
		Результат = МассивСлушающихПортов[0];
	КонецЕсли;
	Возврат Результат;
	
КонецФункции
	
// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьФайлСтилейСинтаксПомощника() Экспорт 

	Если ФайлСтилейСинтаксПомощника = Неопределено Тогда 
		ФайлСтилейСинтаксПомощника = Новый Файл(ПолучитьИмяВременногоФайла("css"));
		ТекстовыйДокумент = ПолучитьМакет("СтилиСинтаксПомощника");
		ТекстовыйДокумент.Вывод = ИспользованиеВывода.Разрешить;
		ТекстовыйДокумент.Записать(ФайлСтилейСинтаксПомощника.ПолноеИмя);
	КонецЕсли;
	Возврат ФайлСтилейСинтаксПомощника;

КонецФункции // ПолучитьФайлСтилейСинтаксПомощника()

// Получает zip-архив синтакс-помощника из файла "shcntx_ru.hbk" в каталоге установки платформы.
//
// Параметры:
//  ЭлементСтруктуры - Число, *0 - 0 - архив страниц, 1 - содержание книги, 2 - индекс книги
//
Функция ПолучитьАрхивСинтаксПомощникаПоИмени(ЭлементСтруктуры = 0, ИмяАрхива = "shcntx_ru") Экспорт

	Если АрхивСинтаксПомощника = Неопределено Тогда
		АрхивСинтаксПомощника = Новый Структура;
	КонецЕсли; 
	ФайлАрхива = Неопределено;
	КлючСтруктуры = "_" + ИмяАрхива + ЭлементСтруктуры;
	Если Не АрхивСинтаксПомощника.Свойство(КлючСтруктуры, ФайлАрхива) Тогда
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("zip");
		Если ЭлементСтруктуры = 0 Тогда
			ИмяБлока = "FileStorage.data";
		ИначеЕсли ЭлементСтруктуры = 1 Тогда
			ИмяБлока = "PackBlock.data";
		ИначеЕсли ЭлементСтруктуры = 2 Тогда
			ИмяБлока = "IndexPackBlock.data";
		КонецЕсли; 
		ИмяФайлаПлатформы = ИмяАрхива + ".hbk";
		ТекущийКаталог = КаталогВременныхФайлов();
		ФайлПлатформы = Новый Файл(КаталогПрограммы() + ИмяФайлаПлатформы);
		//ФайлПлатформы = Новый Файл(ПолучитьИмяФайлаВФорматеDOS(ФайлПлатформы.ПолноеИмя));
		ФайлБлока = Новый Файл(ТекущийКаталог + ИмяБлока);
		#Если Клиент Тогда
		Состояние("Распаковка синтакс-помощника");
		#КонецЕсли 
		РаспаковатьФайлВнешнейОбработки(ФайлПлатформы.ПолноеИмя, ТекущийКаталог);
		Попытка
			ПереместитьФайл(ФайлБлока.ПолноеИмя, ИмяВременногоФайла);
		Исключение
			// Если файл залочен на чтение (открыт синтакс-помощник в конфигураторе)
			КопияФайлаПлатформы = Новый Файл(ПолучитьИмяВременногоФайла());
			КопироватьФайл(ФайлПлатформы.ПолноеИмя, КопияФайлаПлатформы.ПолноеИмя);
			ФайлПлатформы = Новый Файл(ПолучитьИмяФайлаВФорматеDOS(КопияФайлаПлатформы.ПолноеИмя));
			ФайлБлока = Новый Файл(ТекущийКаталог + ИмяБлока);
			РаспаковатьФайлВнешнейОбработки(ФайлПлатформы.ПолноеИмя, ТекущийКаталог);
			ПереместитьФайл(ФайлБлока.ПолноеИмя, ИмяВременногоФайла);
		КонецПопытки;
		УдалитьФайлы(ТекущийКаталог + Лев(ФайлПлатформы.ИмяБезРасширения, 8));
		#Если Клиент Тогда
		Состояние("");
		#КонецЕсли 
		ФайлАрхива = Новый Файл(ИмяВременногоФайла);
		АрхивСинтаксПомощника.Вставить(КлючСтруктуры, ФайлАрхива);
	КонецЕсли;
	Возврат ФайлАрхива;

КонецФункции // ПолучитьАрхивСинтаксПомощника()

// 
//
// Параметры:
//  ПутьКЭлементу  - Строка - модифицируется
//  ИмяАрхива    – Строка – входное значение игнорируется, на выход подается вычисленное имя файла архива;
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьАрхивСинтаксПомощникаПоПутиКЭлементу(ПутьКЭлементу, ЭлементСтруктуры = 0, ЛиОбрезатьПутьДоОтносительного = Ложь, ИмяАрхива = "") Экспорт

	МаркерДопАрхива = "//";
	Если Найти(ПутьКЭлементу, МаркерДопАрхива) = 1 Тогда
		ИмяАрхива = ирОбщий.ПолучитьПервыйФрагментЛкс(Сред(ПутьКЭлементу, СтрДлина(МаркерДопАрхива) + 1), "/");
		Если ЛиОбрезатьПутьДоОтносительного Тогда
			ПутьКЭлементу = Сред(ПутьКЭлементу, СтрДлина(МаркерДопАрхива) + 1 + СтрДлина(ИмяАрхива) + 1);
		КонецЕсли;
		ФайлАрхива = ПолучитьАрхивСинтаксПомощникаПоИмени(ЭлементСтруктуры, ИмяАрхива);
	Иначе
		ФайлАрхива = ПолучитьАрхивСинтаксПомощникаПоИмени(ЭлементСтруктуры);
	КонецЕсли;
	Возврат ФайлАрхива;

КонецФункции // ПолучитьИмяАрхиваСинтаксПомощника()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция РаспаковатьФайлАрхиваСинтаксПомощника(Знач ПутьКЭлементу, ПрефиксСсылки = "") Экспорт

	ФайлАрхива = ПолучитьАрхивСинтаксПомощникаПоПутиКЭлементу(ПутьКЭлементу,, Истина);
	Если ФайлАрхива = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Лев(ПутьКЭлементу, 1) = "/" Тогда
		ПутьКЭлементу = Сред(ПутьКЭлементу, 2);
	КонецЕсли;
	МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(ПутьКЭлементу, "#");
	ПутьКЭлементу = МассивФрагментов[0];
	ФайлРаспаковщикаZIP = ПолучитьФайлРаспаковщикаZIP(Истина);
	ВременныйФайл = Новый Файл(ПолучитьИмяВременногоФайла("html"));
	
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(ФайлРаспаковщикаZIP.Имя + " -j " + ФайлАрхива.Имя 
		+ " """ + ПутьКЭлементу + """", КаталогВременныхФайлов(), Истина);
	ПолноеИмяРаспакованногоФайла = КаталогВременныхФайлов() + ирОбщий.ПолучитьПоследнийФрагментЛкс(ПутьКЭлементу, "/");
	Попытка
		ПереместитьФайл(ПолноеИмяРаспакованногоФайла, ВременныйФайл.ПолноеИмя);
	Исключение
		// для примитивных типов видимо лежат файлы в другом архиве
		Возврат Неопределено;
	КонецПопытки;
	УдалитьФайлы(ПолноеИмяРаспакованногоФайла);
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ВременныйФайл.ПолноеИмя);
	СодержаниеСтраницы = ТекстовыйДокумент.ПолучитьТекст();
	Если Найти(СодержаниеСтраницы, "<head>") > 0 Тогда
		Маркер = "<head>";
	ИначеЕсли Найти(СодержаниеСтраницы, "<HEAD>") > 0 Тогда
		Маркер = "<HEAD>";
	ИначеЕсли Найти(СодержаниеСтраницы, "<Head>") > 0 Тогда
		Маркер = "<Head>";
	КонецЕсли;
	Если Маркер <> Неопределено Тогда
		ТегБазы = "<base href=""" + ПрефиксСсылки + "/" + ПутьКЭлементу + """>";
		СодержаниеСтраницы = СтрЗаменить(СодержаниеСтраницы, Маркер, Маркер + ТегБазы);
		ТекстовыйДокумент.УстановитьТекст(СодержаниеСтраницы);
		ТекстовыйДокумент.Вывод = ИспользованиеВывода.Разрешить;
		ТекстовыйДокумент.Записать(ВременныйФайл.ПолноеИмя);
	КонецЕсли;
	ВременныйАдрес = ВременныйФайл.ПолноеИмя;
	Если МассивФрагментов.Количество() > 1 Тогда
		ВременныйАдрес = ВременныйАдрес + "#" + МассивФрагментов[1];
	КонецЕсли; 
	Возврат ВременныйАдрес;

КонецФункции // РаспаковатьФайлАрхиваСинтаксПомощника()

Процедура НастроитьАвтоТабличноеПолеДинамическогоСписка(ОсновнойЭУ) Экспорт

	ОсновнойЭУ.СоздатьКолонки();
	
	Попытка
		КолонкиСписка = ОсновнойЭУ.Значение.Колонки;
	Исключение
	КонецПопытки; 
	
	КолонкиТП = ОсновнойЭУ.Колонки;
	Колонка = КолонкиТП.Найти("Картинка");
	Если Колонка = Неопределено Тогда
		КолонкаКартинки = КолонкиТП.Добавить("Картинка");
		КолонкаКартинки.ОтображатьСтандартнуюКартинку = Истина;
		КолонкаКартинки.Ширина = 3;
		КолонкаКартинки.ИзменениеРазмера = ИзменениеРазмераКолонки.НеИзменять;
		КолонкаКартинки.ТекстШапки = "";
	КонецЕсли;
	
	Для Каждого ЭлементОтбора Из ОсновнойЭУ.Значение.Отбор Цикл
		Колонка = ОсновнойЭУ.Колонки.Найти(ЭлементОтбора.Имя);
		Если Колонка = Неопределено Тогда
			// Антибаг 8.2.15 http://partners.v8.1c.ru/forum/thread.jsp?id=1002521#1002521
			Если Ложь
				Или Найти(ЭлементОтбора.Имя, "ВидСубконтоДт") = 1
				Или Найти(ЭлементОтбора.Имя, "ВидСубконтоКт") = 1
			Тогда
				Продолжить;
			КонецЕсли; 
			Попытка
				КолонкиСписка.Добавить(ЭлементОтбора.Имя, Ложь);
			Исключение
				// Сюда попадает например элемент отбора от критерия отбора
				Продолжить;
			КонецПопытки; 
			Колонка = ОсновнойЭУ.Колонки.Добавить();
			Колонка.ТекстШапки = ЭлементОтбора.Представление;
			Колонка.УстановитьЭлементУправления(Тип("ПолеВвода"));
			Попытка
				Колонка.Данные = ЭлементОтбора.Имя;
			Исключение
				Колонка.Видимость = Ложь;
			КонецПопытки;
			
			// Закомментировал 13.02.2011
			//Если ЗначениеЗаполнено(Колонка.Данные) Тогда
			//	Колонка.Имя = Колонка.Данные;
			//КонецЕсли; 
			Колонка.Имя = ЭлементОтбора.Имя;
			
		КонецЕсли;
	КонецЦикла;
	Если КолонкиСписка <> Неопределено Тогда
		Для Каждого ЭлементНастройкиОтбора Из ОсновнойЭУ.НастройкаОтбора Цикл
			ЭлементНастройкиОтбора.Доступность = Истина;
		КонецЦикла;
		ОбъектМД = Метаданные.НайтиПоТипу(ОсновнойЭУ.ТипЗначения.Типы()[0]);
		НастройкаПорядка = ОсновнойЭУ.НастройкаПорядка;
		ПредопределенныеПоля = Новый Массив();
		ПредопределенныеПоля.Добавить("Код");
		ПредопределенныеПоля.Добавить("Наименование");
		ПредопределенныеПоля.Добавить("Дата");
		ПредопределенныеПоля.Добавить("Период");
		ПредопределенныеПоля.Добавить("ДатаИзменения");
		ПредопределенныеПоля.Добавить("ДатаСоздания");
		Для Каждого ПредопределенноеПоле Из ПредопределенныеПоля Цикл
			ЭлементПорядка = НастройкаПорядка.Найти(ПредопределенноеПоле);
			Если ЭлементПорядка <> Неопределено Тогда
				ЭлементПорядка.Доступность = Истина;
			КонецЕсли; 
		КонецЦикла;
		//Компоновщик = ирКэш.ПолучитьКомпоновщикТаблицыМетаданныхЛкс(ОбъектМД.ПолноеИмя()); 
		//#Если _ Тогда
		//	Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
		//#КонецЕсли
		//Для Каждого ПолеВыбора Из Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы Цикл
		//	Если ПолеВыбора.Папка Тогда
		//		Продолжить;
		//	КонецЕсли; 
		//КонецЦикла;
	КонецЕсли; 
	Если ОсновнойЭУ.Колонки.Найти("Ссылка") <> Неопределено Тогда
		КолонкаИдентификатора = ОсновнойЭУ.Колонки.Добавить("ИдентификаторЛкс");
		КолонкаИдентификатора.ТекстШапки = "Идентификатор ссылки";
	КонецЕсли; 

КонецПроцедуры // НастроитьАвтоТабличноеПолеДинамическогоСписка()

Функция ПолучитьДокументDOMФормы(Форма) Экспорт 

	Перем ДокументDOM;
	
	Попытка
		Форма.мСвойстваФормы.Свойство("ДокументDOM", ДокументDOM);
		ЕстьХранилище = Истина;
	Исключение
		ЕстьХранилище = Ложь;
	КонецПопытки;
	Если ДокументDOM = Неопределено Тогда
		СтрокаФормы = ЗначениеВСтрокуВнутр(Форма);
		XMLСтрокаФормы = ирОбщий.СтрокаВнутрВХМЛТелоЛкс(СтрокаФормы);
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XMLСтрокаФормы);
		ПостроительDOM = Новый ПостроительDOM;
		ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
		Если ЕстьХранилище Тогда
			Форма.мСвойстваФормы.Вставить("ДокументDOM", ДокументDOM);
		КонецЕсли; 
	КонецЕсли;
	Возврат ДокументDOM;

КонецФункции // ЛксПолучитьДокументDOMФормы()

Функция ПолучитьXPathИмениРеквизитаВОписанииРеквизита()

	Если ИДВерсииПлатформы = "81" Тогда
		Результат = "/data[3]";
	ИначеЕсли Ложь
		Или ИДВерсииПлатформы = "82"
		Или ИДВерсииПлатформы = "83"
	Тогда
		Результат = "/data[4]";
	КонецЕсли; 
	Возврат Результат;

КонецФункции // ПолучитьXPathИмениРеквизитаВОписанииРеквизита()

Функция ПолучитьИмяОсновногоРеквизитаФормы(Форма) Экспорт
	
	ДокументDOM = ПолучитьДокументDOMФормы(Форма);
	РазыменовательПИ = Новый РазыменовательПространствИменDOM(ДокументDOM);
	ИмяЭлемента = "/elem[1]/elem[1]/elem[2]/elem[1]/data[1]/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ, ТипРезультатаDOMXPath.Строка);
	КлючОсновногоРеквизита = РезультатXPath.СтроковоеЗначение;

	ИмяЭлемента = "/elem[1]/elem[1]/elem[2]/elem[2]/elem/elem[1]/data[1]/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(ИмяЭлемента, ДокументDOM, РазыменовательПИ,
		ТипРезультатаDOMXPath.УпорядоченныйИтераторУзлов);
	Счетчик = 1;
	Пока 1 = 1 Цикл
		Узел = РезультатXPath.ПолучитьСледующий();
		Если Узел = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Если Узел.ТекстовоеСодержимое = КлючОсновногоРеквизита Тогда
			Прервать;
		КонецЕсли;
		Счетчик = Счетчик + 1;
	КонецЦикла;

	Если Узел = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	СтрокаXPath = "/elem[1]/elem[1]/elem[2]/elem[2]/elem[" + Счетчик + "]" + ПолучитьXPathИмениРеквизитаВОписанииРеквизита() + "/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(СтрокаXPath, ДокументDOM, РазыменовательПИ, ТипРезультатаDOMXPath.Строка);
	Длина = СтрДлина(РезультатXPath.СтроковоеЗначение);
	Возврат Сред(РезультатXPath.СтроковоеЗначение, 2, Длина - 2);
	
КонецФункции // ЛксПолучитьИмяОсновногоРеквизитаФормы()

Функция ПолучитьМассивИменРеквизитовФормы(Форма) Экспорт
	
	Массив = Новый Массив;
	ДокументDOM = ПолучитьДокументDOMФормы(Форма);
	РазыменовательПИ = Новый РазыменовательПространствИменDOM(ДокументDOM);
	СтрокаXPath = "/elem[1]/elem[1]/elem[2]/elem[2]/elem" + ПолучитьXPathИмениРеквизитаВОписанииРеквизита() + "/text()";
	РезультатXPath = ДокументDOM.ВычислитьВыражениеXPath(СтрокаXPath, ДокументDOM,
		РазыменовательПИ, ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов);
	Пока 1 = 1 Цикл
		Узел = РезультатXPath.ПолучитьСледующий();
		Если Узел = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Текст = Узел.ТекстовоеСодержимое;
		Длина = СтрДлина(Текст);
		Текст = Сред(Текст, 2, Длина - 2);
		Массив.Добавить(Текст);
	КонецЦикла;
	Возврат Массив;

КонецФункции // ЛксПолучитьМассивИменРеквизитовФормы()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьМакетКомпоненты(Компонента) Экспорт

	Макет = 0;
	Если Не МакетыКомпонент.Свойство(Компонента.ИмяКласса, Макет) Тогда
		Макет = Компонента.ПолучитьФорму("ФормаМакет");
		МакетыКомпонент.Вставить(Компонента.ИмяКласса, Макет);
	КонецЕсли;
	Возврат Макет;

КонецФункции // ПолучитьМакетКомпоненты()

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция ПолучитьADOUtils(ПытатьсяУстанавливать =  Истина, Знач СмещениеГодаADO = Неопределено, Знач Типизировать1С = Ложь,
	Знач ПреобразовыватьБинарныеВСтроки = Ложь) Экспорт

	Если мADOUtils = Неопределено Тогда
		ИдентификаторКласса = "GameWithFire.ADOUtils";
		ИмяОбъекта = "ADOUtils";
		ПодключитьВнешнююКомпоненту(ИдентификаторКласса);
		Попытка
			мADOUtils = Новый ("AddIn." + ИмяОбъекта);
		Исключение
		КонецПопытки;
		Если Истина
			И мADOUtils = Неопределено 
			И ПытатьсяУстанавливать
		Тогда
			ИмяМакетаДополнительнойБиблиотеки = "Zlib1";
			ИмяМакетаКомпоненты = "GameWithFire";
			ПолучитьCOMОбъектИзМакета(ИмяМакетаКомпоненты, ИдентификаторКласса,, ИмяМакетаДополнительнойБиблиотеки, ИмяОбъекта);
			ПодключитьВнешнююКомпоненту(ИдентификаторКласса);
			Попытка
				мADOUtils = Новый ("AddIn." + ИмяОбъекта);
			Исключение
			КонецПопытки;
		КонецЕсли; 
		// такой способ почему то не работает
		//мADOUtils = ПолучитьОбъектВнешнейКомпонентыИзМакета(ИмяМакетаКомпоненты, , ИдентификаторКласса, ТипВнешнейКомпоненты.COM, ИмяМакетаДополнительнойБиблиотеки);
	КонецЕсли; 
	Если мADOUtils <> Неопределено Тогда
		мADOUtils.BinaryDataAsStrings = ПреобразовыватьБинарныеВСтроки;
		мADOUtils.BinaryDataAs1C = Типизировать1С;
		мADOUtils.YearOffset = СмещениеГодаADO;
	КонецЕсли; 
	Возврат мADOUtils;

КонецФункции // мПолучитьADOUtils()

// Пауза.
//
// Параметры:
//  Длительность – Число – милисекунд.
//
Процедура Sleep(Длительность) Экспорт

	Если ПолучитьWinAPI() <> Неопределено Тогда 
		WinAPI.Sleep(Длительность);
	Иначе
		Для Счетчик = 1 По Длительность / 1000 Цикл
			ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("ping -n 2 127.0.0.1");
		КонецЦикла; 
	КонецЕсли;

КонецПроцедуры // Sleep()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьТекстМодуляВнешнейОбработкиАлгоритма(ФайлВнешнейОбработки) Экспорт

	Если Не ФайлВнешнейОбработки.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ТекстМодуля = ПолучитьТекстМодуляВнешнейОбработки(ФайлВнешнейОбработки);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	ТекстАлгоритма = ирОбщий.ПолучитьСтрокуМеждуМаркерамиЛкс(ТекстМодуля, МаркерНачалаАлгоритма, МаркерКонцаАлгоритма);
	Результат = "";
	Для Счетчик = 1 По СтрЧислоСтрок(ТекстАлгоритма) Цикл
		СтрокаАлгоритма = СтрПолучитьСтроку(ТекстАлгоритма, Счетчик);
		Если Лев(СтрокаАлгоритма, 1) = Символы.Таб Тогда
			СтрокаАлгоритма = Сред(СтрокаАлгоритма, 2);
		КонецЕсли;
		Результат = Результат + СтрокаАлгоритма + Символы.ПС;
	КонецЦикла;
		
	Возврат Результат;

КонецФункции // ПолучитьТекстМодуляВнешнейОбработкиАлгоритма()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьТекстМодуляВнешнейОбработки(ФайлВнешнейОбработки) Экспорт 

	КаталогРаспаковки = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(КаталогРаспаковки);
	РаспаковатьФайлВнешнейОбработки(ФайлВнешнейОбработки.ПолноеИмя, КаталогРаспаковки);
	ФайлТекстаМодуляОбработки = Новый Файл(КаталогРаспаковки + "\" + СубПутьКФайлуПотокаМодуляВнешнейОбработки);
	ТекстовыйДокументМодуля = Новый ТекстовыйДокумент();
	ТекстовыйДокументМодуля.Прочитать(ФайлТекстаМодуляОбработки.ПолноеИмя);
	ТекстМодуля = ТекстовыйДокументМодуля.ПолучитьТекст();
	УдалитьФайлы(КаталогРаспаковки);
	Возврат ТекстМодуля;

КонецФункции // ПолучитьТекстМодуляВнешнейОбработки()

// Открывает модуль внешней обработки алгоритма в конфигураторе.
//
// Параметры:
//  АлгоритмОбъект – СправочникОбъект.Сервисы2iS;
//  *НомерСтрокиВМодуле – Число, *0 - если указана, устанавливает текущую строку в модуле;
//  *ИдентификаторПроцесса – Число, *0 - если указан, будет открываться только в заданном процессе;
//  *Переоткрыть   - Булево, *Истина - переоткрыть, если уже открыт
//
Процедура ОткрытьАлгоритмВОтладчике(АлгоритмОбъект, НомерСтрокиВМодуле = 0, ИдентификаторПроцесса = 0, Переоткрыть = Истина) Экспорт 

	Если Не ВыполнятьАлгоритмыЧерезВнешниеОбработки Тогда
		Сообщить("Данная функция доступна только в режиме выполнения сервисов через внешние обработки", СтатусСообщения.Информация);
		Возврат;
	КонецЕсли; 
	Если Не ФайловыйКэшАлгоритмовДопускаетРедактирование Тогда
		Сообщить("Т.к. не включено разрешение редактирования файлового кэша, изменения файла будут игнорироваться",
			СтатусСообщения.Информация);
	КонецЕсли;
	ПолучитьФайлОткрывателя1С();
	ФайлВнешнейОбработки = ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект);
	Если ФайлВнешнейОбработки <> Неопределено Тогда
		СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """ -com -ob1""" + ФайлВнешнейОбработки.ПолноеИмя + """";
		Если ЗначениеЗаполнено(НомерСтрокиВМодуле) Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -num" + Формат(НомерСтрокиВМодуле, "ЧГ=");
		КонецЕсли;
		Если ЗначениеЗаполнено(ИдентификаторПроцесса) Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -pid" + Формат(ИдентификаторПроцесса, "ЧГ=");
		КонецЕсли;
		Если Переоткрыть Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -reopen";
		КонецЕсли;
		WshShell.Run(СтрокаЗапуска, 0, Ложь);
	КонецЕсли;

КонецПроцедуры 

// Открывает модуль внешней обработки в конфигураторе.
//
// Параметры:
//  ПолноеИмяФайла – Строка;
//  *НомерСтрокиВМодуле – Число, *0 - если указана, устанавливает текущую строку в модуле;
//  *ИдентификаторПроцесса – Число, *0 - если указан, будет открываться только в заданном процессе;
//  *Переоткрыть   - Булево, *Истина - переоткрыть, если уже открыт
//
Процедура ОткрытьМодульВнешнейОбработкиВОтладчике(ПолноеИмяФайла, НомерСтрокиВМодуле = 0, ИдентификаторПроцесса = 0, Переоткрыть = Истина) Экспорт 

	ПолучитьФайлОткрывателя1С();
	ФайлВнешнейОбработки = Новый Файл(ПолноеИмяФайла);
	Если ФайлВнешнейОбработки <> Неопределено Тогда
		СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """ -com -ob1""" + ФайлВнешнейОбработки.ПолноеИмя + """";
		Если НомерСтрокиВМодуле > 0 Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -num" + Формат(НомерСтрокиВМодуле, "ЧГ=");
		КонецЕсли;
		Если ИдентификаторПроцесса > 0 Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -pid" + Формат(ИдентификаторПроцесса, "ЧГ=");
		КонецЕсли;
		Если Переоткрыть Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -reopen";
		КонецЕсли;
		WshShell.Run(СтрокаЗапуска, 0, Ложь);
	КонецЕсли;

КонецПроцедуры 

// Открывает файл в конфигураторе.
//
// Параметры:
//  ПолноеИмя    – Строка;
//  *ЭлементОбработки – "Форма", "Модуль", *Неопределено$
//  *ИдентификаторПроцесса – Число, *0 - если указан, будет открываться только в заданном процессе.
//
Процедура ОткрытьФайлВКонфигураторе(ПолноеИмя, ЭлементОбработки = "", ИдентификаторПроцесса = 0) Экспорт 

	ПолучитьФайлОткрывателя1С();
	ФайлВнешнейОбработки = Новый Файл(ПолноеИмя);
	Если ФайлВнешнейОбработки.Существует() Тогда
		//WshShell = Новый COMОбъект("WScript.Shell");
		СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """";
		Если ЭлементОбработки = "Форма" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -cof";
		ИначеЕсли ЭлементОбработки = "Модуль" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -com";
		Иначе
			СтрокаЗапуска = СтрокаЗапуска + " -coa";
		КонецЕсли;
		СтрокаЗапуска = СтрокаЗапуска + " -ob1""" + ПолноеИмя + """";
		Если ИдентификаторПроцесса > 0 Тогда
			СтрокаЗапуска = СтрокаЗапуска + " -pid" + Формат(ИдентификаторПроцесса, "ЧГ=");
		КонецЕсли;
		WshShell.Run(СтрокаЗапуска, 0, Ложь);
	КонецЕсли;

КонецПроцедуры // ОткрытьФайлВКонфигураторе()

// Открывает диалог глобального поиска в конфигураторе и устанавливает каталог файлов.
//
// Параметры:
//  КаталогРасположения - Строка;
//  *ИдентификаторПроцесса – Число, *0 - если указан, будет открываться только в заданном процессе.
//
Процедура ОткрытьДиалогГлобальногоПоискаВКонфигураторе(КаталогРасположения, ИдентификаторПроцесса = 0) Экспорт 

	ПолучитьФайлОткрывателя1С();
	СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """";
	СтрокаЗапуска = СтрокаЗапуска + " -cgf";
	СтрокаЗапуска = СтрокаЗапуска + " -ob1""" + КаталогРасположения + """";
	Если ИдентификаторПроцесса > 0 Тогда
		СтрокаЗапуска = СтрокаЗапуска + " -pid" + Формат(ИдентификаторПроцесса, "ЧГ=");
	КонецЕсли;
	WshShell.Run(СтрокаЗапуска, 0, Ложь);

КонецПроцедуры // ОткрытьДиалогГлобальногоПоискаВКонфигураторе()

// Активизирует главное окно процесса по PID.
//
// Параметры:
//  *ИдентификаторПроцесса – Число.
//
Процедура АктивизироватьОкноПроцесса1С8(ИдентификаторПроцесса = 0) Экспорт 

	ПолучитьФайлОткрывателя1С();
	СтрокаЗапуска = """" + ФайлОткрывателя1С.ПолноеИмя + """";
	СтрокаЗапуска = СтрокаЗапуска + " -aaa -pid" + Формат(ИдентификаторПроцесса, "ЧГ=");
	WshShell.Run(СтрокаЗапуска, 0, Ложь);

КонецПроцедуры // ОткрытьДиалогГлобальногоПоискаВКонфигураторе()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура СохранитьНастройкиАлгоритмов() Экспорт 

	СохранитьЗначение("ирПлатформа.МаскироватьФайловыйКэш", МаскироватьФайловыйКэш);
	СохранитьЗначение("ирПлатформа.ФиксироватьВнешниеИсключенияАлгоритмов", ФиксироватьВнешниеИсключенияАлгоритмов);
	СохранитьЗначение("ирПлатформа.СинтаксическийКонтрольПередЗаписью", СинтаксическийКонтрольПередЗаписью);
	СохранитьЗначение("ирПлатформа.ВыполнятьАлгоритмыЧерезВнешниеОбработки", ВыполнятьАлгоритмыЧерезВнешниеОбработки);
	СохранитьЗначение("ирПлатформа.ФайловыйКэшАлгоритмовДопускаетРедактирование", ФайловыйКэшАлгоритмовДопускаетРедактирование);
	СохранитьЗначение("ирПлатформа.ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов", ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов);

КонецПроцедуры // СохранитьНастройкиАлгоритмов()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИдентификаторПроцессаОС() Экспорт

	Если Не ЗначениеЗаполнено(ИдентификаторПроцессаОС) Тогда
		//ДочернийПроцесс = WshShell.Exec("rundll32.exe kernel32,Sleep");
		//ИдентификаторПроцессаОС = ПолучитьCOMОбъектИзМакета("winmgmts:{impersonationLevel=impersonate}!\\.\root\CIMV2:Win32_Process.Handle='"
		//	+ Формат(ДочернийПроцесс.ProcessID, "ЧГ=0") + "'").ParentProcessID;
		//ДочернийПроцесс.Terminate();
		ИдентификаторПроцессаОС = WinAPI.GetCurrentProcessId();
	КонецЕсли;
	Возврат ИдентификаторПроцессаОС;

КонецФункции // ПолучитьИдентификаторПроцессаОС()

// Получает структуру для индикации прогресса цикла.
//
// Параметры:
//  КоличествоПроходов – Число - максимальное значение счетчика;
//  ПредставлениеПроцесса – Строка, "Выполнено" – отображаемое название процесса;
//  ВнутреннийСчетчик - Булево, *Истина - использовать внутренний счетчик с начальным значением 1,
//                    иначе нужно будет передавать значение счетчика при каждом вызове обновления индикатора;
//  КоличествоОбновлений - Число, *0 - всего количество обновлений индикатора, 0 - по минимальному периоду;
//  ЛиВыводитьВремя - Булево, *Истина - выводить приблизительное время до окончания процесса;
//  РазрешитьПрерывание - Булево, *Истина - разрешает пользователю прерывать процесс.
//  МинимальныйПериодОбновления - Число, *0.5 - с, обновлять не чаще чем этот период, 0 - по количеству обновлений;
//
// Возвращаемое значение:
//  Структура - которую потом нужно будет передавать в метод ирОбщий.ОбработатьИндикаторЛкс.
//
Функция ПолучитьИндикаторПроцесса(Знач КоличествоПроходов = 0, ПредставлениеПроцесса = "Выполнение", ВнутреннийСчетчик = Истина,
	Знач КоличествоОбновлений = 0, ЛиВыводитьВремя = Истина, РазрешитьПрерывание = Истина, МинимальныйПериодОбновления = 0.5) Экспорт 

	//ПолучитьWinAPI();
	Индикатор = Новый Структура;
	Если КоличествоПроходов = 0 Тогда
		Состояние(ПредставлениеПроцесса + "...");
		КоличествоПроходов = 1;
	КонецЕсли;
	Индикатор.Вставить("КоличествоПроходов", КоличествоПроходов);
	Индикатор.Вставить("ПредставлениеПроцесса", ПредставлениеПроцесса);
	Индикатор.Вставить("ЛиВыводитьВремя", ЛиВыводитьВремя);
	Индикатор.Вставить("РазрешитьПрерывание", РазрешитьПрерывание);
	Индикатор.Вставить("МинимальныйПериодОбновления", МинимальныйПериодОбновления);
	
	Индикатор.Вставить("ДатаНачалаПроцесса", ТекущаяДата());
	Индикатор.Вставить("ДатаСледующегоОбновления", Дата('00010101'));
	
	Индикатор.Вставить("ВремяНачалаПроцесса", ПолучитьТекущееВремяВМиллисекундах());
	Индикатор.Вставить("ВремяСледующегоОбновления", 0);
	
	Индикатор.Вставить("ВнутреннийСчетчик", ВнутреннийСчетчик);
	Если КоличествоОбновлений > 0 Тогда
		Шаг = КоличествоПроходов / КоличествоОбновлений;
	Иначе
		Шаг = 0;
	КонецЕсли; 
	Индикатор.Вставить("Шаг", Шаг);
	Индикатор.Вставить("СледующийСчетчик", 0);
	Индикатор.Вставить("Счетчик", 0);
	//ВложенностьИндикации = ВложенностьИндикации + 1;
	Возврат Индикатор;

КонецФункции // ирОбщий.ПолучитьИндикаторПроцессаЛкс()

// Проверяет и обновляет индикатор. Нужно вызывать на каждом проходе индицируемого цикла.
//
// Параметры:
//  Индикатор    – Структура – индикатора, полученная методом ирОбщий.ПолучитьИндикаторПроцессаЛкс;
//  Счетчик      – Число – внешний счетчик цикла, используется при ВнутреннийСчетчик = Ложь.
//
Процедура ОбработатьИндикатор(Индикатор, Счетчик = Неопределено) Экспорт 

	Если Счетчик = Неопределено Тогда
		Счетчик = Индикатор.Счетчик + 1;
		Индикатор.Счетчик = Счетчик;
	КонецЕсли;
	Если Индикатор.РазрешитьПрерывание Тогда
		ОбработкаПрерыванияПользователя();
	КонецЕсли;
	ОбновитьИндикатор = Истина;
	Если Счетчик < Индикатор.КоличествоПроходов Тогда 
		ТекущееВремя = ПолучитьТекущееВремяВМиллисекундах();
		Если Индикатор.МинимальныйПериодОбновления > 0 Тогда
			Если ТекущееВремя >= Индикатор.ВремяСледующегоОбновления Тогда
				Индикатор.ВремяСледующегоОбновления = ТекущееВремя + Индикатор.МинимальныйПериодОбновления * 1000;
			Иначе
				ОбновитьИндикатор = Ложь;
			КонецЕсли;
		КонецЕсли;
		Если ОбновитьИндикатор Тогда
			Если Индикатор.Шаг > 0 Тогда
				Если Счетчик >= Индикатор.СледующийСчетчик Тогда
					Индикатор.СледующийСчетчик = Цел(Счетчик + Индикатор.Шаг);
				Иначе
					ОбновитьИндикатор = Ложь;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Если ОбновитьИндикатор Тогда
		Если Истина
			И Индикатор.ЛиВыводитьВремя 
			И Счетчик > 0
			И Счетчик < Индикатор.КоличествоПроходов
		Тогда
			ПрошлоВремени = (ТекущееВремя - Индикатор.ВремяНачалаПроцесса) / 1000;
			Осталось = ПрошлоВремени * (Индикатор.КоличествоПроходов / Счетчик - 1);
			Часов = Цел(Осталось / 3600);
			Осталось = Осталось - (Часов * 3600);
			Минут = Цел(Осталось / 60);
			Секунд = Цел(Цел(Осталось - (Минут * 60)));
			ОсталосьВремени = Формат(Часов, "ЧЦ=2; ЧН=00; ЧВН=") + ":" 
				+ Формат(Минут, "ЧЦ=2; ЧН=00; ЧВН=") + ":" 
				+ Формат(Секунд, "ЧЦ=2; ЧН=00; ЧВН=");
			ТекстОсталось = ", Осталось: ~" + ОсталосьВремени;
		Иначе
			ТекстОсталось = "";
		КонецЕсли;
		ТекстСостояния = Индикатор.ПредставлениеПроцесса + ": " 
			+ Формат(Счетчик / Индикатор.КоличествоПроходов * 100, "ЧЦ=3; ЧДЦ=0; ЧН=") + "%" + ТекстОсталось;
		Если ТипЗнч(Индикатор) = Тип("СтрокаТаблицыЗначений") Тогда
			ТаблицаИндикаторов = Индикатор.Владелец();
			ИндексИндикатора = ТаблицаИндикаторов.Индекс(Индикатор);
			Если ИндексИндикатора > 0 Тогда
				ТекстСостояния = ТаблицаИндикаторов[ИндексИндикатора - 1].ТекстСостояния + ".>> " + ТекстСостояния;
			КонецЕсли;
			Индикатор.ТекстСостояния = ТекстСостояния;
		КонецЕсли; 
		Состояние(ТекстСостояния);
	КонецЕсли;
	//Если Счетчик = Индикатор.КоличествоПроходов Тогда
	//	Состояние("");
	//КонецЕсли;

КонецПроцедуры // ирОбщий.ОбработатьИндикаторЛкс()

Процедура ЗаполнитьТаблицуРедактируемыхТипов() Экспорт
	
	ОписаниеТипов = ирОбщий.ПолучитьОписаниеТиповВсеРедактируемыеТипыЛкс();
	Для Каждого Тип Из ОписаниеТипов.Типы() Цикл
		СтрокаТипа = ТаблицаРедактируемыхТипов.Добавить();
		//СтрокаТипа.Представление = "" + Тип;
		ТипXML = СериализаторXDTO.XMLТип(Тип);
		Если Тип = Тип("Число") Тогда
			СтрокаТипа.Порядок = -4;
		ИначеЕсли Тип = Тип("Строка") Тогда
			СтрокаТипа.Порядок = -3;
		ИначеЕсли Тип = Тип("Дата") Тогда
			СтрокаТипа.Порядок = -2;
		ИначеЕсли Тип = Тип("Булево") Тогда
			СтрокаТипа.Порядок = -1;
		ИначеЕсли Истина
			И ТипXML <> Неопределено
			И Найти(ТипXML.ИмяТипа, ".") > 0
		Тогда
			СтрокаТипа.Порядок = 100;
			ОбъектМД = Метаданные.НайтиПоТипу(Тип);
			ТекущееИмяТипа = ОбъектМД.ПолноеИмя();
			ИмяТипаМетаданных = ирОбщий.ПолучитьПервыйФрагментЛкс(ТекущееИмяТипа);
			СтрокаТипаМетаОбъектов = ПолучитьСтрокуТипаМетаОбъектов(ИмяТипаМетаданных);
			Если СтрокаТипаМетаОбъектов <> Неопределено Тогда
				СтрокаТипа.ИндексКартинки = СтрокаТипаМетаОбъектов.ИндексКартинкиЕдинственное;
			КонецЕсли;
		КонецЕсли; 
		СтрокаТипа.Имя = ТипXML.ИмяТипа;
		СтрокаТипа.URIПространстваИмен = ТипXML.URIПространстваИмен;
		СтрокаТипа.Представление = "" + Тип;
	КонецЦикла;
	ТаблицаРедактируемыхТипов.Сортировать("Порядок, Имя");
	
КонецПроцедуры

#КонецЕсли

////////////////////////////////////////////////////////////////////////////////////////////////////

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция мПолучитьПарсер(ИмяГрамматики, Кэшировать = Истина) Экспорт

	Если Кэшировать Тогда
		Если Парсеры.Свойство(ИмяГрамматики) Тогда
			Возврат Парсеры[ИмяГрамматики];
		КонецЕсли; 
	КонецЕсли;
	Парсер = ПолучитьCOMОбъектИзМакета("GoldParser", "GOLDParserEngine.GOLDParser");
	Если Парсер <> Неопределено Тогда 
        Парсер.TrimReductions = Истина;
		МакетГрамматики = ПолучитьМакет(ИмяГрамматики);
		ФайлСкомпилированнойГрамматики = ПолучитьИмяВременногоФайла("cgt");
		МакетГрамматики.Записать(ФайлСкомпилированнойГрамматики);
		Если Не Парсер.LoadCompiledGrammar(ФайлСкомпилированнойГрамматики) Тогда
			ирОбщий.СообщитьСУчетомМодальностиЛкс("Не удалось загрузить файл грамматики """ + ФайлСкомпилированнойГрамматики + """",
				Истина, СтатусСообщения.Важное);
			Парсер = Неопределено;
		КонецЕсли;
		УдалитьФайлы(ФайлСкомпилированнойГрамматики);
	КонецЕсли;
	Если Кэшировать Тогда
		Парсеры.Вставить(ИмяГрамматики, Парсер);
	КонецЕсли;
	Возврат Парсер;

КонецФункции // ИнициализироватьПарсер()

// Получает идентификатор из любой строки.
// "3-я Дебиторка По контрагентам с интервалами СНГ (для  Руководства)" => "_3_яДебиторкаПоКонтрагентамСИнтерваламиСНГ_дляРуководства_".
//
// Параметры:
//  Представление – Строка.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьИдентификаторИзПредставления(Знач Представление, ЗаменаПустойСтроки = "_") Экспорт

	Если ПустаяСтрока(Представление) Тогда
		Представление = ЗаменаПустойСтроки;
	КонецЕсли;
	Если СокрЛП(Представление) = Представление Тогда
		Попытка
			Пустышка = Новый Структура(Представление);
			Возврат Представление;
		Исключение КонецПопытки;
	КонецЕсли; 
	VBRegExp.Pattern = "\d";
	НовоеПредставление = Представление;
	ПервыйСимвол = Сред(Представление, 1, 1);
	Если VBRegExp.Test(ПервыйСимвол) Тогда
		// Первый символ - цифра
		НовоеПредставление = "_" + НовоеПредставление;
	КонецЕсли;
	ПредыдущийСимвол = " ";
	ТекущаяСтрока = "";
	Для Счетчик = 1 По СтрДлина(НовоеПредставление) Цикл
		ТекущийСимвол = Сред(НовоеПредставление, Счетчик, 1);
		VBRegExp.Pattern = "\s";
		Если VBRegExp.Test(ПредыдущийСимвол) Тогда
			// Предыдущий символ - непечатаемый
			ТекущийСимвол = ВРег(ТекущийСимвол);
		КонецЕсли;
		VBRegExp.Pattern = "[" + шБуква + "\d]";
		Если VBRegExp.Test(ТекущийСимвол) Тогда
			// Предыдущий символ - непечатаемый
			ТекущаяСтрока = ТекущаяСтрока + ТекущийСимвол;
		Иначе
			VBRegExp.Pattern = "[\S]";
			Если VBRegExp.Test(ТекущийСимвол) Тогда
				ТекущаяСтрока = ТекущаяСтрока + "_";
			КонецЕсли;
		КонецЕсли;
		ПредыдущийСимвол = ТекущийСимвол;
	КонецЦикла;
	Результат = ТекущаяСтрока;
	Возврат ТекущаяСтрока;

КонецФункции // ПолучитьИдентификаторИзПредставления()

// Добавляет новую строку в таблицу корневых объектов.
//
// Параметры:
//  Таблица      – ТаблицаЗначений;
//  *Категория   - Число, *0;
//  Единственное – Строка;
//  ИндексКартинкиЕдинственное – Число;
//  Множественное – Строка;
//  ИндексКартинкиМножественное – Число;
//
Процедура ДобавитьВТаблицуТиповМетаОбъектов(Таблица, Категория = 0, Единственное, ИндексКартинкиЕдинственное,
	Множественное, ИндексКартинкиМножественное)

	НовыйКорневойОбъект = Таблица.Добавить();
	НовыйКорневойОбъект.Категория = Категория;
	НовыйКорневойОбъект.Единственное = Единственное;
	НовыйКорневойОбъект.ИндексКартинкиЕдинственное = ИндексКартинкиЕдинственное;
	НовыйКорневойОбъект.Множественное = Множественное;
	НовыйКорневойОбъект.ИндексКартинкиМножественное = ИндексКартинкиМножественное;

КонецПроцедуры // ДобавитьВТаблицуТиповМетаОбъектов()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ПроверитьСтруктуруФайловогоКэша() Экспорт 

	ПроверитьКаталогФайловогоКэша();
	СтруктураПодкаталоговФайловогоКэша = Новый Структура;
	СтруктураПодкаталоговФайловогоКэша.Вставить("a");
	СтруктураПодкаталоговФайловогоКэша.Вставить("b");
	СтруктураПодкаталоговФайловогоКэша.Вставить("c");
	Для Каждого ЭлементПодкаталога Из СтруктураПодкаталоговФайловогоКэша Цикл
		//Если МаскироватьФайловыйКэш Тогда
		//	ИмяПодкаталога = Подкаталог + "h";
		//Иначе
		//	ИмяПодкаталога = Подкаталог + "v";
		//КонецЕсли;
		ПолныйПутьКаталога = КаталогФайловогоКэша + "\" + ЭлементПодкаталога.Ключ;
		ФайлКаталога = Новый Файл(ПолныйПутьКаталога);
		Если Не ФайлКаталога.Существует() Тогда
			Попытка
				СоздатьКаталог(ФайлКаталога.ПолноеИмя);
				ПробныйФайл = Новый ТекстовыйДокумент;
				ПробныйФайл.Записать(ФайлКаталога.ПолноеИмя + "\1.txt");
			Исключение
				Сообщить("Дополнительный кэш """ + ЭлементПодкаталога.Ключ + """ отключен.", СтатусСообщения.Важное);
				Продолжить;
			КонецПопытки;
		КонецЕсли;
		СтруктураПодкаталоговФайловогоКэша[ЭлементПодкаталога.Ключ] = ФайлКаталога;
		Если ЭлементПодкаталога.Ключ = "a" Тогда
			//КаталогДинамическихВнешнихОбработок = ПолныйПутьКаталога;
			ПапкаКешаВнешнихОбработокАлгоритмов = ФайлКаталога;
			
			ТекущаяДатаДвижка = Дата("20100927"); // Здесь меняем редко. Будет приводить к разовой очистке кэша перед началом его использования
			ФайлКэшаДвижка = Новый Файл(ПолныйПутьКаталога + "\_EngineTimeStamp.mll");
			ДатаКэшаДвижка = Неопределено;
			Если ФайлКэшаДвижка.Существует() Тогда
				Попытка
					ДатаКэшаДвижка = ЗначениеИзФайла(ФайлКэшаДвижка.ПолноеИмя);
				Исключение КонецПопытки;
			КонецЕсли;
			Если ДатаКэшаДвижка <> ТекущаяДатаДвижка Тогда
				Попытка
					УдалитьФайлы(ПолныйПутьКаталога + "\", "*.*");
				Исключение
					Неудача = Истина;
				КонецПопытки; 
				Если Неудача <> Истина Тогда
					ЗначениеВФайл(ФайлКэшаДвижка.ПолноеИмя, ТекущаяДатаДвижка);
				КонецЕсли; 
			КонецЕсли;
		ИначеЕсли ЭлементПодкаталога.Ключ = "b" Тогда
			ПапкаКешаВнешнихОбработокАрхива = ФайлКаталога;
		ИначеЕсли ЭлементПодкаталога.Ключ = "c" Тогда
			ПапкаВнешнихКомпонент = ФайлКаталога;
		КонецЕсли;
	КонецЦикла;
	
	ПутьККаталогуСлужебныхВременныхФайлов = КаталогВременныхФайлов() + "temp1template\";
	СоздатьКаталог(ПутьККаталогуСлужебныхВременныхФайлов);
	МассивЗамков = НайтиФайлы(ПутьККаталогуСлужебныхВременныхФайлов, "*.lck");
	Для Каждого Замок Из МассивЗамков Цикл
		Попытка
			УдалитьФайлы(Замок.ПолноеИмя);
			УдалитьФайлы(Замок.Путь + Замок.ИмяБезРасширения);
		Исключение
		КонецПопытки; 
	КонецЦикла;
	
КонецПроцедуры // ПроверитьСтруктуруФайловогоКэша()

// Получает таблицу единственных и множественных чисел корневых типов.
//
// Параметры:
//  *ЛиВключатьНехранимые - Булево, *Истина - включать ли нехранимые корневые типы;
//  *ЛиВключатьДочерние - Булево, *Истина - включать ли дочерние корневые типы;
//  *ЛиВключатьВнешние - Булево, *Истина - включать ли внешние корневые типы.
//
// Возвращаемое значение:
//  Массив – имен хранимых типов
//
Функция ПолучитьТаблицуТиповМетаОбъектов(ЛиВключатьНехранимые = Истина, ЛиВключатьДочерние = Истина, ЛиВключатьВнешние = Истина) Экспорт

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Категория", Новый ОписаниеТипов("Число")); // 0 - корневой, 1 - нехранимый, 2 - дочерний, 3 - внешний
	Таблица.Колонки.Добавить("Единственное");
	Таблица.Колонки.Добавить("ИндексКартинкиЕдинственное");
	Таблица.Колонки.Добавить("Множественное");
	Таблица.Колонки.Добавить("ИндексКартинкиМножественное");
	
	// Корневые типы
	Если ЛиВключатьНехранимые Тогда
		// Главным образом эти строки нужны для связи с пиктограммами этих коллекций
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "WebСервис", ,          "WebСервисы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "WSCсылка", ,           "WSСсылки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ГруппаКоманд", ,       "ГруппыКоманд", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Интерфейс", ,          "Интерфейсы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Нумератор", ,          "НумераторыДокументов", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Обработка", 19,        "Обработки", 18);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяКартинка", ,      "ОбщиеКартинки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяКоманда", ,       "ОбщиеКоманды", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяФорма", ,         "ОбщиеФормы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийМакет", ,         "ОбщиеМакеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийМодуль", ,        "ОбщиеМодули", );
		Если ВерсияПлатформы >= 802014 Тогда
			ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийРеквизит", ,      "ОбщиеРеквизиты", );
		КонецЕсли; 
		Если ВерсияПлатформы >= 803003 Тогда
			ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОпределяемыйТип", ,    "ОпределяемыеТипы", );
		КонецЕсли; 
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Отчет", 24,            "Отчеты", 23);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПараметрСеанса", ,     "ПараметрыСеанса", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПараметрФункциональныхОпций", , "ПараметрыФункциональныхОпций", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПакетXDTO", ,          "ПакетыXDTO", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПодпискаНаСобытие", ,  "ПодпискиНаСобытия", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Подсистема", ,         "Подсистемы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "РегламентноеЗадание", , "РегламентныеЗадания", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Роль", ,               "Роли", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Стиль", ,              "Стили", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ФункциональнаяОпция", ,"ФункциональныеОпции", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ХранилищеНастроек", ,  "ХранилищаНастроек", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ЭлементСтиля", ,       "ЭлементыСтиля", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Язык", ,               "Языки", );
	КонецЕсли;
	Если ВерсияПлатформы >= 802014 Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ВнешнийИсточникДанных", ,  "ВнешниеИсточникиДанных", ); // Перенес из категории 1 02.03.2012
	КонецЕсли; 
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланОбмена", 52,           "ПланыОбмена", 51);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Константа", 0,             "Константы", 1);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Справочник", 3,            "Справочники", 2);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "КритерийОтбора", ,         "КритерииОтбора", );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Последовательность", ,     "Последовательности", );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Документ", 13,             "Документы", 12);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ЖурналДокументов", 16,     "ЖурналыДокументов", 15);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Перечисление", 10,         "Перечисления", 9);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланВидовХарактеристик", 38, "ПланыВидовХарактеристик", 37);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланСчетов", 40,           "ПланыСчетов",39 );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланВидовРасчета", 48,     "ПланыВидовРасчета", 47);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрСведений", 34,      "РегистрыСведений", 33);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрНакопления", 32,    "РегистрыНакопления", 31);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрБухгалтерии", 42,   "РегистрыБухгалтерии", 41);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрРасчета", 50,       "РегистрыРасчета", 49);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "БизнесПроцесс", 44,        "БизнесПроцессы", 43);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Задача", 46,               "Задачи", 45);
	
	// Дочерние типы
	Если ЛиВключатьДочерние Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Графа", ,                 "Графы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ЗначениеПеречисления", ,  "ЗначенияПеречисления", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Измерение", ,             "Измерения", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Команда", ,               "Команды", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Макет", ,                 "Макеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Операция", ,              "Операции", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Параметр", ,              "Параметры", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Перерасчет", ,            "Перерасчеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Поле", ,                  "Поля", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ПризнакУчета", ,          "ПризнакиУчета", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ПризнакУчетаСубконто", ,  "ПризнакиУчетаСубконто", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Реквизит", ,              "Реквизиты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "РеквизитАдресации", ,     "РеквизитыАдресации", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Ресурс", ,                "Ресурсы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ТабличнаяЧасть", 55,      "ТабличныеЧасти", 54);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Таблица", ,               "Таблицы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Форма", ,                 "Формы", );
		Если ВерсияПлатформы >= 803003 Тогда
			ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ТаблицаИзмерения", ,   "ТаблицыИзмерений", );
		КонецЕсли; 
	КонецЕсли;
	
	// Внешние типы
	Если ЛиВключатьВнешние Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 3, "ВнешняяОбработка", ,      "ВнешниеОбработки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 3, "ВнешнийОтчет", ,          "ВнешниеОтчеты", );
	КонецЕсли;
	
	Возврат Таблица;

КонецФункции // ПолучитьТаблицуКорневыхОбъектов()

Функция ПолучитьТекстРезультатаКомандыСистемы(Знач Команда = "", Знач ИмяСервера = "", Знач ИспользоватьWSH = Истина) Экспорт
	
	Если Не ЗначениеЗаполнено(ИмяСервера) Тогда
		ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
		СтрокаЗапуска = Команда;
		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(СтрокаЗапуска, ФайлРезультата.Путь, ИспользоватьWSH, ФайлРезультата.Имя);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.Прочитать(ФайлРезультата.ПолноеИмя, КодировкаТекста.OEM);
		УдалитьФайлы(ФайлРезультата.ПолноеИмя);
		Результат = ТекстовыйДокумент.ПолучитьТекст();
	Иначе
		ВызватьИсключение "Получение результата команды системы на удаленном сервере не реализовано";
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

Функция ЗарегистрироватьПолучитьCOMОбъект(КлассКомпоненты, ПолноеИмяDll, Административная = Ложь, ИмяТипаВК = Ложь) Экспорт
	
	Если Не Административная Тогда
		// HKCU через сторонний регистратор. Обычно это срабатывает
		Если ФайлРегистратораКомпонент = Неопределено Тогда
			ФайлРегистратораКомпонент = ПроверитьЗаписатьКомпонентуИзМакетаВФайл("RegsvrPower", , "exe");
			ПроверитьЗаписатьКомпонентуИзМакетаВФайл("TLBINF32");
		КонецЕсли;
		//Regsvrex тут иногда падает
		//КоманднаяСтрока = """" + ФайлРегистратораКомпонент.ПолноеИмя + """ /c /s /i """ + ПолноеИмяDll + """"; // RegsvrEx
		ФайлКомпоненты = Новый Файл(ПолноеИмяDll);
		КоманднаяСтрока = """" + ФайлРегистратораКомпонент.ПолноеИмя + """ " + ФайлКомпоненты.Имя + " /s"; // RegsvrPower не понимает длинные пути
		ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, ФайлКомпоненты.Путь, Истина);
		Компонента = ПолучитьПроверитьCOMОбъект(КлассКомпоненты, ИмяТипаВК);
		Если Компонента <> Неопределено Тогда 
			Сообщить("В HKCU зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
			Возврат Компонента;
		КонецЕсли;
		
	КонецЕсли; 
	
	// HKLM с DLLInstall
	КоманднаяСтрока = "regsvr32 /s /i """ + ПолноеИмяDll + """";
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, , Истина);
	Компонента = ПолучитьПроверитьCOMОбъект(КлассКомпоненты, ИмяТипаВК);
	Если Компонента <> Неопределено Тогда 
		Сообщить("В HKLM зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
		Возврат Компонента;
	КонецЕсли;
	
	// HKLM
	КоманднаяСтрока = "regsvr32 /s """ + ПолноеИмяDll + """";
	//ТекстРезультата = ПолучитьТекстРезультатаКомандыСистемы(КоманднаяСтрока,, Истина);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(КоманднаяСтрока, , Истина);
	Компонента = ПолучитьПроверитьCOMОбъект(КлассКомпоненты, ИмяТипаВК);
	Если Компонента <> Неопределено Тогда 
		Сообщить("В HKLM зарегистрирована COM-компонента " + КлассКомпоненты, СтатусСообщения.Информация);
		Возврат Компонента;
	КонецЕсли;
	
	Сообщить("Не удалось зарегистривать COM-компоненту " + КлассКомпоненты + ". Возможно требуется запуск от имени администратора",
		СтатусСообщения.Внимание);
	Возврат Неопределено;

КонецФункции // ЗарегистрироватьПолучитьCOMОбъект

Функция ПолучитьПроверитьCOMОбъект(КлассКомпоненты, ИмяТипаВК = "") Экспорт
	
	Если ЗначениеЗаполнено(ИмяТипаВК)  Тогда
		ПодключитьВнешнююКомпоненту(КлассКомпоненты);
		Попытка
			Компонента = Новый ("AddIn." + ИмяТипаВК);
		Исключение
		КонецПопытки; 
		Возврат Компонента;
	Иначе
		Попытка
			Компонента = Новый COMОбъект(КлассКомпоненты);
			Если КлассКомпоненты = "DynamicWrapperX" Тогда
				// Проверка на нужную версию компоненты DynamicWrapperX 
				Попытка
					Пустышка = Компонента.GetIDispatch(Компонента);
					Возврат Компонента;
				Исключение
				КонецПопытки;
			Иначе
				Возврат Компонента;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли; 
	Возврат Неопределено;
	
КонецФункции

// Возвращает нужный com-объект. Если компонента не зарегистрирована, то пытается ее сохранить из макета и зарегистрировать.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  COM-объект, Неопределено.
//
Функция ПолучитьCOMОбъектИзМакета(ИмяМакетаКомпоненты, КлассКомпоненты, КаталогУстановки = "авто", ИмяМакетаДополнительнойБиблиотеки = "",
	ИмяТипаВК = "") Экспорт

	Результат = ПолучитьПроверитьCOMОбъект(КлассКомпоненты, ИмяТипаВК);
	Если Результат = Неопределено Тогда
		Если Нрег(КаталогУстановки) = Нрег("авто") Тогда
			КаталогУстановки = ПапкаВнешнихКомпонент.ПолноеИмя;
		КонецЕсли; 
		#Если Клиент Тогда
		Если КаталогУстановки = "" Тогда
			Ответ = Вопрос("Для работы данной функции необходимо зарегистрировать 
				//|(необходимы права локального администратора)
				|	COM-компоненту """ + ИмяМакетаКомпоненты + """. Выполнить регистрацию?",
				РежимДиалогаВопрос.ОКОтмена, 30, КодВозвратаДиалога.Отмена);
			Если Ответ = КодВозвратаДиалога.Отмена Тогда
				Возврат Неопределено;
			КонецЕсли;
			ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
			ВыборФайла.Заголовок = "Укажите папку, куда установить компоненту.";
			Если Не ВыборФайла.Выбрать() Тогда
				Возврат Неопределено;
			КонецЕсли;
			КаталогУстановки = ВыборФайла.Каталог;
		КонецЕсли;
		#КонецЕсли
		ФайлКомпоненты = ПроверитьЗаписатьКомпонентуИзМакетаВФайл(ИмяМакетаКомпоненты, КаталогУстановки);
		Если ЗначениеЗаполнено(ИмяМакетаДополнительнойБиблиотеки) Тогда
			ФайлДополнительнойБиблиотеки = ПроверитьЗаписатьКомпонентуИзМакетаВФайл(ИмяМакетаДополнительнойБиблиотеки, КаталогУстановки);
		КонецЕсли; 
		Результат = ЗарегистрироватьПолучитьCOMОбъект(КлассКомпоненты, ФайлКомпоненты.ПолноеИмя, , ИмяТипаВК);
	КонецЕсли; 
	Возврат Результат;

КонецФункции // ПолучитьCOMОбъектИзМакета()

// Параметры:
//   ИмяКомпоненты - Строка - имя макета компоненты
//   КлассКомпоненты - Строка - имя 
//   ТипВнешнейКомпоненты - ТипВнешнейКомпоненты, * - по умолчанию Native
Функция ПолучитьОбъектВнешнейКомпонентыИзМакета(ИмяМакетаКомпоненты, ИмяОбъекта, ИмяКомпоненты = Неопределено, Знач ТипКомпоненты = Неопределено,
	ИмяМакетаДополнительнойБиблиотеки = "") Экспорт
	
	Если ТипКомпоненты = Неопределено Тогда
		ТипКомпоненты = ТипВнешнейКомпоненты.Native;
	КонецЕсли; 
	Попытка
		Результат = Новый (ИмяОбъекта);
	Исключение
		Если ИмяКомпоненты = Неопределено Тогда
			ИмяКомпоненты = ИмяМакетаКомпоненты;
		КонецЕсли;
		ФайлКомпоненты = ПроверитьЗаписатьКомпонентуИзМакетаВФайл(ИмяМакетаКомпоненты);
		Если ЗначениеЗаполнено(ИмяМакетаДополнительнойБиблиотеки) Тогда
			ФайлДополнительнойБиблиотеки = ПроверитьЗаписатьКомпонентуИзМакетаВФайл(ИмяМакетаДополнительнойБиблиотеки);
		КонецЕсли; 
		ПодключитьВнешнююКомпоненту(ФайлКомпоненты.ПолноеИмя, ИмяКомпоненты, ТипКомпоненты);
		Попытка
			Результат = Новый (ИмяОбъекта);
		Исключение
		КонецПопытки;
	КонецПопытки;
	Возврат Результат;
	
КонецФункции

Функция ПроверитьЗаписатьКомпонентуИзМакетаВФайл(Знач ИмяМакетаКомпоненты, КаталогУстановки = "", Расширение = "dll")

	Если Не ЗначениеЗаполнено(КаталогУстановки) Тогда
		КаталогУстановки = ПапкаВнешнихКомпонент.ПолноеИмя;
	КонецЕсли;
	Если Метаданные().Макеты.Найти(ИмяМакетаКомпоненты) = Неопределено Тогда
		// Надо добавить определение и поддержку 64
		ИмяМакетаКомпоненты = ИмяМакетаКомпоненты + "32";
	КонецЕсли; 
	ДвоичныеДанныеМакета = ПолучитьМакет(ИмяМакетаКомпоненты);
	ФайлКомпоненты = Новый Файл(КаталогУстановки + "\" + ИмяМакетаКомпоненты + "." + Расширение);
	ВременныйФайл = Новый Файл(ПолучитьИмяВременногоФайла());
	ДвоичныеДанныеМакета.Записать(ВременныйФайл.ПолноеИмя);
	Счетчик = 1;
	ФайлПодходит = Ложь;
	Пока ФайлКомпоненты.Существует() Цикл
		#Если Клиент Тогда
		СравнениеФайлов = Новый СравнениеФайлов;
		СравнениеФайлов.СпособСравнения = СпособСравненияФайлов.Двоичное;
		СравнениеФайлов.ПервыйФайл = ВременныйФайл.ПолноеИмя;
		СравнениеФайлов.ВторойФайл = ФайлКомпоненты.ПолноеИмя;
		Если СравнениеФайлов.Сравнить() Тогда
			ФайлПодходит = Истина;
			Прервать;
		КонецЕсли; 
		#Иначе
			Если ВременныйФайл.Размер() = ФайлКомпоненты.Размер() Тогда // Опасно. Переделать на Хэш
				ФайлПодходит = Истина;
				Прервать;
			КонецЕсли; 
		#КонецЕсли
		ФайлКомпоненты = Новый Файл(КаталогУстановки + "\" + ИмяМакетаКомпоненты +  "_" + Формат(Счетчик, "ЧГ=") + "." + Расширение);
		Счетчик = Счетчик + 1;
	КонецЦикла; 
	Если Не ФайлПодходит Тогда
		ПереместитьФайл(ВременныйФайл.ПолноеИмя, ФайлКомпоненты.ПолноеИмя);
	КонецЕсли; 
	Возврат ФайлКомпоненты;

КонецФункции

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция СоздатьОбъектВнешнихМетаданных(ПолноеИмяФайла, МенеджерВнешнихОбъектов = Неопределено, Конвертировать = Истина) Экспорт

	Если МенеджерВнешнихОбъектов = Неопределено Тогда
		МенеджерВнешнихОбъектов = ВнешниеОбработки;
	КонецЕсли; 
	Попытка
		ВнешнийОбъект = МенеджерВнешнихОбъектов.Создать(ПолноеИмяФайла, Ложь);
	Исключение
		#Если Клиент Тогда
		ОписаниеОшибки = ОписаниеОшибки();
		Если Истина
			И Конвертировать
			И Найти(НРег(ОписаниеОшибки), НРег("не может быть прочитан")) > 0 
			//И ВерсияПлатформы <> 802015 // Антибаг 8.2.15 http://partners.v8.1c.ru/forum/thread.jsp?id=1003164#1003164
		Тогда
			СтрокаЗапуска = "DESIGNER /ConvertFiles""" + ПолноеИмяФайла + """";
			ЗапуститьСистему(СтрокаЗапуска, Истина);
			ВнешнийОбъект = МенеджерВнешнихОбъектов.Создать(ПолноеИмяФайла, Ложь);
		Иначе
		#КонецЕсли 
			ВызватьИсключение;
		#Если Клиент Тогда
		КонецЕсли;
		#КонецЕсли 
	КонецПопытки;
	Возврат ВнешнийОбъект;

КонецФункции // СоздатьОбъектВнешнихМетаданных()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция СоздатьВнешнююОбработкуАлгоритма(АлгоритмОбъект, ПолноеИмя) Экспорт 

	Попытка
		ВнешняяОбработка = СоздатьОбъектВнешнихМетаданных(ПолноеИмя);
		Результат = ВнешняяОбработка;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Если Найти(НРег(ОписаниеОшибки), НРег("не может быть прочитана текущей версией")) > 0 Тогда
			УдалитьФайлы(ПолноеИмя);
		КонецЕсли; 
		
		СобытиеОшибки = "Ошибка создания внешнего объекта";
		ОписаниеОшибки = "Загрузка сервиса """ + АлгоритмОбъект.Наименование + """";
		Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
			ОписаниеОшибки = ОписаниеОшибки + "
			|" + ПредставлениеИнформацииОбОшибке(ИнформацияОбОшибке.Причина);
		КонецЕсли;
		ОписаниеОшибки = СобытиеОшибки + ": " + ОписаниеОшибки;
		Если Не МаскироватьФайловыйКэш Тогда
			ОписаниеОшибки = ОписаниеОшибки + ": " + ИнформацияОбОшибке.Описание
				+ Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
		КонецЕсли; 
		Сообщить(ОписаниеОшибки, СтатусСообщения.Важное);
		Если МаскироватьФайловыйКэш Тогда
			ОписаниеОшибки = ОписаниеОшибки + ": " + ИнформацияОбОшибке.Описание
				+ Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
		КонецЕсли; 
		ЗаписьЖурналаРегистрации(СобытиеОшибки, УровеньЖурналаРегистрации.Ошибка, Метаданные.НайтиПоТипу(ТипЗнч(АлгоритмОбъект.Ссылка)),
			АлгоритмОбъект.Ссылка, ОписаниеОшибки);
		Результат = Неопределено;
	КонецПопытки;
	Возврат Результат;

КонецФункции // СоздатьВнешнююОбработкуАлгоритма()

// Проверяет актуальность кэша. Вызывается когда кэш в памяти уже точно не соотвествует объекту БД.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПроверитьАктуальностьКэшаВнешнейОбработки(ЭлементКэша, ДатаИзмененияКэша, ФайлВнешнейОбработки, ДатаИзмененияОбъекта, 
	КэшВнешнейОбработкиАктуален, ФайлВнешнейОбработкиАктуален, ФайловыйКэшДопускаетРедактирование) Экспорт

	Попытка
		ДатаИзмененияФайла = ФайлВнешнейОбработки.ПолучитьВремяИзменения();
		ФайлВнешнейОбработкиСуществует = Истина;
	Исключение
		ФайлВнешнейОбработкиСуществует = Ложь;
	КонецПопытки;
	Если ФайлВнешнейОбработкиСуществует Тогда 
		Если Истина 
			И ЭлементКэша <> Неопределено
			И ЭлементКэша.ДатаИзменения >= ДатаИзмененияФайла
			И ЭлементКэша.ДатаИзменения >= ДатаИзмененияОбъекта
		Тогда
			КэшВнешнейОбработкиАктуален = Истина;
		ИначеЕсли Ложь
			Или (Истина
				И ЭлементКэша = Неопределено
				И ДатаИзмененияФайла = ДатаИзмененияОбъекта)
			Или (Истина 
				И ЭлементКэша <> Неопределено
				И ДатаИзмененияФайла = ЭлементКэша.ДатаИзменения 
				И ДатаИзмененияФайла = ДатаИзмененияОбъекта)
			Или (Истина
				И ФайловыйКэшДопускаетРедактирование
                И (Ложь
					Или (Истина
						И ЭлементКэша = Неопределено
						И ДатаИзмененияФайла >= ДатаИзмененияОбъекта)
					Или (Истина 
						И ЭлементКэша <> Неопределено
						И ДатаИзмененияФайла >= ЭлементКэша.ДатаИзменения 
						И ДатаИзмененияФайла >= ДатаИзмененияОбъекта)))
		Тогда
			ФайлВнешнейОбработкиАктуален = Истина;
			ДатаИзмененияКэша = ДатаИзмененияФайла;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ПроверитьАктуальностьКэшаВнешнейОбработки()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция РазвернутьНовыйШаблонВнешнейОбработки(СМакетом = Ложь, ГлобальныйКлюч = Неопределено,
	ФайлСИменем, ТекстПотокаСИменем, Знач ДляИДВерсииПлатформы = "") Экспорт 

	Если ПустаяСтрока(ДляИДВерсииПлатформы) Тогда
		ДляИДВерсииПлатформы = ИДВерсииПлатформы;
	КонецЕсли; 
	Если ДляИДВерсииПлатформы = "83" Тогда
		ДляИДВерсииПлатформы = "82";
	КонецЕсли; 
	Если ГлобальныйКлюч = Неопределено Тогда
		ГлобальныйКлюч = "" + Новый УникальныйИдентификатор;
	КонецЕсли; 
	лПутьКШаблонуВнешнейОбработки = ПутьККаталогуСлужебныхВременныхФайлов + ГлобальныйКлюч;
	Файл = Новый Файл(ПолучитьИмяВременногоФайла());
	//ПолучитьМакет("ВнешняяОбработка").Записать(Файл.ПолноеИмя);
	Если СМакетом Тогда
		ИмяМакета = "ШаблонВнешнейОбработкиСМакетом";
	Иначе
		ИмяМакета = "ШаблонВнешнейОбработкиСервиса";
	КонецЕсли;
	ИмяМакета = ИмяМакета + ДляИДВерсииПлатформы;
	ПолучитьМакет(ИмяМакета).Записать(Файл.ПолноеИмя);
	ЧтениеZip = Новый ЧтениеZipФайла(Файл.ПолноеИмя);
	ЧтениеZip.ИзвлечьВсе(лПутьКШаблонуВнешнейОбработки);
	ФайлСИменем = Новый Файл(лПутьКШаблонуВнешнейОбработки + "\" + СубПутьКФайлуПотокаЗаголовкаВнешнейОбработки);
	ПотокСИменемОбработки = Новый ТекстовыйДокумент;
	ПотокСИменемОбработки.Прочитать(ФайлСИменем.ПолноеИмя);
	ТекстПотокаСИменем = ПотокСИменемОбработки.ПолучитьТекст();
	СоздатьКомандныйФайлДляУпаковкиФайлаВнешнейОбработки(лПутьКШаблонуВнешнейОбработки);
	
	Возврат лПутьКШаблонуВнешнейОбработки;

КонецФункции // РазвернутьШаблонВнешнейОбработки()

Процедура СоздатьКомандныйФайлДляУпаковкиФайлаВнешнейОбработки(Каталог) Экспорт

	ПолучитьМакет("v8unpack").Записать(Каталог + "\" + ИмяФайлаПакера);
	ПолучитьМакет("Zlib1").Записать(Каталог + "\" + "Zlib1.dll");
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст("
	|FOR /D %%I IN (*.unp) DO " + ИмяФайлаПакера + " -pack    %%I %%~nI
	|FOR    %%I IN (*.und) DO " + ИмяФайлаПакера + " -deflate %%I %%~nI
	|" + ИмяФайлаПакера + " -pack .\ %1");
	ТекстовыйДокумент.Записать(Каталог + "\" + "pack.bat", КодировкаТекста.ANSI);

КонецПроцедуры // СоздатьКомандныйФайлДляУпаковкиФайлаВнешнейОбработки()

Процедура УпаковатьФайлВнешнейОбработки(КаталогРаспаковки, ПолноеИмяФайлаВнешнейОбработки) Экспорт

	СоздатьКомандныйФайлДляУпаковкиФайлаВнешнейОбработки(КаталогРаспаковки);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("pack.bat """ + ПолноеИмяФайлаВнешнейОбработки + """", КаталогРаспаковки);

КонецПроцедуры // УпаковатьФайлВнешнейОбработки()

Процедура РаспаковатьФайлВнешнейОбработки(ПолноеИмяФайла, ПутьРаспаковки) Экспорт 

	//ПроверитьСоздатьФайлЗапаковщика1С();
	ПолучитьМакет("v8unpack").Записать(ПутьРаспаковки + "\" + ИмяФайлаПакера);
	ПолучитьМакет("Zlib1").Записать(ПутьРаспаковки + "\" + "Zlib1.dll");
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст("
	|" + ИмяФайлаПакера + " -unpack  %1 .\
	|FOR %%I IN (*.data) DO " + ИмяФайлаПакера + " -undeflate %%I %%~nI.data.und
	|FOR %%I IN (*.und)  DO " + ИмяФайлаПакера + " -unpack    %%I %%~nI.und.unp
	|");
	ТекстовыйДокумент.Записать(ПутьРаспаковки + "\" + "unpack.bat", КодировкаТекста.ANSI);
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("unpack.bat """ + ПолноеИмяФайла + """", ПутьРаспаковки);

КонецПроцедуры // РаспаковатьВнешнююОбработку()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция СформироватьВнешнююОбработку(ИмяОбработки, ФайлОбработки, ТекстМодуля, ТекстМакета = Неопределено, ДляИДВерсииПлатформы = "") Экспорт

	Если ПустаяСтрока(ДляИДВерсииПлатформы) Тогда
		ДляИДВерсииПлатформы = ИДВерсииПлатформы;
	КонецЕсли; 
	Если ДляИДВерсииПлатформы = "83" Тогда
		ДляИДВерсииПлатформы = "82";
	КонецЕсли; 

	Если ТекстМакета <> Неопределено Тогда
		ШаблонВнешнейОбработкиСМакетом = ШаблоныВнешнейОбработкиСМакетом[ДляИДВерсииПлатформы];
		Если ШаблонВнешнейОбработкиСМакетом = Неопределено Тогда
			ШаблонВнешнейОбработкиСМакетом = Новый Структура("Путь, ФайлСИменем, ФайлЗамок, ТекстПотокаСИменем");
			ШаблонВнешнейОбработкиСМакетом.Путь = РазвернутьНовыйШаблонВнешнейОбработки(Истина,,
				ШаблонВнешнейОбработкиСМакетом.ФайлСИменем, ШаблонВнешнейОбработкиСМакетом.ТекстПотокаСИменем, ДляИДВерсииПлатформы);
			ФайлЗамокШаблонаСМакетом = Новый ЗаписьТекста;
			ФайлЗамокШаблонаСМакетом.Открыть(ШаблонВнешнейОбработкиСМакетом.Путь + ".lck");
			ШаблонВнешнейОбработкиСМакетом.ФайлЗамок = ФайлЗамокШаблонаСМакетом;
			ШаблоныВнешнейОбработкиСМакетом[ДляИДВерсииПлатформы] = ШаблонВнешнейОбработкиСМакетом;
		КонецЕсли;
		ПутьКШаблону = ШаблонВнешнейОбработкиСМакетом.Путь;
		ФайлСИменем = ШаблонВнешнейОбработкиСМакетом.ФайлСИменем;
		ТекстПотокаСИменем = ШаблонВнешнейОбработкиСМакетом.ТекстПотокаСИменем;
	Иначе
		ШаблонВнешнейОбработки = ШаблоныВнешнейОбработки[ДляИДВерсииПлатформы];
		Если ШаблонВнешнейОбработки = Неопределено Тогда
			ШаблонВнешнейОбработки = Новый Структура("Путь, ФайлСИменем, ФайлЗамок, ТекстПотокаСИменем");
			ШаблонВнешнейОбработки.Путь = РазвернутьНовыйШаблонВнешнейОбработки(,,
				ШаблонВнешнейОбработки.ФайлСИменем, ШаблонВнешнейОбработки.ТекстПотокаСИменем, ДляИДВерсииПлатформы);
			ФайлЗамокШаблона = Новый ЗаписьТекста;
			ФайлЗамокШаблона.Открыть(ШаблонВнешнейОбработки.Путь + ".lck");
			ШаблонВнешнейОбработки.ФайлЗамок = ФайлЗамокШаблона;
			ШаблоныВнешнейОбработки[ДляИДВерсииПлатформы] = ШаблонВнешнейОбработки;
		КонецЕсли;
		ПутьКШаблону = ШаблонВнешнейОбработки.Путь;
		ФайлСИменем = ШаблонВнешнейОбработки.ФайлСИменем; 
		ТекстПотокаСИменем = ШаблонВнешнейОбработки.ТекстПотокаСИменем;
	КонецЕсли;
	
	ПутьКШаблону = ПутьКШаблону + "\";
	ПотокСИменемОбработки = Новый ТекстовыйДокумент;
	ПотокСИменемОбработки.УстановитьТекст(СтрЗаменить(ТекстПотокаСИменем, "ИмяВнешнейОбработки", ИмяОбработки));
	ПотокСИменемОбработки.Записать(ФайлСИменем.ПолноеИмя);
	
	ФайлТекстаМодуляОбработки = Новый Файл(ПутьКШаблону + СубПутьКФайлуПотокаМодуляВнешнейОбработки);
	ТекстовыйДокументМодуля = Новый ТекстовыйДокумент();
	ТекстовыйДокументМодуля.УстановитьТекст(ТекстМодуля);
	ТекстовыйДокументМодуля.Записать(ФайлТекстаМодуляОбработки.ПолноеИмя);
	
	Если ТекстМакета <> Неопределено Тогда
		ФайлТекстаМакетаПараметров = Новый Файл(ПутьКШаблону + СубПутьКФайлуПотокаМакетаВнешнейОбработки);
		ТекстовыйДокументМакета = Новый ТекстовыйДокумент();
		ТекстовыйДокументМакета.УстановитьТекст(ТекстМакета);
		ТекстовыйДокументМакета.Записать(ФайлТекстаМакетаПараметров.ПолноеИмя);
	КонецЕсли;
	
	Результат = УпаковатьВнешнююОбработку(ПутьКШаблону, ФайлОбработки.ПолноеИмя);
	Возврат Результат;

КонецФункции // СформироватьВнешнююОбработку()

// Файлы "Zlib1.dll" и "v8unpack.exe" должны быть в этом каталоге.
Функция УпаковатьВнешнююОбработку(ПутьКШаблонуВнешнейОбработки, ИмяВыходногоФайла, СоздатьФайлыУпаковщика = Ложь) Экспорт

	// Небольшой накладной расход, но надежность повышаем
	УдалитьФайлы(ПутьКШаблонуВнешнейОбработки + СубПутьККонтрольномуФайлуВнешнейОбработки);
	Попытка
		УдалитьФайлы(ИмяВыходногоФайла); // @@@.ДОБАВЛЕНИЕ.10/07/19-15:56:28.<2iS>.СтарыхСА
	Исключение
		Событие = "Ошибка создания служебного объекта (1)";
		//Сообщить(Событие, СтатусСообщения.Важное);
		//ЗаписьЖурналаРегистрации(Событие, УровеньЖурналаРегистрации.Ошибка);
		//Возврат Неопределено;
		ВызватьИсключение Событие;
	КонецПопытки;
	
	Если СоздатьФайлыУпаковщика Тогда 
		ПолучитьМакет("v8unpack").Записать(ПутьКШаблонуВнешнейОбработки + ИмяФайлаПакера);
		ПолучитьМакет("Zlib1").Записать(ПутьКШаблонуВнешнейОбработки + "Zlib1.dll");
	КонецЕсли;

	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("pack.bat """ + ИмяВыходногоФайла + """", ПутьКШаблонуВнешнейОбработки);
	
	КонтрольныйФайл1 = Новый Файл(ПутьКШаблонуВнешнейОбработки + СубПутьККонтрольномуФайлуВнешнейОбработки);
	КонтрольныйФайл2 = Новый Файл(ИмяВыходногоФайла);
	Если Ложь
		Или Не КонтрольныйФайл1.Существует() 
		//Или Не КонтрольныйФайл2.Существует()  // Отключил для повышения скорости
	Тогда
		Событие = "Ошибка создания служебного объекта (2)";
		//Сообщить(Событие, СтатусСообщения.Важное);
		//ЗаписьЖурналаРегистрации(Событие, УровеньЖурналаРегистрации.Ошибка);
		//Возврат Неопределено;
		ВызватьИсключение Событие;
	КонецЕсли;
	Возврат Истина;

КонецФункции // УпаковатьВнешнююОбработку()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьФайлВнешнейОбработкиАлгоритма(АлгоритмОбъект) Экспорт 

	Если Ложь
		Или МаскироватьФайловыйКэш
		Или СтрДлина(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя) + СтрДлина(АлгоритмОбъект.Наименование) > 250
	Тогда
		// Ограничение WinAPI на путь к файлу
		КлючСервиса = "" + АлгоритмОбъект.Ссылка.УникальныйИдентификатор();
	Иначе
		КлючСервиса = АлгоритмОбъект.Наименование;
	КонецЕсли; 
	Если МаскироватьФайловыйКэш Тогда
		ИмяФайла = КлючСервиса + ".dat";
	Иначе
		ИмяФайла = КлючСервиса + ".epf";
	КонецЕсли;
	ФайлВнешнейОбработки = Новый Файл(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя + "\" + ИмяФайла);
	Возврат ФайлВнешнейОбработки;

КонецФункции // ПолучитьФайлВнешнейОбработкиАлгоритма()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма(ДескрипторСервиса, ЭлементКэша = Неопределено,
	ДатаИзмененияКэша = Неопределено) Экспорт

	ВнешняяОбработка = Неопределено;
	ФайлВнешнейОбработкиАктуален = Ложь;
	КэшВнешнейОбработкиАктуален = Ложь;
	ФайлВнешнейОбработки = ПолучитьФайлВнешнейОбработкиАлгоритма(ДескрипторСервиса);
	ДатаИзмененияОбъекта = ДескрипторСервиса.ДатаИзмененияКонтекста;
	
	//// Условие добавлено для мягкого перехода на новый кэш параметров сервисов 21.10.2010. Потом нужно убрать
	//Если ЗначениеЗаполнено(ДескрипторСервиса.ДатаИзмененияКэша) Тогда 
		ПроверитьАктуальностьКэшаВнешнейОбработки(ЭлементКэша, ДатаИзмененияКэша, ФайлВнешнейОбработки, ДатаИзмененияОбъекта, 
			КэшВнешнейОбработкиАктуален, ФайлВнешнейОбработкиАктуален, ФайловыйКэшАлгоритмовДопускаетРедактирование);
	//КонецЕсли; 
	Если Истина
		И Не КэшВнешнейОбработкиАктуален
		И Не ФайлВнешнейОбработкиАктуален
	Тогда
		СервисОбъект = ПроверитьПолучитьОбъектСервиса(ДескрипторСервиса); 
		СервисОбъект.СобратьКонтекст();
		СформироватьВнешнююОбработку(СервисОбъект.Наименование, ФайлВнешнейОбработки,
			СервисОбъект.ПолучитьТекстМодуляОбработки()
			//, СервисОбъект.ПолучитьТекстМакетаПараметров()
			);
		Попытка
			ФайлВнешнейОбработки.УстановитьВремяИзменения(СервисОбъект.ДатаИзмененияКонтекста);
		Исключение
			Если Не ФайлВнешнейОбработки.Существует() Тогда
				ПроверитьСистемнуюКодовуюСтраницуОС();
				ВызватьИсключение "Файл внешней обработки сервиса """ + СервисОбъект.Наименование + """ не сформирован";
			Иначе
				ВызватьИсключение;
			КонецЕсли; 
		КонецПопытки;
	КонецЕсли; 
	Если КэшВнешнейОбработкиАктуален Тогда 
		Возврат Неопределено;
	Иначе
		Возврат ФайлВнешнейОбработки;
	КонецЕсли;

КонецФункции // ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма()

Функция ПроверитьСистемнуюКодовуюСтраницуОС() Экспорт
	Локатор = Новый COMОбъект("WbemScripting.SwbemLocator");
	ПространствоИмен1 = Локатор.ConnectServer(, "Root\CIMV2");
	ВыборкаОС = ПространствоИмен1.ExecQuery("Select * from Win32_OperatingSystem");
	Для Каждого ОперационнаяСистема Из ВыборкаОС Цикл
		Прервать;
	КонецЦикла;
	Если ОперационнаяСистема.Locale <> "0419" Тогда
		ВызватьИсключение "Russian system locale (0419) in OS required for this function";
	КонецЕсли; 
КонецФункции

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьВнешнююОбработкуПоАлгоритму(ДескрипторСервиса) Экспорт

	// %%%% Здесь можно было бы структуру попробовать вместо ТЗ
	//ЭлементКэша = 0;
	//КешВнешнихОбработокАлгоритмов.Свойство(ДескрипторСервиса.Наименование, ЭлементКэша);
	ЭлементКэша = ДескрипторСервиса.мСтруктураВнешнейОбработки;
	Если Ложь
		Или ЭлементКэша = Неопределено
		Или ЭлементКэша.ДатаИзменения < ДескрипторСервиса.ДатаИзмененияКонтекста
		Или ФайловыйКэшАлгоритмовДопускаетРедактирование
	Тогда
		ДатаИзмененияКэша = ДескрипторСервиса.ДатаИзмененияКонтекста;
		// Для обхода бага платформы WSHShell.Run(,,True)
		Для Счетчик = 1 По 3 Цикл
			
			ФайлВнешнейОбработки = ПолучитьОбновитьФайлВнешнейОбработкиАлгоритма(ДескрипторСервиса, ЭлементКэша,
				ДатаИзмененияКэша);
			Если ФайлВнешнейОбработки <> Неопределено Тогда
				ВнешняяОбработка = СоздатьВнешнююОбработкуАлгоритма(ДескрипторСервиса, ФайлВнешнейОбработки.ПолноеИмя);
				
				// Для обхода бага платформы.
				Если ВнешняяОбработка <> Неопределено Тогда
					ИмяАлгоритмаВнешнейОбработки = ВнешняяОбработка.Метаданные().Имя;
					Если ИмяАлгоритмаВнешнейОбработки <> ДескрипторСервиса.Наименование Тогда
						ЗаписьЖурналаРегистрации("Несоответствие внешней обработки и сервиса", УровеньЖурналаРегистрации.Ошибка, ,
							ДескрипторСервиса.Ссылка, "Попытка №" + Счетчик + ". Внешняя обработка """ + ИмяАлгоритмаВнешнейОбработки + """");
						УдалитьФайлы(ФайлВнешнейОбработки.ПолноеИмя);
						Продолжить;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Прервать;
		КонецЦикла;
		Если ФайлВнешнейОбработки <> Неопределено Тогда
			Если ЭлементКэша = Неопределено Тогда
				ЭлементКэша = Новый Структура("ДатаИзменения, ВнешняяОбработка");
				//КешВнешнихОбработокАлгоритмов.Вставить(ДескрипторСервиса.Наименование, ЭлементКэша);
				ДескрипторСервиса.мСтруктураВнешнейОбработки = ЭлементКэша;
			КонецЕсли;
			Если ВнешняяОбработка <> Неопределено Тогда
				ЭлементКэша.ДатаИзменения = ДатаИзмененияКэша;
				ЭлементКэша.ВнешняяОбработка = ВнешняяОбработка;
			Иначе
				ЭлементКэша.ДатаИзменения = Дата("00010101");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Если ЭлементКэша <> Неопределено Тогда
		Результат = ЭлементКэша.ВнешняяОбработка;
	Иначе
		Результат = Неопределено;
	КонецЕсли;
	Возврат Результат;

КонецФункции // ПолучитьВнешнююОбработкуПоАлгоритму()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  ИмяФайлаРезультата – Краткое имя файла, в который будет выведен выходной поток, только в текущем каталоге.
//
Процедура ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения(Знач СтрокаЗапуска, ТекущийКаталог = "\.", ИспользоватьWSH = Ложь,
	КраткоеИмяФайлаРезультата = "", ОжидатьЗавершения = Истина) Экспорт 

	#Если Клиент Тогда
	// Баг платформы здесь будет работать. Во время работы данной строки окно продолжает принимать команды! 
	// WSH не использовать при генерации внешних обработок
	Если ИспользоватьWSH Тогда
	#КонецЕсли
		СтарыйТекущийКаталог = WshShell.CurrentDirectory;
		WshShell.CurrentDirectory = ТекущийКаталог;
		СтрокаЗапуска = "cmd.exe /c """ + СтрокаЗапуска + """";
		Если КраткоеИмяФайлаРезультата <> "" Тогда
			СтрокаЗапуска = СтрокаЗапуска + " > " + КраткоеИмяФайлаРезультата;
			СтрокаЗапуска = СтрокаЗапуска + " 2>&1"; //stderr
		КонецЕсли;
		Попытка
			WshShell.Run(СтрокаЗапуска, 0, ОжидатьЗавершения);
		Исключение
			// Для x64 ОС
			СтрокаЗапуска = "%windir%\Sysnative\" + СтрокаЗапуска;
			WshShell.Run(СтрокаЗапуска, 0, ОжидатьЗавершения);
		КонецПопытки;
		WshShell.CurrentDirectory = СтарыйТекущийКаталог;
	#Если Клиент Тогда
	Иначе
		ПолучитьИсполнительСкрытыхКомандСистемы();
		//КонечнаяСтрока = ИсполнительСкрытыхКомандСистемы + " /nowindow /wait /silent /D=""" + ТекущийКаталог + """ " + СтрокаЗапуска;
		КонечнаяСтрока = ИсполнительСкрытыхКомандСистемы + " /nowindow /wait /silent /D=""" + ТекущийКаталог + """ """ + СтрокаЗапуска + """";
		ЗапуститьПриложение(КонечнаяСтрока, , ОжидатьЗавершения);
	КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьПолноеИмяКомпьютераСетиПоЛюбомуИмени(ИмяКомпьютера) Экспорт

	ПолучитьИсполнительСкрытыхКомандСистемы();
	ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
	ЗапуститьСкрытоеПриложениеИДождатьсяЗавершения("nslookup " + ИмяКомпьютера, ФайлРезультата.Путь, Истина, ФайлРезультата.Имя);
	Если Не ФайлРезультата.Существует() Тогда
		ПолноеИмяКомпьютера = "";
	Иначе
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.Прочитать(ФайлРезультата.ПолноеИмя);
		УдалитьФайлы(ФайлРезультата.ПолноеИмя);
		ТекстРезультата = ТекстовыйДокумент.ПолучитьТекст();
		RegExp.IgnoreCase = Истина;
		RegExp.Pattern = "(?:name|имя|╚ь ):\s*([-0-9a-zA-Za-яА-Я]+(\.([-0-9a-zA-Za-яА-Я]+))*)\s*";
		Результат = RegExp.Execute(ТекстРезультата);
		Если Результат.Count > 0 Тогда
			ПолноеИмяКомпьютера = Результат.Item(0).SubMatches(0);
		Иначе
			ПолноеИмяКомпьютера = "";
		КонецЕсли;
	КонецЕсли;
	//ASPDNS = ПолучитьCOMОбъектИзМакета("ASPDNS", "ASPDNS.DNSLookup");
	//IP = ASPDNS.GetIPFromName(ИмяКомпьютера);
	//ПолноеИмяКомпьютера = ASPDNS.GetNameFromIP(IP);
	Возврат ПолноеИмяКомпьютера;

КонецФункции // ПолучитьПолноеИмяКомпьютераСетиПоЛюбомуИмени()

Функция ПолучитьИсполнительСкрытыхКомандСистемы() Экспорт
	
	Если ИсполнительСкрытыхКомандСистемы = Неопределено Тогда
		ДвоичныеДанные = ПолучитьМакет("HiddenStart");
		ИсполнительСкрытыхКомандСистемы = ПолучитьИмяВременногоФайла("exe");
		ДвоичныеДанные.Записать(ИсполнительСкрытыхКомандСистемы);
		ИсполнительСкрытыхКомандСистемы = """" + ИсполнительСкрытыхКомандСистемы + """";
	КонецЕсли;
	Возврат ИсполнительСкрытыхКомандСистемы;
	
КонецФункции

Функция ПолучитьКаталогВерсииПлатформыВПрофиле() Экспорт

	ShellApplication = Новый COMobject("Shell.Application");
	КаталогЛокальныхДанныхПриложений = ShellApplication.NameSpace(28).Self.Path;
	Если ИДВерсииПлатформы > "82" Тогда
		Суффикс = Лев(ИДВерсииПлатформы, 1);
	Иначе
		Суффикс = ИДВерсииПлатформы;
	КонецЕсли; 
	КаталогВерсииПлатформыВПрофиле = КаталогЛокальныхДанныхПриложений + "\1C\1Cv" + Суффикс;
	Возврат КаталогВерсииПлатформыВПрофиле;

КонецФункции

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ПроверитьКаталогФайловогоКэша() Экспорт

	СтрокаСоединения = ирКэш.ПолучитьСтрокуСоединенияСервераЛкс();
	КаталогВерсииПлатформыВПрофиле = ПолучитьКаталогВерсииПлатформыВПрофиле();
	КаталогФайловогоКэша = КаталогВерсииПлатформыВПрофиле + "\" 
		+ ПолучитьИдентификаторИзПредставления(СтрокаСоединения);
	ПапкаФайловогоКэша = Новый Файл(КаталогФайловогоКэша);
	Если Не ПапкаФайловогоКэша.Существует() Тогда
		Попытка
			СоздатьКаталог(ПапкаФайловогоКэша.ПолноеИмя);
			ПробныйФайл = Новый ТекстовыйДокумент;
			ПробныйФайл.Записать(ПапкаФайловогоКэша.ПолноеИмя + "\1.txt");
		Исключение
			Сообщить("Дополнительные кэши отключены.", СтатусСообщения.Важное);
			ВыполнятьАлгоритмыЧерезВнешниеОбработки = Ложь;
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	Если МаскироватьФайловыйКэш Тогда 
		Попытка
			// Пользователь не должен видеть таких сообщений
			ПапкаФайловогоКэша.УстановитьНевидимость(Истина);
		Исключение
		КонецПопытки;
	КонецЕсли;
	Возврат Истина;

КонецФункции // ПроверитьКаталогФайловогоКэша()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИмяНеопределеннойПеременнойИзИнформацииОбОшибке(ИнформацияОбОшибке, СообщитьНеобрабатываемуюОшибку = Ложь) Экспорт

	Если ИнформацияОбОшибке <> Неопределено Тогда
		RegExp.Global = Ложь;
		//ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Пока ИнформацияОбОшибке.Причина <> Неопределено Цикл // Добавлено 26.07.2011 из-за доработки синтаксического контроля в COM сеансе
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
		ОписаниеОшибки = ИнформацияОбОшибке.Описание;
		
		RegExp.Pattern = "(?:Переменная не определена |Variable is not defined )\(([_0-9" + шБуква + "]+)\)";
		Результат = RegExp.Execute(ОписаниеОшибки);
		Если Результат.Count > 0 Тогда 
			ИмяПеременнойРезультата = Результат.Item(0).SubMatches(0);
		Иначе
			Если СообщитьНеобрабатываемуюОшибку Тогда
				Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке), СтатусСообщения.Важное);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	Возврат ИмяПеременнойРезультата;

КонецФункции // ПолучитьИмяНеопределеннойПеременнойИзИнформацииОбОшибке()

#Если Клиент Или ВнешнееСоединение Тогда

// Выполняет алгоритм по ссылке.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ВыполнитьАлгоритм(СсылкаАлгоритма, СтруктураПараметров = Неопределено) Экспорт 

	Если СтруктураПараметров = Неопределено Тогда
		СтруктураПараметров = Новый Структура;
	КонецЕсли;
	Результат = Ложь;
	АлгоритмОбъект = Неопределено;
	Если Не КешАлгоритмов.Свойство(СсылкаАлгоритма, АлгоритмОбъект) Тогда
		АлгоритмОбъект = СсылкаАлгоритма.ПолучитьОбъект();
		КешАлгоритмов.Вставить(СсылкаАлгоритма, АлгоритмОбъект);
	КонецЕсли;
	ВыполнитьМетодАлгоритма(АлгоритмОбъект, 1, СтруктураПараметров);

КонецФункции // ВыполнитьАлгоритм()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ОчиститьКешАлгоритмов(ОчиститьКэшНаДиске = Ложь) Экспорт 

	КешАлгоритмов.Очистить();
	//КешВнешнихОбработокАлгоритмов.Очистить();
	Если ОчиститьКэшНаДиске Тогда 
		//Для Каждого ЭлементПодкаталога Из СтруктураПодкаталоговФайловогоКэша Цикл
		//	УдалитьФайлы(ЭлементПодкаталога.Значение.ПолноеИмя, "*.dat");
		//	УдалитьФайлы(ЭлементПодкаталога.Значение.ПолноеИмя, "*.epf");
		//КонецЦикла;
		
		ФайлПодкаталога = СтруктураПодкаталоговФайловогоКэша["a"];
		УдалитьФайлы(ФайлПодкаталога.ПолноеИмя + "\", "*.*");
		ПроверитьСтруктуруФайловогоКэша();
	КонецЕсли;

КонецПроцедуры // ОчиститьКешАлгоритмов()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура ОбновитьАлгоритмВКеше(АлгоритмОбъект) Экспорт 

	КешАлгоритмов.Вставить(АлгоритмОбъект.Ссылка, АлгоритмОбъект);

КонецПроцедуры // УдалитьАлгоритмИзКеша()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Процедура _ПроверитьСоздатьФайлЗапаковщика1С(БыстраяПроверка = Ложь) Экспорт 

	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлЗапаковщика1С = Неопределено
	Тогда
		Если МаскироватьФайловыйКэш Тогда
			// Получено из обычного УИД 594c2002-1f44-11dd-851a-000423af726e путем замены "-" в середине на "0"
			ИмяФайла = "594c2002-1f44-11dd0851a-000423af726e.exe";
		Иначе
			ИмяФайла = "V8unpack.exe";
		КонецЕсли;
		ФайлЗапаковщика1С = Новый Файл(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя + "\" + ИмяФайла);
		Если Не ФайлЗапаковщика1С.Существует() Тогда
			ДанныеМакета = ПолучитьМакет("v8unpack");
			ЗаписатьМакетСУчетомМаскировки(ДанныеМакета, ФайлЗапаковщика1С.ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлБиблиотекиЗапаковщика = Неопределено
	Тогда
		ФайлБиблиотекиЗапаковщика = Новый Файл(ПапкаКешаВнешнихОбработокАлгоритмов.ПолноеИмя + "\Zlib1.dll");
		Если Не ФайлБиблиотекиЗапаковщика.Существует() Тогда
			ДанныеМакета = ПолучитьМакет("Zlib1");
			ЗаписатьМакетСУчетомМаскировки(ДанныеМакета, ФайлБиблиотекиЗапаковщика.ПолноеИмя);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ПроверитьСоздатьФайлЗапаковщика1С()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьФайлОткрывателя1С(БыстраяПроверка = Ложь) Экспорт 

	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлОткрывателя1С = Неопределено
	Тогда
		ФайлОткрывателя1С = Новый Файл(ПолучитьИмяВременногоФайла("exe"));
		ПолучитьМакет("OpenIn1Cv8").Записать(ФайлОткрывателя1С.ПолноеИмя);
	КонецЕсли;
	Возврат ФайлОткрывателя1С;

КонецФункции // ПолучитьФайлОткрывателя1С()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьФайлРаспаковщикаZIP(БыстраяПроверка = Ложь) Экспорт 

	Если Ложь
		Или Не БыстраяПроверка
		Или ФайлРаспаковщикаZIP = Неопределено
	Тогда
		ФайлРаспаковщикаZIP = Новый Файл(ПолучитьИмяВременногоФайла("exe"));
		ПолучитьМакет("unzip").Записать(ФайлРаспаковщикаZIP.ПолноеИмя);
	КонецЕсли;
	Возврат ФайлРаспаковщикаZIP;

КонецФункции // ПолучитьФайлРаспаковщикаZIP()

// Получает из длинного пути к файлу короткий в формате DOS (8.3) 
//
// Параметры:
//  ПолноеИмяФайла – Строка;
//
// Возвращаемое значение:
//  Строка;
//
Функция ПолучитьИмяФайлаВФорматеDOS(ПолноеИмяФайла) Экспорт
	
	Если VBScript = Неопределено Тогда
		VBScript = Новый COMОбъект("MSScriptControl.ScriptControl");
		VBScript.language = "vbscript";
	КонецЕсли;
	VBScript.addcode("
	|Public Function GetShortPath()
	|Set fso = CreateObject(""scripting.filesystemobject"")
	|Set fsoFile = fso.GetFile(""" + ПолноеИмяФайла + """)
	|GetShortPath = fsoFile.ShortPath
	|End Function
	|");
	DOSИмя = VBScript.Run("GetShortPath");
	Возврат DOSИмя;
	
КонецФункции

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Процедура ЗаписатьМакетСУчетомМаскировки(ДанныеМакета, ПолноеИмя)

	Если МаскироватьФайловыйКэш Тогда
		Попытка
			ДанныеМакета.Записать(ПолноеИмя);
		Исключение
		КонецПопытки;
	Иначе
		ДанныеМакета.Записать(ПолноеИмя);
	КонецЕсли; 

КонецПроцедуры // ЗаписатьМакетСУчетомМаскировки()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура УдалитьСлужебныеФайлы() Экспорт
	
	СтруктураЦикла = Новый Массив;
	СтруктураЦикла.Добавить(ШаблоныВнешнейОбработки);
	СтруктураЦикла.Добавить(ШаблоныВнешнейОбработкиСМакетом);
	Для Каждого ЭлементЦикла Из СтруктураЦикла Цикл
		Для Каждого КлючИЗначение Из ЭлементЦикла Цикл
			ШаблонВнешнейОбработки = КлючИЗначение.Значение;
			Если ШаблонВнешнейОбработки.ФайлЗамок <> Неопределено Тогда
				ШаблонВнешнейОбработки.ФайлЗамок.Закрыть();
				Попытка
					УдалитьФайлы(ШаблонВнешнейОбработки.Путь + ".lck");
					УдалитьФайлы(ШаблонВнешнейОбработки.Путь);
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЦикла; 
	КонецЦикла;

КонецПроцедуры // УдалитьСлужебныеФайлы()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция мПолучитьПредставлениеПустогоЗначения(ПустоеЗначение) Экспорт

	Если ПустоеЗначение = Неопределено Тогда
		Результат = "<Неопределено>";
	Иначе
		Результат = мКэшПустыхЗначений[ПустоеЗначение];
		Если Результат = Неопределено Тогда
			Если ПустоеЗначение = Null Тогда
				Результат = "<Null>";
			ИначеЕсли ПустоеЗначение = "" Тогда
				Результат = "<Пустая строка>";
			ИначеЕсли ПустоеЗначение = 0 Тогда
				Результат = "<Пустое число>";
			ИначеЕсли ПустоеЗначение = Дата("00010101") Тогда
				Результат = "<Пустая дата>";
			Иначе 
				ОбъектМД = ирОбщий.ПолучитьМетаданныеЛкс(ПустоеЗначение);
				Если ОбъектМД <> Неопределено Тогда
					Результат = "<" + ОбъектМД.ПолноеИмя() + ".ПустаяСсылка>";
				КонецЕсли;
			КонецЕсли; 
			мКэшПустыхЗначений[ПустоеЗначение] = Результат;
		КонецЕсли;
	КонецЕсли; 
	Возврат Результат;

КонецФункции // ПолучитьПредставлениеПустогоЗначения()

// Получает уникальную строку, подходящую для именования элемента структуры.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьНовоеУникальноеИмя() Экспорт

	Результат = "_" + ПолучитьИдентификаторИзПредставления(Новый УникальныйИдентификатор);
	Возврат Результат;

КонецФункции // ПолучитьНовоеУникальноеИмя()

// Возвращает текущее время в миллисекундах.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Число.
//
Функция ПолучитьТекущееВремяВМиллисекундах() Экспорт
	
	Возврат WinAPI.timeGetTime();
	
	//Если ВремяОбъект = Неопределено Тогда
		Если JavaScript = Неопределено Тогда
			Попытка
		    	JavaScript = Новый COMОбъект("MSScriptControl.ScriptControl");
			Исключение
				Сообщить(ОписаниеОшибки(), СтатусСообщения.Внимание);
				Возврат 0;
			КонецПопытки;
		    JavaScript.Language = "javascript";
		КонецЕсли;
	//	ВремяОбъект = JavaScript.Eval("new Date()");
	//КонецЕсли;
	//Время = ВремяОбъект.getTime();
	Время = JavaScript.Eval("new Date().getTime()");
    Возврат Время;
	
КонецФункции

Функция ПолучитьКартинкуТипа()
	
	Если КартинкиТипов = Неопределено Тогда
		КартинкиТипов = Новый ТаблицаЗначений;
		
	КонецЕсли; 
	
КонецФункции

#КонецЕсли

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПолучитьИДВерсииПлатформы(СистемнаяИнформация = Неопределено) Экспорт

	Если СистемнаяИнформация = Неопределено Тогда
		СистемнаяИнформация = Новый СистемнаяИнформация;
	КонецЕсли;
	МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(СистемнаяИнформация.ВерсияПриложения);
	//ВерсияПлатформы = Число(МассивФрагментов[0]) * 1000 * 1000 + Число(МассивФрагментов[1]) * 1000 + Число(МассивФрагментов[2]);
	Результат = МассивФрагментов[0] + МассивФрагментов[1];
	Возврат Результат;

КонецФункции // ПолучитьИДВерсииПлатформы()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПроверитьПолучитьОбъектСервиса(Знач АлгоритмОбъект) Экспорт

	Если ТипЗнч(АлгоритмОбъект) = Тип("СтрокаТаблицыЗначений") Тогда
		лОбъект = АлгоритмОбъект.ЭтотОбъект;
		Если лОбъект = Неопределено Тогда
			лОбъект = АлгоритмОбъект.Ссылка.ПолучитьОбъект();
			ЗаполнитьЗначенияСвойств(лОбъект, АлгоритмОбъект, , "ЭтотОбъект, Ссылка, мПолнаяТаблицаПараметров"); ////%!%
			АлгоритмОбъект.ЭтотОбъект = лОбъект;
		КонецЕсли; 
		АлгоритмОбъект = лОбъект;
	КонецЕсли; 
	Возврат АлгоритмОбъект;

КонецФункции // ПроверитьПолучитьОбъектСервиса()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
// Возвращаемое значение:
//               – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>;
//  <Значение2>  – <Тип.Вид> – <описание значения>
//                 <продолжение описания значения>.
//
Функция ПредставлениеИнформацииОбОшибке(Знач ИнформацияОбОшибке) Экспорт 

	// Антибаг платформы. В описании повторяется причина и описание между уровнями. В общем бардак.
	ОписаниеОшибки = ИнформацияОбОшибке.Описание;
	Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
		Пока Истина
			И ИнформацияОбОшибке.Причина <> Неопределено 
			И ИнформацияОбОшибке.Описание = ОписаниеОшибки
		Цикл
			ИнформацияОбОшибке = ИнформацияОбОшибке.Причина;
		КонецЦикла;
		Если ИнформацияОбОшибке.Описание <> ОписаниеОшибки Тогда
			ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ПредставлениеИнформацииОбОшибке(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Фрагмент = ирОбщий.ПолучитьПоследнийФрагментЛкс(ОписаниеОшибки, "по причине:" + Символы.ПС);
		Позиция = Найти(ОписаниеОшибки, Фрагмент + Символы.ПС + "по причине:" + Символы.ПС + Фрагмент);
		Если Позиция > 0 Тогда
			ОписаниеОшибки = Лев(ОписаниеОшибки, Позиция) + Фрагмент;
		КонецЕсли;
	КонецЕсли;
	Возврат ОписаниеОшибки;

КонецФункции // ПредставлениеИнформацииОбОшибке()

// <Описание функции>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ОбработатьВнешнееИсключениеАлгоритма(ДескрипторСервиса, ИнформацияОбОшибке, РежимВыполнения, Интерактивно = Истина) Экспорт 

	//СервисОбъект = ПроверитьПолучитьОбъектСервиса(ДескрипторСервиса); 
	// Такой прием применен для избежания обращения к БД внутри сломанной транзакции
	Если ТипЗнч(ДескрипторСервиса) = Тип("СтрокаТаблицыЗначений") Тогда
		лОбъект = ДескрипторСервиса.ЭтотОбъект;
		Если лОбъект = Неопределено Тогда
			//лОбъект = Справочники.Сервисы2iS.СоздатьЭлемент();
			//ЗаполнитьЗначенияСвойств(лОбъект, ДескрипторСервиса, , "ЭтотОбъект, Ссылка, КэшПараметров"); 
			лОбъект = Новый ("СправочникОбъект.Сервисы2iS");
			ЗаполнитьЗначенияСвойств(лОбъект, ДескрипторСервиса, "мЗначенияПоУмолчанию, мВнешниеПараметры, мВнутренниеПараметры"); 
		КонецЕсли; 
		СервисОбъект = лОбъект;
	Иначе
		СервисОбъект = ДескрипторСервиса;
	КонецЕсли; 
	
	Если РежимВыполнения = 3 Тогда
		Смещение = СервисОбъект.ПолучитьСтартовуюСтрокуАлгоритмаВРежиме2();
		ИмяМодуляСервиса = "";
	ИначеЕсли РежимВыполнения = 2 Тогда
		Смещение = СервисОбъект.ПолучитьСтартовуюСтрокуАлгоритмаВТексте();
		ИмяМодуляСервиса = "";
	ИначеЕсли Ложь
		Или РежимВыполнения = 1
		Или РежимВыполнения = 0
	Тогда 
		Смещение = СервисОбъект.ПолучитьСтартовуюСтрокуМетодаВМодуле();
		ИмяМодуляСервиса = "ВнешняяОбработка." + ДескрипторСервиса.Наименование;
		Если Ложь
			Или ИДВерсииПлатформы = "82"
			Или ИДВерсииПлатформы = "83"
		Тогда
			ИмяМодуляСервиса = ИмяМодуляСервиса + ".МодульОбъекта";
		КонецЕсли;
	КонецЕсли;
	ПрефиксСервиса = "Сервис ";
	Если ИмяМодуляСервиса = ИнформацияОбОшибке.ИмяМодуля Тогда
		НомерСтрокиАлгоритма = ИнформацияОбОшибке.НомерСтроки;
		НомерСтрокиАлгоритма = НомерСтрокиАлгоритма - Смещение;
		ОписаниеОшибки = ПрефиксСервиса + """" + ДескрипторСервиса.Наименование + """[" + РежимВыполнения + "]{" 
			+ НомерСтрокиАлгоритма + "}:" + Символы.ПС + "==========================================================================" + Символы.ПС
			+ ИнформацияОбОшибке.Описание + Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
	Иначе
		ОписаниеОшибки = ПрефиксСервиса + """" + ДескрипторСервиса.Наименование + """[" + РежимВыполнения + "]";
		МаркерСлужебногоИсключения = "ВызватьИсключение Ошибка;//#Служебное";
		Если Найти(ИнформацияОбОшибке.ИсходнаяСтрока, МаркерСлужебногоИсключения) = 0 Тогда
			ОписаниеОшибки = ОписаниеОшибки + "{" + ИнформацияОбОшибке.ИмяМодуля + "(" + ИнформацияОбОшибке.НомерСтроки + ")}: ";
		КонецЕсли; 
		ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ИнформацияОбОшибке.Описание;
		Если Найти(ИнформацияОбОшибке.ИсходнаяСтрока, МаркерСлужебногоИсключения) = 0 Тогда
			ОписаниеОшибки = ОписаниеОшибки + Символы.ПС + ИнформацияОбОшибке.ИсходнаяСтрока;
		КонецЕсли;
	КонецЕсли;
	Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
		ОписаниеОшибки = ОписаниеОшибки + "
		|" + ПредставлениеИнформацииОбОшибке(ИнформацияОбОшибке.Причина);
	КонецЕсли;
	
	#Если Клиент Тогда
		Если Интерактивно Тогда
			Если РольДоступна("ирРазработчик") Тогда
				Если ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов Тогда
					Если Истина
						И ОтложенноеОткрытиеИсточникаОшибки.Количество() > 0
						И ОтложенноеОткрытиеИсточникаОшибки[0].АлгоритмОбъект = Неопределено // СтопСтрока
					Тогда
						// Не подключаем отложенное открытие, т.к. уже внутри него. Случается при ПолученииДанных
					Иначе
						СтрокаИсточникаОшибки = ОтложенноеОткрытиеИсточникаОшибки.Добавить();
						СтрокаИсточникаОшибки.АлгоритмОбъект = ДескрипторСервиса.Ссылка;
						СтрокаИсточникаОшибки.ИнформацияОбОшибке = ИнформацияОбОшибке;
						СтрокаИсточникаОшибки.РежимВыполнения = РежимВыполнения;
						СтрокаИсточникаОшибки.Смещение = Смещение;
						ПодключитьОбработчикОжидания("ОтложенноеОткрытиеИсточникаОшибки", 0.1, Истина);
					КонецЕсли;
					//Возврат Символы.ПС + ОписаниеОшибки;
				КонецЕсли;
			КонецЕсли;
			Если Не РольДоступна("ирРазработчик") Тогда
				Если ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов Тогда 
					Сообщить(ОписаниеОшибки, СтатусСообщения.Важное);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли; 
	#КонецЕсли
	Возврат ОписаниеОшибки;

КонецФункции // ОбработатьВнешнееИсключениеАлгоритма()

// Выполняет алгоритм по объекту.
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ВыполнитьМетодАлгоритма(ДескрипторСервиса, Режим, П0 = Null, П1 = Null, П2 = Null, П3 = Null, П4 = Null,
	П5 = Null, П6 = Null, П7 = Null, П8 = Null, П9 = Null) Экспорт 

	//#Если Клиент Тогда
	Если ВыполнятьАлгоритмыЧерезВнешниеОбработки Тогда
		Если Ложь
			Или ВнешняяОбработкаСервисы = Неопределено
			Или ДескрипторСервиса.ИндивидуальнаяВнешняяОбработка
		Тогда
			ВнешняяОбработкаАлгоритма = ПолучитьВнешнююОбработкуПоАлгоритму(ДескрипторСервиса);
			//Иначе
			//	ВнешняяОбработкаАлгоритма = ДескрипторСервиса.мСтруктураВнешнейОбработки;
			//	Если ВнешняяОбработкаАлгоритма = Неопределено Тогда 
			//		ВнешняяОбработкаАлгоритма = ВнешняяОбработкаСервисы.ПолучитьФорму(ДескрипторСервиса.Наименование);
			//		ДескрипторСервиса.мСтруктураВнешнейОбработки = ВнешняяОбработкаАлгоритма;
			//	КонецЕсли;
			//КонецЕсли;
			Если ВнешняяОбработкаАлгоритма <> Неопределено Тогда
				Если ФиксироватьВнешниеИсключенияАлгоритмов Тогда
					Попытка
						Результат = ВнешняяОбработкаАлгоритма.мМетод(ДескрипторСервиса, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
					Исключение
						ИнформацияОбОшибке = ИнформацияОбОшибке();
						Ошибка = ОбработатьВнешнееИсключениеАлгоритма(ДескрипторСервиса, ИнформацияОбОшибке, 0);
						ВызватьИсключение Ошибка;//#Служебное
					КонецПопытки;
				Иначе
					Результат = ВнешняяОбработкаАлгоритма.мМетод(ДескрипторСервиса, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
				КонецЕсли;
			Иначе
				//Сообщить("Ошибка компиляции сервиса """ + ДескрипторСервиса.Наименование + """. Сервис не выполнен.", СтатусСообщения.Внимание);
				ВызватьИсключение "Ошибка компиляции сервиса """ + ДескрипторСервиса.Наименование + """";
			КонецЕсли;
		Иначе
			// Прямые вызовы
			Если ФиксироватьВнешниеИсключенияАлгоритмов Тогда
				Попытка
					Результат = Вычислить("ВнешняяОбработкаСервисы._" + ДескрипторСервиса.Наименование 
						+ "(ДескрипторСервиса, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9)");
				Исключение
					ИнформацияОбОшибке = ИнформацияОбОшибке();
					Ошибка = ОбработатьВнешнееИсключениеАлгоритма(ДескрипторСервиса, ИнформацияОбОшибке, 0);
					ВызватьИсключение Ошибка;//#Служебное
				КонецПопытки;
			Иначе
				Результат = Вычислить("ВнешняяОбработкаСервисы._" + ДескрипторСервиса.Наименование 
					+ "(ДескрипторСервиса, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9)");
			КонецЕсли;
		КонецЕсли;
	Иначе
	//#КонецЕсли
		//#Если Не Клиент И Не ВнешнееСоединение Тогда
		//ДескрипторСервиса.ирПлатформа = ЭтотОбъект;
		//#КонецЕсли
		СервисОбъект = ПроверитьПолучитьОбъектСервиса(ДескрипторСервиса);
		ТекстАлгоритмаСПараметрами = СервисОбъект.ПолучитьТелоМетода();
		Если ФиксироватьВнешниеИсключенияАлгоритмов Тогда
			Попытка
				Результат = ирОбщий.ВыполнитьАлгоритм(ТекстАлгоритмаСПараметрами, СервисОбъект, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
			Исключение
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				Ошибка = ОбработатьВнешнееИсключениеАлгоритма(СервисОбъект, ИнформацияОбОшибке, 2);
				ВызватьИсключение Ошибка;//#Служебное
			КонецПопытки;
		Иначе
			Результат = ирОбщий.ВыполнитьАлгоритм(ТекстАлгоритмаСПараметрами, СервисОбъект, Режим, П0, П1, П2, П3, П4, П5, П6, П7, П8, П9);
		КонецЕсли;
	//#Если Клиент Тогда
	КонецЕсли;
	//#КонецЕсли

	Возврат Результат;

КонецФункции // ВыполнитьМетодАлгоритма()

// Получает новый экземпляр ком-объекта парсера.
//
// Параметры:
//  Нет.
//
// Возвращаемое значение:
//  Com-объект, Неопределено.
//
Функция ПолучитьWinAPI() Экспорт

	Если WinAPI = "НеИнициализирован" Тогда
		#Если Клиент Или ВнешнееСоединение Тогда
		WinAPI = ПолучитьCOMОбъектИзМакета("DynamicWrapperX", "DynamicWrapperX");
		#Иначе
		// На сервере вызывало зависание. Пришлось отключить
		WinAPI = Неопределено;
		#КонецЕсли 
		Если WinAPI <> Неопределено Тогда
			WinAPI.Register( "KERNEL32.DLL","Sleep","i=h","f=s");
			//WinAPI.Register( "KERNEL32.DLL","GetTickCount64","r=l","f=s"); // обычный DynamicWrapper на x86 подключает, а этот - нет
			WinAPI.Register( "KERNEL32.DLL","GetTickCount","r=l","f=s");
			WinAPI.Register( "KERNEL32.DLL","GetProcessId","i=l","r=l","f=s");
			WinAPI.Register( "KERNEL32.DLL","GetCurrentProcessId","r=l","f=s");
			WinAPI.Register( "WINMM.DLL", "timeGetTime",            "r=l", "f=s");
			WinAPI.Register( "WINMM.DLL", "timeBeginPeriod", "i=l", "r=l", "f=s");
			WinAPI.Register( "WINMM.DLL", "timeEndPeriod",   "i=l", "r=l", "f=s");
		Иначе
			#Если Клиент Тогда
			// Под пользователем ОС без админиских прав сразу после установки через regsvr32 /i компонента не создается почему то.
			// Нужно перезапускать приложение.
			Предупреждение("Установлена новая компонента. Сеанс будет перезапущен", 5);
			ПрекратитьРаботуСистемы(Истина);
			#Иначе
			//ВызватьИсключение "Не удалось подключить компоненту расширения платформы";
			#КонецЕсли 
		КонецЕсли;
	КонецЕсли;
	Возврат WinAPI;

КонецФункции // ПолучитьWinAPI()

Функция ПолучитьНовыйВычислительРегулярныхВыражений(VBScript = Истина) Экспорт
	
	Если VBScript Тогда
		Результат = Новый COMОбъект("VBScript.RegExp");
	Иначе
		Результат = ПолучитьОбъектВнешнейКомпонентыИзМакета("V8RegEx", "V8RegEx");
	КонецЕсли; 
	Результат.IgnoreCase = Истина;
	Возврат Результат;
	
КонецФункции

Функция ПолучитьИмяТипаCOMVariant(Член) Экспорт
	
	ТекстМодуля = "
	|Function getMemberReturn( member )
	|  Dim ret
	|    On Error Resume Next
	|    If member.ReturnType Is Nothing Then
	|        ret = """"
	|    ElseIf Not IsEmpty(member.ReturnType.TypedVariant) Then
	|		 ff = member.ReturnType.TypedVariant
	|		 ff.VariantInit()
	|        ret = ff.Name
	|    ElseIf Not member.ReturnType.TypeInfo Is Nothing Then
	|        ret = member.ReturnType.TypeInfo.Name
	|    Else
	|        ret = """"
	|    End If
	|    getMemberReturn = ret
	|End Function";
	ScrptCtrl = Новый COMОбъект("MSScriptControl.ScriptControl");
	ScrptCtrl.Language = "vbscript";
	Попытка
		ScrptCtrl.AddCode(ТекстМодуля);
	Исключение
		Сообщить(ScrptCtrl.Error.Description);
		Сообщить(ScrptCtrl.Error.Source);
		Сообщить(ScrptCtrl.Error.Text);
		Сообщить(ScrptCtrl.Error.Line);
	КонецПопытки;
	Результат = ScrptCtrl.Run("getMemberReturn", Член);
	Возврат Результат;
	
КонецФункции

#Если Клиент Тогда
	
///////////////////////////////////////////////////////////////////
// Информатор. Начало http://www.1cpp.ru/forum/YaBB.pl?num=1313560540/105

Функция Public_Consts()
	
	ТекстМодуля = "	 
		|Public Const S_OK						= &h0
		|Public Const E_NOINTERFACE  			= &h80004002
		|Public Const CP_ACP					= &h0
		|
		|Public Const HEAP_ZERO_MEMORY 			= &h00000008
		|Public Const PAGE_EXECUTE_READWRITE	= &h40
		|Public Const PAGE_EXECUTE_READ         = &h20
		|
		|Public Const VT_BSTR					= &h8
		|Public Const VT_DISPATCH				= &h9
		|
		|'IID Интерфейсов
		|Public Const IID_IContextExtImpBase 	= ""{FD7B6CC2-DC8E-11D2-B8D0-008048DA0335}""
		|Public Const IID_IValueImplBase	 	= ""{FD7B6CC3-DC8E-11D2-B8D0-008048DA0335}""
		|Public Const IID_GC					= ""{F7399BD5-100E-4D0A-A5CE-F97810ACFEE9}""
		|
		|Public Const platform_offset			= &h18	
		|";
		
	СисИнфо 	= Новый СистемнаяИнформация;	
	ВерсияDLL 	= СтрЗаменить(Лев(СисИнфо.ВерсияПриложения, 4), ".", "");
	ТекстМодуля = ТекстМодуля + "	 	
		|Public Const dllName					= """ + КаталогПрограммы() + "core" + ВерсияDLL + """ 
		|";
		
	
	Возврат ТекстМодуля;
КонецФункции

Функция Public_Vars()
	ТекстМодуля = "	 
		|Public oServ	
		|
		|Public	Wrap
		|Public curVers			'Версия сборки 8.X
		|Public VersPlatform	'Версия 8.X
		|
		|Set Wrap = CreateObject("""+ИМЯ_КЛАССА_DynamicWrapperX+""")
		|
		|Public bsl_off_13
		|";
			//|Set Wrap = CreateObject(""DynamicWrapperX"")
		
	Возврат ТекстМодуля;	
КонецФункции

Функция Class_Service()
	ТекстМодуля = "
//{		|Class	Service
		|Class	Service
//{		|Vars
		|	Private hHeap
		|	Public	buf				'Буфер для вызова функций
		|	Private	buf_thiscall	'Буфер для вызова функций
		|
		//|	Private res				'Память для результата VirtualProtect
		|	Private	pGC				'Глоб.объект
		|	Public	ppv				
		|	Private pIID
		|	Private swIID
		|	Private handle
		|
		|	Public	numGK				'Кол-во ГК контекстов
		|	Public	pArray			'Массив ГК
		|
		|	'Для передачи параметров
		|	Public paramArr2		'Для печати
		|	Public paramArr9		'Для вызова функций
		|
		|	Private pMes			'Контекст, с методом /Сообщить/
		|	Private numMes			'Номер метода /Сообщить/
		|
		|	Private adrValue_str	'адрес ф-и	__thiscall core::Value::Value(wchar_t const *)
		|	Private adrValue_void   'адрес ф-и	__thiscall core::Value::Value(void)
		|
		|	Private Ref
		|	Private oldFunc
		|	Private newFunc
//}		|
//{		|Release
        |	Private Function Release(pObj)
		|		vfunc pObj, (3 - 1) * 4
		|       res	= Wrap.IUnknown_Release(pObj)
		|	End Function
//}		|
//{		|FindCG_Message
		|	Private Function FindCG_Message()
		|		FindCG_Message = -1
		|		
		|		'Найдем контекст, в котором есть метод ""Сообщить""
		|		 j = 0
		|		PutString(""Сообщить"")
		|		Do While j < numGK + 1
		|			pIContext = Wrap.NumGet(pArray, j * 4)
		|	
		|			vfunc pIContext, 4 * (16 - 1)
		|			numMes = Wrap.ImplBase_findMethod(pIContext, ppv)
		|			If numMes =>0 Then
		|				FindCG_Message = pIContext
		|				Exit Do
		|			End If
		|			 j =  j + 1
		|		Loop
		|       '=======================================================
		|	End Function
//}		|
//{		|GetArrayGC	
		|	Private Function GetArrayGC()
		|		IIDFromString IID_GC
		|
		|		'ГО (1)
		|		vfunc pGC, (15 - 1) * 4
		|		pObj1 = Wrap.GetObjectFromIID(pGC, pIID)
		|
		|		If VersPlatform = 82 Then
		|			vfunc pObj1, (13 - 1) * 4
		|			res	= Wrap.GetObj(pObj1, ppv)
		|			pObj2 	= Wrap.NumGet(ppv)
		|			Select Case curVers
		|				Case 13
		|               	numfunc = 68
		|				Case 14
		|					numfunc = 69
		|				Case 15
		|					numfunc = 70
		|				Case Else
		|           		numfunc = 70
		|			End Select
		|		ElseIf VersPlatform = 83 Then
		|			vfunc pObj1, (13 - 1) * 4
		|			res		= Wrap.GetObj2(pObj1)
		|			pObj2 	= res
		|			Select Case Cint(Left(curVers, 1))
		|				Case 1
		|					numfunc = 71
		|				Case Else
		|					numfunc = 74
		|			End Select
		|		End If
		|
		|		'ГО (3)
		|		vfunc pObj2, (numfunc - 1) * 4
		|		res1 = Wrap.GetObj(pObj2, ppv)	
		|		pObj3 = Wrap.NumGet(ppv)
		//|		MsgBox ""vt_pObj3 	= "" & Hex(Wrap.NumGet(pObj3)) 
		|
		|		off_array = &h10
		|		If VersPlatform = 82 Then
		|			Select Case curVers
		|				Case 13
		|				Case 14
		|				Case 15
		|				Case 16
		|				Case 17
		|				Case Else
		|           		off_array = &h24
		|			End Select
		|		ElseIf VersPlatform = 83 Then
		|			Select Case curVers
		|				Case 1
		|				Case Else
		|           		off_array = &h24
		|			End Select
		|		End If
		|
		|		'Массив
		|		GetArrayGC = Wrap.NumGet(pObj3, off_array)
		//|		MsgBox   Hex(GetArrayGC)
		|
		|		'Количество
		|		numGK = (Wrap.NumGet(pObj3, off_array + 4) - GetArrayGC) / 4
		|		numGK = numGK - 1
		|	
		|
		|		Release pObj3
		|		If VersPlatform = 82 Then
		|			Release pObj2
		|		End If
		|		Release pObj1
		|		Release pGC
		|	End Function
//}		|
//{		|Class_Initialize
		|	Private Sub Class_Initialize
		|		Wrap.Register ""Kernel32"",	""HeapAlloc"",	""i=lll"",	""r=l""
	    |		Wrap.Register ""Kernel32"",	""GetProcessHeap"", ""r=l""
	    |		Wrap.Register ""Kernel32"",	""HeapFree"", ""i=lll"",""r=l""
		|		Wrap.Register ""Kernel32"",	""VirtualProtect"" , ""i=lllp"", ""r=l""
		|		Wrap.Register ""Kernel32"", ""LoadLibrary"" , ""i=s"", ""r=h""
		|		Wrap.Register ""Kernel32"", ""GetProcAddress"" , ""i=hs"", ""r=u""
		|		Wrap.Register ""Kernel32"", ""MultiByteToWideChar"", ""i=llslpl"", ""r=l""
		|		Wrap.Register ""Ole32""   , ""IIDFromString"", ""i=pp"", ""r=l""
		|		Wrap.Register ""Version"", 	""GetFileVersionInfoSize"",	""i=sl"", ""r=l""
		|		Wrap.Register ""Version"", 	""GetFileVersionInfo"",	""i=sllp"", ""r=l""
		|		Wrap.Register ""Version"", 	""VerQueryValue"", ""i=pspp"", ""r=l""
		|
		|		hHeap		= Wrap.GetProcessHeap() 
		|		curVers		= GetVersion()	
		|
		|		numGK		= 0
		|		code_len 	= 10
		|		
		|		buf_thiscall= Wrap.HeapAlloc(hHeap, HEAP_ZERO_MEMORY, code_len)
		|		ppv			= Wrap.HeapAlloc(hHeap, HEAP_ZERO_MEMORY, &h20)	'Под внутр. нужды и строки
		|       pIID		= Wrap.HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 32)
		|		swIID		= Wrap.HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 100)
		|
		|		paramArr2	= Wrap.HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 16 * 2 + 4 * (2 + 1) + 4 * 3)	'На 2 параметра
		|		paramArr9	= Wrap.HeapAlloc(hHeap, HEAP_ZERO_MEMORY, 16 * 9 + 4 * (9 + 1) + 4 * 3)	'На 9 параметров
		|       '=======================================================
		|		'Буфер для вызова функций интерфейса
		|		Wrap.VirtualProtect buf_thiscall, code_len, PAGE_EXECUTE_READWRITE, ppv	
		|
		|		Wrap.NumPut &hB9, buf_thiscall, 0, ""b""	'mov ecx, ....   pObj
		|
		|		buf = buf_thiscall + 5
		|		Wrap.NumPut	&hE9, 	buf, 0, ""b""			'jmp ...Addr
		|       '=======================================================
		|       'IUnknown
		|		Wrap.RegisterAddr buf, ""IUnknown_QueryInterface"", 		""i=ppp"", 	""r=l""			'ID 1
		|		Wrap.RegisterAddr buf, ""IUnknown_AddRef"", 				""i=p"", 	""r=l""			'ID 2
		|		Wrap.RegisterAddr buf, ""IUnknown_Release"", 				""i=p"", 	""r=l""			'ID 3
		|
		|		'IContextExtImplBase
		|		Wrap.RegisterAddr buf	, ""ImplBase_getName"", 			""i=pll"", 	""r=l""			'ID getPropName - 5, getMethodName - 10
		|		Wrap.RegisterAddr buf	, ""ImplBase_getN"", 				""i=p"", 	""r=l""			'ID getNProps   - 4, getNMethods - 9
		|		Wrap.RegisterAddr buf	, ""ImplBase_getNParams"", 			""i=pl"", 	""r=l""			'ID 11
		|		Wrap.RegisterAddr buf	, ""ImplBase_hasRetVal"", 			""i=pl"", 	""r=l""			'ID 15
		|		Wrap.RegisterAddr buf	, ""ImplBase_findMethod"", 			""i=pp"", 	""r=l""			'ID 16
		|		Wrap.RegisterAddr buf	, ""ImplBase_getParamDefValue"", 	""i=pllp"", ""r=l""			'ID 14
		|		Wrap.RegisterAddr buf	, ""ImplBase_call"", 				""i=pllp"", ""r=l""			'ID 20
		|		Wrap.RegisterAddr buf_thiscall, ""ImplBase_call_thiscall"", ""i=pllp"", ""r=l""			'ID 20
		|
		|		'IValue
		|		Wrap.RegisterAddr buf_thiscall, ""setIValue"", 				""i=p"", ""r=l""			'ID 1
		|		Wrap.RegisterAddr buf_thiscall, ""getIValue"", 				""i=p"", ""r=l""			'ID 2
		|		Wrap.RegisterAddr buf_thiscall, ""type0"", 					""i=p"", ""r=l""			'ID 7
		|
		|		'ObjectTypeCore
		|		Wrap.RegisterAddr buf, ""getTypeCode"", 					""i=p"", ""r=l""			'ID 4
		|       '=======================================================
		|		handle = Wrap.LoadLibrary(dllName)
		|		'Функция возвращает ГК
		|		Addr1	= Wrap.GetProcAddress(handle, ""?current_process@core@@YAPAVSCOM_Process@1@XZ"")
		|       
		|		Wrap.RegisterAddr	Addr1, ""current_process"", ""r=l""		'core::current_process(void)
		|
		|		'Вот это Глобальный Контекст
		|		pGC 	= Wrap.current_process()					'vt объекта в core82/83
		//|		MsgBox Hex(pGC)
		|
		|       '=======================================================
		|		'CurProc
		|		'Функция из ВТ объекта pGC 
		|		'возвращает какой-то глобальный объект (ГО)		(1)	'vt объекта в backend
		|		'в ВТ 	(1) есть ф-я, возвращающая другой ГО 	(2)	'vt объекта в rclient
		|		'в ВТ 	(2) есть ф-я, возвращающая другой ГО 	(3)	'vt объекта в bsl
		|		'		(3) - содержит массив ГлобальныхКонтекстов IContextExtImplBase
		|
		|		Wrap.RegisterAddr buf, ""GetObjectFromIID"", 				""i=pp"", ""r=l""			'ID 15
		|       
		|		'Функция, получения объектов 
		|		Wrap.RegisterAddr buf, ""GetObj"", 							""i=pp"", ""r=p""
		|		Wrap.RegisterAddr buf, ""GetObj2"", 						""i=p"", ""r=p""
		|
		|		'Получим указатель на глоб. массив ГК
		|       pArray = GetArrayGC()
		|
		|		'Для вывода сообщений
		|		pMes = FindCG_Message()
		|       '=======================================================
		|
		|		adrValue_str	= Wrap.GetProcAddress(handle, ""??0Value@core@@QAE@PB_W@Z"")		'__thiscall core::Value::Value(wchar_t const *)
		|       Wrap.RegisterAddr buf_thiscall, ""Value_str"", 				""i=p"", ""r=l""
		|
		|		adrValue_void	= Wrap.GetProcAddress(handle, ""??0Value@core@@QAE@XZ"")			'__thiscall core::Value::Value(void)	
		|       Wrap.RegisterAddr buf_thiscall, ""Value_void"", 			""r=l""
		|
		|		'Обертка 1C-х объектов в IDispatch
		|		Addr1	= Wrap.GetProcAddress(handle, ""?value_to_dispatch@core@@YA?AV?$InterfacePtr@UIDispatch@@@1@PAVIValue@1@PAVSCOM_ProcessData@1@@Z"")
		|		Wrap.RegisterAddr	Addr1, ""value_to_dispatch"", 			""i=ppl"", ""r=l""
		|
		|		Set Ref = GetRef(""IContextExtImplBase_call"")
		|		newFunc	= Wrap.RegisterCallback(Ref, ""i=pllp"", ""r=l"")
		|		Wrap.VirtualProtect newFunc - 6, 21, PAGE_EXECUTE_READWRITE, ppv	
		|	End Sub
//}		|
//{		|Class_Terminate
		|	Private Sub Class_Terminate
		|		Wrap.HeapFree hHeap, 0, buf_thiscall
		|		Wrap.HeapFree hHeap, 0,	ppv
		|		Wrap.HeapFree hHeap, 0, pIID
		|		Wrap.HeapFree hHeap, 0, swIID
		|
		|		Wrap.HeapFree hHeap, 0, paramArr2
		|		Wrap.HeapFree hHeap, 0, paramArr9
		|
		|		Set Ref	 = Nothing
		|		Set Wrap = Nothing
		//|		MsgBox ""Class_Terminate2""
		|	End Sub
//}		|
//{		|GetString
		|	Private Function GetString(offset)
		|		ppv1 = ppv + offset
		|		ln 		= Wrap.NumGet(ppv1)
		|		If ln > 15 Then
		|   		GetString = Wrap.StrGet(Wrap.NumGet(ppv1, 4) + 8)
		|		Else
		|   		GetString = Wrap.StrGet(ppv1 + 4)
		|		End If
		|	End Function
//}		|
//{		|PutString
		|	Private Function PutString(txt)
		|		'Формируем структуру строки
		|		ln = Len(txt)
		|		If ln > 15 Then
		|			Wrap.NumPut 16, ppv, 0						'Флаг, что строка длиннее 15 символов
		|			Wrap.NumPut (ppv + 16), ppv, 4				'Указатель на начало строки
		|           Wrap.NumPut (ppv + 24) + ln * 2, ppv, 8     'Указатель на 0, за концом строки
		|           Wrap.NumPut 1, ppv, 12      				'Не знаю, что это
		|
		|			Wrap.NumPut 1, ppv, 16						'Это счетчик ссылок на строку
		|			Wrap.NumPut 1, ppv, 20						'Не знаю, что это	
		|		    res = Wrap.MultiByteToWideChar(CP_ACP, 0, txt, -1, ppv + 24, ln)	
		|			Wrap.NumPut 0, ppv, 24 + ln * 2
		|		Else
		|       	Wrap.NumPut ln, ppv, 0
		|			res = Wrap.MultiByteToWideChar(CP_ACP, 0, txt, -1, ppv + 4, ln)	
		|		End If
		|	End Function
//}		|
//{		|GetVersion
        |	Private Function GetVersion()
		|		sz = Wrap.GetFileVersionInfoSize(dllName, 0)	
		|
		|		pbuf		= Wrap.HeapAlloc(hHeap, 0, sz)
		|		lplpBuffer  = Wrap.HeapAlloc(hHeap, 0, 4)
		|		puLen 		= Wrap.HeapAlloc(hHeap, 0, 4)
		|
		|		res1 = Wrap.GetFileVersionInfo(dllName,0, sz, pbuf)
		|		res1 = Wrap.VerQueryValue(pbuf, ""\"",	lplpBuffer, puLen)
		|
		|		VS_FIXEDFILEINFO = Wrap.NumGet(lplpBuffer)
		|       'Младшая часть версии
		|		lpart = Wrap.NumGet(VS_FIXEDFILEINFO, &h0C, ""t"")
		|		'Старшая часть версии
		|		hpart = Wrap.NumGet(VS_FIXEDFILEINFO, &h0E, ""t"")
		|
		//|		GetVersion = CSTR(hpart) & ""."" & CSTR(lpart)
		|		GetVersion 		= hpart
		|
		|		VersPlatform 	= Wrap.NumGet(VS_FIXEDFILEINFO, &h0A, ""t"") * 10
		|		VersPlatform 	= VersPlatform + Wrap.NumGet(VS_FIXEDFILEINFO, &h08, ""t"")
		|
		|		Wrap.HeapFree hHeap, 0, pbuf
		|		Wrap.HeapFree hHeap, 0, lplpBuffer
		|		Wrap.HeapFree hHeap, 0, puLen
		|	End Function
//}		|
//{		|IIDFromString
		|	Private Function IIDFromString(sIDD)	
		|		IIDFromString = Wrap.MultiByteToWideChar(CP_ACP, 0, sIDD, -1, swIID, 100)
		|		IIDFromString = Wrap.IIDFromString(swIID, pIID)
		|	End Function
//}		|
//{		|QueryInterface
		|	Private Function QueryInterface(pObj, sIDD)
		|		QueryInterface 	= E_NOINTERFACE
		|		If IIDFromString(sIDD) = S_OK Then
		|			vfunc pObj, &h0
		|			QueryInterface = Wrap.IUnknown_QueryInterface(pObj, pIID, ppv)
		|		End If 
		|	End Function
//}		|
//{		|GetInterface
		|   Public Function GetInterface(pObj, sIID)
		|		GetInterface = QueryInterface(pObj, sIID)
		|		If GetInterface = S_OK Then
		|			GetInterface = Wrap.NumGet(ppv)	
		|		End If
		|	End Function
//}		|
//{		|vfunc
		|	Public Sub vfunc(pObj, offset)	
		|		Addr = Wrap.NumGet(Wrap.NumGet(pObj), offset)	
		|		Wrap.NumPut	Addr - (buf + 1 + 4), 	buf, 1
		|	End Sub
//}		|
//{		|this_call
		|	Public Sub this_call(ECX, Addr)
		|		Wrap.NumPut ECX, 	buf_thiscall,1
		|		Wrap.NumPut	Addr - (buf + 1 + 4),buf, 1
		|	End Sub
//}		|
//{		|SetParamsCount
		|	Private Function SetParamsCount(pParams, num, cnt)
		|		'Указатели на начало и конец массива указателей на параметры
		|
		|		'Указатель на начало массива указателей на параметры
		|		Wrap.NumPut (pParams + num * 16), pParams, num * 16 + (num + 1) * 4
		|		
		|		'Указатель на конец массива указателей на параметры
		|		Wrap.NumPut (pParams + num * 16 + cnt * 4), pParams, num * 16 + (num + 1) * 4 + 4
		|		Wrap.NumPut (pParams + num * 16 + cnt * 4), pParams, num * 16 + (num + 1) * 4 + 8
		|   End Function
//}		|
//{     |PrepareParams	
		|	Private Function PrepareParams(pParams, num)
		|		'Подготовим параметры, 16 байт на параметр
		|		bsl_off = bsl_off_13
		|
		|       For j = 0 To num - 1 
		|			Wrap.NumPut bsl_off, pParams, j * 16
		|		Next
		|
		|		'Указатели на параметры
		|       For j = 0 To num - 1 
		|			Wrap.NumPut (pParams + j * 16), pParams, num * 16 + j * 4
		|		Next
		|		
		|		'Установим по-умолчанию 2 параметра
		|		SetParamsCount pParams, num, 2
		|	End Function
//}		|
//{     |SetParam
		|	Private Function SetParam(pParams, num, paramType, paramValue, paramValueType)
		|		Wrap.NumPut paramType, 		pParams, (num - 1) * 16 + 4
		|		Wrap.NumPut paramValue, 	pParams, (num - 1) * 16 + 8
		|		Wrap.NumPut paramValueType, pParams, (num - 1) * 16 + 12
		|	End Function
//}     |
//{     |GetParam
		|	Private Function GetParam(pParams, num)
		|		GetParam = Wrap.NumGet(pParams, 8 + num * 16)
		|	End Function
//}     |
//{		|getParamList
        |	Public Function getParamList(pParams, num)
        |		getParamList = pParams + num * 16 + (num + 1) * 4
        |	End Function
//}		|
//{     |getType
		|	Public Function	getType(pIValue)
		|		Addr = Wrap.NumGet(Wrap.NumGet(pIValue), (7 - 1) * 4)
		|		this_call pIValue, Addr
		|		res  = Wrap.type0(ppv + 8)
		|
		|		pObjTypeCore = Wrap.NumGet(ppv + 8)
		|       vfunc pObjTypeCore, (4 - 1) * 4
		|		getType = Wrap.getTypeCode(pObjTypeCore)
		//|		MsgBox getType
		|	End Function
//}     |
//{     |getIValue
		|	Private Function	getIValue(pValue)
		|		Addr 		= Wrap.NumGet(Wrap.NumGet(pValue), (2 - 1) * 4)
		|
		|		this_call pValue, Addr
		|		res  		= Wrap.getIValue(ppv + 8)
		|		getIValue 	= Wrap.NumGet(ppv + 8)
		|	End Function
//}     |
//{     |setIValue
		|	Private Function	setIValue(pIValue, pValue)
		|		Addr 		= Wrap.NumGet(Wrap.NumGet(pIValue), (1 - 1) * 4)
		|
		|		this_call pIValue, Addr
		|		setIValue	= Wrap.setIValue(pValue)
		|	End Function
//}     |
//{		|Message
		|	Public Function Message(txt)
		|		'1-й параметр, строка
		|       '=======================================================	
		|		this_call ppv, adrValue_str
		|		res 	= Wrap.Value_str(txt)
		|		IValue 	= getIValue(ppv)
		|		res 	= SetParam (paramArr2, 1, 0, IValue, 4)
		|
		|		'2-й параметр, перечисление
		|		'=======================================================		
		|		this_call ppv, adrValue_void
		|		res 	= Wrap.Value_void()
		|
		|		vfunc pMes, 4 * (14 - 1)
		|		res 	= Wrap.ImplBase_getParamDefValue(pMes, numMes, 1, ppv)
		|		IValue 	= getIValue(ppv)
		|		res		= SetParam(paramArr2, 2, 0, IValue, 0)
		|
		|		SetParamsCount paramArr2, 2, 2
		|       '=======================================================		
		|		vtable 	= Wrap.NumGet(pMes)
		|		Addr 	= Wrap.NumGet(vtable, 4 * (20 - 1))
		|
		|		this_call numMes, Addr
		|		Wrap.ImplBase_call_thiscall pMes, numMes, 0, getParamList(paramArr2, 2)
		|	End Function
//}		|
//{		|PrepareDefParams
		|Public Function PrepareDefParams(pIContext, numFunc)	
		|		PrepareDefParams = -1	
		|
		|		vfunc pIContext, 4 * (11 - 1)
		|		NParams = Wrap.ImplBase_getNParams(pIContext, numFunc)
		|				
		|      	If (NParams = 0) OR (NParams > 9)  Then
		|			Exit Function
		|		End If
		|
		|		j = 0
		|		Do While j < NParams
		|			this_call ppv, adrValue_void
		|			res 	= Wrap.Value_void()
		|
		|			vfunc pIContext, 4 * (14 - 1)
		|			res 		= Wrap.ImplBase_getParamDefValue(pIContext, numFunc, j, ppv)
		|			If res <> S_OK Then
		|				PrepareDefParams = -1
		|				Exit Do
		|			End If
		|			IValue 		= getIValue(ppv)
		|			typeCode 	= getType(ppv)
		|			res 		= SetParam(paramArr9, j + 1, 0, IValue, typeCode)
		|			j 			= j + 1
		|		Loop
		|		If PrepareDefParams = -1 Then
		|			Exit Function
		|		End If
		|
		|		SetParamsCount paramArr9, 9, NParams
		|
		|		this_call ppv, adrValue_void
		|		res 	= Wrap.Value_void()
		|
		|		vfunc	 pIContext, 4 * (20 - 1)
		|   	PrepareDefParams = getParamList(paramArr9, 9)
		|	End Function
//}		|
//{		|RetValueImplBase
		|	Public Function RetValueImplBase()
		|		pCont			= getIValue(ppv)
		|		pValueImplBase 	= GetInterface(pCont, IID_IValueImplBase)
		|
		|		res		 		= Wrap.value_to_dispatch(ppv, pValueImplBase, 0)
		|      	pDisp	 		= Wrap.NumGet(ppv)
		|			
		|		'Уменьшим счетчик ссылок (незаконно - не через Release), иначе повиснет ссылка и 1С не закроется
		|		res 	 		= Wrap.NumGet(pDisp, 8)
		|		res 	 		= Wrap.NumPut(res - 1, pDisp, 8)
		|
		|		Set RetValueImplBase = Wrap.GetObject(pDisp)
		|	End Function
//}		|
//{		|HookOn
        |	Public Function HookOn()
		|		vtable = Wrap.NumGet(pMes)
		|		Wrap.VirtualProtect vtable + (20 - 1) * 4, 4, PAGE_EXECUTE_READWRITE, ppv
		|		oldFunc = Wrap.NumGet(vtable, (20 - 1) * 4)
		|		Wrap.NumPut newFunc, vtable,(20 - 1) * 4 
		|	End Function	
//}     |
//{		|HookOff
        |	Public Function HookOff()
		|		vtable = Wrap.NumGet(pMes)
		|		Wrap.NumPut oldFunc, vtable,(20 - 1) * 4 
		|		Wrap.VirtualProtect vtable + (20 - 1) * 4, 4, PAGE_EXECUTE_READ, ppv
		|
		|		PrepareParams paramArr2, 2
		|		PrepareParams paramArr9, 9
		|	End Function	
//}     |
		|End Class
//}		|
		|Set oServ = New Service 
		|";
	
	Возврат ТекстМодуля;	
КонецФункции

Функция Funcs()
	ТекстМодуля = "
//{		|getN
		|Public Function getN(pIContext, nfunc)
		|	getN = 0
		|	If pIContext <> 0 Then
		|		oServ.vfunc pIContext, 4 * (nfunc - 1)	
		|		getN = Wrap.ImplBase_getN(pIContext)
		|	End If
	    |End Function
//}		|
//{		|ImplBase_getN
		|Public Function ImplBase_getN(Obj, nfunc)
		|	ImplBase_getN = 0
		|   If VarType(Obj) = VT_BSTR Then
		|		For j = 0 To oServ.numGK
		|       	pIContext 		= Wrap.NumGet(oServ.pArray, j * 4)    	
		|			ImplBase_getN 	= ImplBase_getN + getN(pIContext, nfunc)
		|		Next	
		|	Else
		|		pObj	  = Wrap.GetIDispatch(Obj)
		|		pIContext = Wrap.NumGet(pObj, platform_offset)
		|
		//|		If pIContext <> 0 Then
		//|			oServ.Message Hex(pIContext)
		//|			oServ.Message Hex(Wrap.NumGet(pIContext))
		//|		End If
		|
		|		ImplBase_getN 	= getN(pIContext, nfunc)
		|	End if
		|End Function
//}		|
//{		|ImplBase_getName
		|Public Function ImplBase_getName(pIContext, num, nfunc)
		|	ImplBase_getName = 0
		|	If pIContext <> 0 Then
		|		j = 1
		|		Do While j > -1
		|			oServ.vfunc pIContext, 4 * (nfunc - 1)	
		|			pbstrName = Wrap.ImplBase_getName(pIContext, num, j)
		|
		|			If (pbstrName <> 0) Then
		|				If Wrap.StrGet(pbstrName) <> """"  Then
		|					ImplBase_getName = pbstrName	
		|					Exit Do
		|		    	End If
		|			End If
		|			j = j - 1
		|       Loop
		|	End If
		|End Function
//}		|
//{		|valFill
		|Public Function valFill(pIContext, num, valTable, nfunc, ContID)
		|	For j = 0 To num - 1
		|		pStr = ImplBase_getName(pIContext, j, nfunc)
		|		If (pStr <> 0) Then
		|			Set nRow 	= valTable.Add()
		|			nRow.Name	= Wrap.StrGet(pStr)	
		|
		|			oServ.vfunc pIContext, 4 * (15 - 1)
		|			nRow.Val	 = Wrap.ImplBase_hasRetVal(pIContext, j)
		|
		|			oServ.vfunc pIContext, 4 * (11 - 1)
		|           nRow.NParams  = Wrap.ImplBase_getNParams(pIContext, j)
		|			nRow.ID		  = j
		|			nRow.ContID	  = ContID
		|		End If
		|	Next
		|End Function
//}		|
//{		|Fill
		|Public Function Fill(Obj, valTable, nfunc)
		|	Fill = 0
		|
		|   If VarType(Obj) = VT_BSTR Then
		|		For j = 0 To oServ.numGK
		|       	pIContext 	= Wrap.NumGet(oServ.pArray, j * 4)    	
		|			num 		= getN(pIContext, nfunc - 1)
		|			Fill 		= Fill + num
		|			valFill pIContext, num, valTable, nfunc, j
		|		Next	
		|	Else
		|		pObj	  = Wrap.GetIDispatch(Obj)
		|		pIContext = Wrap.NumGet(pObj, platform_offset)
		|
		|		Fill 	  = getN(pIContext, nfunc - 1)
		|		valFill pIContext, Fill, valTable, nfunc, 0
		|	End if
		|End Function
//}		|
//{		|GetContext
		|Public Function GetContext(Obj, numCont)
		|	If VarType(Obj) = VT_BSTR Then
		|		GetContext 	= Wrap.NumGet(oServ.pArray, numCont * 4)
		|	Else
		|		pObj	  = Wrap.GetIDispatch(Obj)
		|		GetContext = Wrap.NumGet(pObj, platform_offset)
		|	End If
		|End Function
//}		|
//{		|PrepareDefParams
		|Public Function PrepareDefParams(Obj, numFunc, numCont)
		|	pIContext 			= GetContext(Obj, numCont)
		|	PrepareDefParams 	= oServ.PrepareDefParams(pIContext, numFunc)
		|End Function
//}		|
//{		|RetValueImplBase
		|Public Function RetValueImplBase()
		|	Set RetValueImplBase = oServ.RetValueImplBase()
		|End Function
//}		|
//{		|GetIContext
		|Public Function GetIContext(Obj) 
		|	GetIContext = """"
		|	pObj	    = GetContext(Obj, 0)
		|	If 	pObj <> 0 Then	
		|		GetIContext = Hex(pObj)
		|	End If
		|End Function
//}		|
//{		|GetVT
		|Public Function GetVT(Obj) 
		|	GetVT = """"
		|	pObj  = GetContext(Obj, 0)
		|	If 	pObj <> 0 Then
		|		GetVT = Hex(Wrap.NumGet(pObj))
		|	End If
		|End Function
//}		|
//{     |IContextExtImplBase_call
		|Public Function IContextExtImplBase_call(pIContext, numMeth, paramOut, ppArrayParIn)
		|	If bsl_off_13 = 0 Then
		|		pFirst 		= Wrap.NumGet(ppArrayParIn)
		|		bsl_off_13 	= Wrap.NumGet(Wrap.NumGet(pFirst))
		|	End If	
		|End Function
//}		|
		|";

	Возврат ТекстМодуля;
КонецФункции

Функция ПолучитьОписаниеОбъектаИнформатором(Объект, ТЗ, Флаг)
	
	ИнициализацияСкриптаИнформатора();
	Попытка
		Рез = ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ_И_МЕТОДОВ; //0
		If Флаг = ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ_И_МЕТОДОВ Then //0
			Рез = ScrptCtrl.Run("ImplBase_getN",Объект, 4);
			Рез = Рез + ScrptCtrl.Run("ImplBase_getN", Объект, 9);
		ElsIf Флаг = ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ Then //1
			Рез = ScrptCtrl.Run("ImplBase_getN",Объект, 4);
		ElsIf Флаг = ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_МЕТОДОВ Then //2
			Рез = ScrptCtrl.Run("ImplBase_getN", Объект, 9);
		Else
			ТЗ = Новый ТаблицаЗначений;
			ТЗ.Колонки.Добавить("Name");
			ТЗ.Колонки.Добавить("Type");
			ТЗ.Колонки.Добавить("Val");
			ТЗ.Колонки.Добавить("NParams");
			ТЗ.Колонки.Добавить("ID");
			ТЗ.Колонки.Добавить("ContID");
			If Флаг = ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_СВОЙСТВА Then //3
				ScrptCtrl.Run("Fill", Объект, ТЗ, 5);
			Else
				ScrptCtrl.Run("Fill", Объект, ТЗ, 10);
			EndIf; 
		EndIf; 
	Исключение
		Сообщить(ОписаниеОшибки());
	КонецПопытки; 
	Возврат Рез;
	
КонецФункции

Процедура ИнициализацияСкриптаИнформатора() //Экспорт
	
	If ТипЗнч(ScrptCtrl) <> Тип("Неопределено") Then
		Возврат;
	EndIf;	
	
	ТекстМодуля = Public_Consts();
	ТекстМодуля = ТекстМодуля + Public_Vars();
	ТекстМодуля = ТекстМодуля + Class_Service();
	ТекстМодуля = ТекстМодуля + Funcs();
	
	ScrptCtrl          	= Новый COMОбъект("MSScriptControl.ScriptControl");
	ScrptCtrl.Language 	= "vbscript";
	ScrptCtrl.TimeOut	= -1;
	
	Попытка
		ScrptCtrl.AddCode(ТекстМодуля);	
	Исключение
		Сообщить(ScrptCtrl.Error.Description);
		Сообщить(ScrptCtrl.Error.Source);
		Сообщить(ScrptCtrl.Error.Text);
		Сообщить(ScrptCtrl.Error.Line);
	КонецПопытки;
	ScrptCtrl.Eval("oServ.HookOn");
	Сообщить(1);
	ScrptCtrl.Eval("oServ.HookOff");
	
	//Для вычисления значения функций
	buf = ScrptCtrl.Eval("oServ.buf");
	ppv = ScrptCtrl.Eval("oServ.ppv");	
	WinAPI.RegisterAddr(buf, "ImplBase_call", "i=pllp", "r=l");	//ID 20 // Было закомментировано
	
КонецПроцедуры

// ТипСлов - Строка - "Свойство" или "Метод"
Функция ПолучитьТаблицуСвойствОбъектаИнформатором(Объект, ТипСлов = "Свойство", НеопределеноСчитатьГлобальнымКонтекстом = Истина) Экспорт
	
	Перем ТЗ;
	Если Ложь
		//Или ВерсияПлатформы > 803001 // На 8.3.2 информатор падает
		//Или ВерсияПлатформы >= 802018 // На 8.2.18 информатор падает
		Или Не ЛиНизкоуровневоеПолучениеОписанийОбъектов
	Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли; 
	Если Объект = Неопределено Тогда
		Объект = СТРОКА_ГЛОБАЛЬНЫЙ_КОНТЕКСТ;
	КонецЕсли;
	Флаг = ?(НРег(ТипСлов) = НРег("Свойство"),
		ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_СВОЙСТВА,
		ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_МЕТОДЫ);
	ПолучитьОписаниеОбъектаИнформатором(Объект, ТЗ, Флаг);
	Возврат ТЗ;
	
КонецФункции

#КонецЕсли

#Если Клиент Тогда
Контейнер = Новый Структура();
Оповестить("ирПолучитьБазовуюФорму", Контейнер);
Если Не Контейнер.Свойство("ирМобильный", ирМобильный) Тогда
	ПолноеИмяФайлаБазовогоМодуля = ВосстановитьЗначение("ирПолноеИмяФайлаОсновногоМодуля");
	ирМобильный = ВнешниеОбработки.ПолучитьФорму(ПолноеИмяФайлаБазовогоМодуля);
КонецЕсли; 
ирОбщий = ирМобильный.ПолучитьОбщийМодульЛкс("ирОбщий");
ирКэш = ирМобильный.ПолучитьОбщийМодульЛкс("ирКэш");
ирСервер = ирМобильный.ПолучитьОбщийМодульЛкс("ирСервер");
ирПривилегированный = ирМобильный.ПолучитьОбщийМодульЛкс("ирПривилегированный");
#КонецЕсли

ИМЯ_КЛАССА_DynamicWrapperX = "DynamicWrapperX";
СТРОКА_ГЛОБАЛЬНЫЙ_КОНТЕКСТ = "ГлобальныйКонтекст";
ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ_И_МЕТОДОВ = 0;
ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_СВОЙСТВ = 1;
ФЛАГ_ЗАПОЛНЕНИЯ_ПРОВЕРИТЬ_СУЩЕСТВОВАНИЕ_МЕТОДОВ = 2;
ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_СВОЙСТВА = 3;
ФЛАГ_ЗАПОЛНЕНИЯ_ЗАПОЛНИТЬ_МЕТОДЫ = 4;

// Информатор. Конец
///////////////////////////////////////////////////////////////////

ИнициализацияОписанияПараметровИТипов();
мМетаданные = Метаданные;
ОбъектыМДПоПолномуИмени = Новый Соответствие;
КэшОбъектов = Новый Соответствие;
мКэшПустыхЗначений = Новый Соответствие;
СисИнфо = Новый СистемнаяИнформация;
МассивФрагментов = ирОбщий.ПолучитьМассивИзСтрокиСРазделителемЛкс(СисИнфо.ВерсияПриложения);
ВерсияПлатформы = Число(МассивФрагментов[0]) * 100 * 1000 + Число(МассивФрагментов[1]) * 1000 + Число(МассивФрагментов[2]);
ИДВерсииПлатформы = ПолучитьИДВерсииПлатформы(СисИнфо);
Это2iS = Метаданные.ОбщиеМодули.Найти("Ядро2iS") <> Неопределено;
ЭтоИнтеграция = Метаданные.Справочники.Найти("иисМетаданные") <> Неопределено;
МаркерНачалаАлгоритма = "//НАЧАЛО.СЕРВИС" + Символы.ПС;
МаркерКонцаАлгоритма  = "//КОНЕЦ_.СЕРВИС" + Символы.ПС;

//шБуква = "_ЁА-Яёа-яA-Za-z";
шБуква = "_ЁА-ЯA-Z";
шКомментарий = "//[^\n]*\n"; 
шРазделитель = "(?:" + шКомментарий + "|\s|^|$)";
шGUID = "[A-F0-9]{8}(?:-[A-F0-9]{4}){3}-[A-Z0-9]{12}";
шЧисло = "\d+(\.\d+)?";
шИндекс = "(\[[^\]\[]+?(?:(?:\[[^\]]+?\][^\]\[]*?)*)*\])";

//шСкобки = "(\([^\)\(]*?(?:(?:\([^\)]*?\)[^\)\(]*?)*)*\))";
  шСкобки = "(\([^\(\)]*(?:\([^\(\)]*\)[^\(\)]*)*\))";
шИмя = "[" + шБуква + "][" + шБуква + "\d]*";

VBRegExp = ПолучитьНовыйВычислительРегулярныхВыражений(Истина);
ВложенностьИндикации = 0;

ИмяКластераСерверов = НСтр(СтрокаСоединенияИнформационнойБазы(), "Srvr");
ЭтоФайловаяБаза = ПустаяСтрока(ИмяКластераСерверов);


WshShell = Новый COMОбъект("WScript.Shell");
//JavaScript = Новый COMОбъект("MSScriptControl.ScriptControl");
//JavaScript.Language = "javascript";
//ВремяОбъект = JavaScript.Eval("new Date()");
АрхитектураПроцессора = WshShell.Environment("SYSTEM").item("PROCESSOR_ARCHITECTURE");

#Если Клиент Тогда
ФиксироватьВнешниеИсключенияАлгоритмов = ВосстановитьЗначение("ирПлатформа.ФиксироватьВнешниеИсключенияАлгоритмов");
#КонецЕсли 
Если ФиксироватьВнешниеИсключенияАлгоритмов = Неопределено Тогда
	ФиксироватьВнешниеИсключенияАлгоритмов = Истина;
КонецЕсли;

#Если Клиент Тогда
ФайловыйКэшАлгоритмовДопускаетРедактирование = ВосстановитьЗначение("ирПлатформа.ФайловыйКэшАлгоритмовДопускаетРедактирование");
#КонецЕсли 
Если ФайловыйКэшАлгоритмовДопускаетРедактирование = Неопределено Тогда
	ФайловыйКэшАлгоритмовДопускаетРедактирование = Ложь;
КонецЕсли;

#Если Клиент Тогда
МаскироватьФайловыйКэш = ВосстановитьЗначение("ирПлатформа.МаскироватьФайловыйКэш");
#КонецЕсли 
Если МаскироватьФайловыйКэш = Неопределено Тогда
	МаскироватьФайловыйКэш = Ложь;
КонецЕсли;
	
#Если Клиент Тогда
ВыполнятьАлгоритмыЧерезВнешниеОбработки = ВосстановитьЗначение("ирПлатформа.ВыполнятьАлгоритмыЧерезВнешниеОбработки");
#КонецЕсли 
Если ВыполнятьАлгоритмыЧерезВнешниеОбработки = Неопределено Тогда
	// Антибаг http://partners.v8.1c.ru/forum/thread.jsp?id=861032#861032
	ВыполнятьАлгоритмыЧерезВнешниеОбработки = Ложь;
КонецЕсли;

#Если Клиент Тогда
ЛиНизкоуровневоеПолучениеОписанийОбъектов = ВосстановитьЗначение("ирПлатформа.ЛиНизкоуровневоеПолучениеОписанийОбъектов");
#КонецЕсли 
Если ЛиНизкоуровневоеПолучениеОписанийОбъектов = Неопределено Тогда
	ЛиНизкоуровневоеПолучениеОписанийОбъектов = Истина;
КонецЕсли;

Парсеры = Новый Структура;
ШаблоныВнешнейОбработки = Новый Соответствие;
ШаблоныВнешнейОбработкиСМакетом = Новый Соответствие;
ПроверитьСтруктуруФайловогоКэша();
ИмяФайлаПакера = "v8unpack.exe";
WinAPI = "НеИнициализирован";
ПолучитьWinAPI();

#Если Клиент Тогда
COMНавигатор = "НеИнициализирован";

ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов = ВосстановитьЗначение("ирПлатформа.ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов");
Если ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов = Неопределено Тогда
	ПоказыватьВнешниеИсключенияПриВыполненииАлгоритмов = Ложь;
КонецЕсли;

СинтаксическийКонтрольПередЗаписью = ВосстановитьЗначение("ирПлатформа.СинтаксическийКонтрольПередЗаписью");
Если СинтаксическийКонтрольПередЗаписью = Неопределено Тогда
	СинтаксическийКонтрольПередЗаписью = Истина;
КонецЕсли;

ТаблицаСтатистикиВыбора = ВосстановитьЗначение("ирПлатформа.ТаблицаСтатистикиВыбора");
Если ТаблицаСтатистикиВыбора = Неопределено Тогда
	ТаблицаСтатистикиВыбора = Новый ТаблицаЗначений;
	ТаблицаСтатистикиВыбора.Колонки.Добавить("ТипКонтекста");
	ТаблицаСтатистикиВыбора.Колонки.Добавить("Слово");
	ТаблицаСтатистикиВыбора.Колонки.Добавить("Рейтинг", Новый ОписаниеТипов("Число"));
КонецЕсли;

ОтложенноеОткрытиеИсточникаОшибки = Новый ТаблицаЗначений;
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("АлгоритмОбъект");
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("ИнформацияОбОшибке");
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("РежимВыполнения");
ОтложенноеОткрытиеИсточникаОшибки.Колонки.Добавить("Смещение", Новый ОписаниеТипов("Число"));

СлужебнаяФорма = ПолучитьФорму("Служебная");
СлужебноеПолеТекстовогоДокумента = СлужебнаяФорма.ЭлементыФормы.Добавить(Тип("ПолеТекстовогоДокумента"), "СлужебноеПолеТекстовогоДокумента", Ложь);
СлужебноеПолеHtmlДокумента = СлужебнаяФорма.ЭлементыФормы.Добавить(Тип("ПолеHTMLДокумента"), "СлужебноеПолеHTMLДокумента", Ложь);


МассивОбычныхЭлементовУправления = Новый Массив;
МассивОбычныхЭлементовУправления.Добавить("Диаграмма"); 
МассивОбычныхЭлементовУправления.Добавить("ДиаграммаГанта"); 
МассивОбычныхЭлементовУправления.Добавить("Дендрограмма"); 
МассивОбычныхЭлементовУправления.Добавить("Индикатор"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеКалендаря"); 
МассивОбычныхЭлементовУправления.Добавить("Кнопка"); 
МассивОбычныхЭлементовУправления.Добавить("КолонкаТабличногоПоля"); // Возможно что то сломается. Добавил для возможности автоопределения объекта системы
МассивОбычныхЭлементовУправления.Добавить("КоманднаяПанель"); 
МассивОбычныхЭлементовУправления.Добавить("Надпись"); 
МассивОбычныхЭлементовУправления.Добавить("Панель"); 
МассивОбычныхЭлементовУправления.Добавить("Переключатель"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеГрафическойСхемы"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеГеографическойСхемы");
МассивОбычныхЭлементовУправления.Добавить("ПолеТабличногоДокумента"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеHTMLДокумента"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеТекстовогоДокумента"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеВвода"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеВыбора"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеСписка"); 
МассивОбычныхЭлементовУправления.Добавить("ПолеКартинки"); 
МассивОбычныхЭлементовУправления.Добавить("ПолосаРегулирования"); 
МассивОбычныхЭлементовУправления.Добавить("Разделитель"); 
МассивОбычныхЭлементовУправления.Добавить("РамкаГруппы"); 
МассивОбычныхЭлементовУправления.Добавить("СводнаяДиаграмма"); 
МассивОбычныхЭлементовУправления.Добавить("СтраницаПанели");  // Возможно что то сломается. Добавил для возможности автоопределения объекта системы
МассивОбычныхЭлементовУправления.Добавить("ТабличноеПоле"); 
МассивОбычныхЭлементовУправления.Добавить("Флажок"); 

мМассивТиповЭлементовУправления = Новый Массив;
Для Каждого ИмяТипа Из МассивОбычныхЭлементовУправления Цикл
	мМассивТиповЭлементовУправления.Добавить(Тип(ИмяТипа));
КонецЦикла;
СодержанияАрхивовСправки = Новый Соответствие;
ИндексыАрхивовСправки = Новый Соответствие;

#КонецЕсли

МассивУправляемыхЭлементовУправления = Новый Массив;
МассивУправляемыхЭлементовУправления.Добавить("ПолеФормы"); 
МассивУправляемыхЭлементовУправления.Добавить("КнопкаФормы"); 
МассивУправляемыхЭлементовУправления.Добавить("ТаблицаФормы"); 
МассивУправляемыхЭлементовУправления.Добавить("ГруппаФормы"); 
МассивУправляемыхЭлементовУправления.Добавить("ДекорацияФормы"); 

мМассивТиповВключающихМетаданные = Новый Массив;
мМассивТиповВключающихМетаданные.Добавить(Тип("ОбъектМетаданных"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Структура"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ТаблицаЗначений"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ДеревоЗначений"));
мМассивТиповВключающихМетаданные.Добавить(Тип("РезультатЗапроса"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Отбор"));
мМассивТиповВключающихМетаданные.Добавить(Тип("НастройкаОформления"));
мМассивТиповВключающихМетаданные.Добавить(Тип("COMОбъект"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ОбъектXDTO"));
мМассивТиповВключающихМетаданные.Добавить(Тип("СвойствоXDTO"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ОбщийМодуль"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ПостроительЗапроса"));
#Если Клиент Тогда
мМассивТиповВключающихМетаданные.Добавить(Тип("ТабличноеПоле"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Панель"));
мМассивТиповВключающихМетаданные.Добавить(Тип("КнопкаКоманднойПанели"));
мМассивТиповВключающихМетаданные.Добавить(Тип("КоманднаяПанель"));
мМассивТиповВключающихМетаданные.Добавить(Тип("Форма"));
мМассивТиповВключающихМетаданные.Добавить(Тип("УправляемаяФорма"));
мМассивТиповВключающихМетаданные.Добавить(Тип("ПолеВвода"));
#КонецЕсли

мТаблицаСтруктурТипа = Новый ТаблицаЗначений;
мТаблицаСтруктурТипа.Колонки.Добавить("ИмяОбщегоТипа", Новый ОписаниеТипов("Строка"));
мТаблицаСтруктурТипа.Колонки.Добавить("Метаданные");
мТаблицаСтруктурТипа.Колонки.Добавить("СтрокаОписания");
мТаблицаСтруктурТипа.Колонки.Добавить("ТипЯзыка", Новый ОписаниеТипов("Строка"));
мТаблицаСтруктурТипа.Колонки.Добавить("ВиртуальнаяТаблица");
мТаблицаСтруктурТипа.Колонки.Добавить("Конструктор", Новый  ОписаниеТипов("Булево"));
мТаблицаСтруктурТипа.Колонки.Добавить("ДополнительныеТипы");
мТаблицаСтруктурТипа.Колонки.Добавить("ДержательМетаданных");

//#Если Клиент Или ВнешнееСоединение Тогда

СубПутьКФайлуПотокаМодуляВнешнейОбработки    = "1ad4dbd4-e136-4202-8121-02c33ad2af45.0.data.und.unp\text.data";
СубПутьКФайлуПотокаМакетаВнешнейОбработки    = "902f74d3-f929-4b0f-8719-4cbb655891aa.0.data.und";
СубПутьКФайлуПотокаЗаголовкаВнешнейОбработки = "4eb1cc18-835d-4f8c-a120-3f9d886d75d4.data.und";
СубПутьККонтрольномуФайлуВнешнейОбработки    = "1ad4dbd4-e136-4202-8121-02c33ad2af45.0.data";

//КешВнешнихОбработокАлгоритмов = Новый Структура;

КешАлгоритмов = Новый Структура;

ТаблицаТиповМетаОбъектов = ПолучитьТаблицуТиповМетаОбъектов();
ТаблицаТиповМетаОбъектов.Индексы.Добавить("Единственное,  Категория");
ТаблицаТиповМетаОбъектов.Индексы.Добавить("Множественное, Категория");

МакетыКомпонент = Новый Структура;

МаркерКоллекцииОбъектовМетаданных = "КоллекцияОбъектовМетаданных";
МаркерОбъектаМетаданных = "ОбъектМетаданных";
МаркерCOMОбъекта = "COMОбъект";

МассивИсключенийИменКоллекций = Новый СписокЗначений;
МассивИсключенийИменКоллекций.Добавить("Свойства");
МассивИсключенийИменКоллекций.Добавить("Методы");
МассивИсключенийИменКоллекций.Добавить("");

СоответствиеВидовСравнения = Новый ТаблицаЗначений;
СоответствиеВидовСравнения.Колонки.Добавить("Построитель");
СоответствиеВидовСравнения.Колонки.Добавить("Компоновка");
СоответствиеВидовСравнения.Колонки.Добавить("Имя");
СоответствиеВидовСравнения.Индексы.Добавить("Построитель");
СоответствиеВидовСравнения.Индексы.Добавить("Компоновка");
//Интервал
//ИнтервалВключаяГраницы
//ИнтервалВключаяНачало
//ИнтервалВключаяОкончание
СоответствиеВидовСравнения.Добавить().Имя = "Больше";
СоответствиеВидовСравнения.Добавить().Имя = "БольшеИлиРавно";
СоответствиеВидовСравнения.Добавить().Имя = "ВИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "ВСписке";
СоответствиеВидовСравнения.Добавить().Имя = "ВСпискеПоИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "Меньше";
СоответствиеВидовСравнения.Добавить().Имя = "МеньшеИлиРавно";
СоответствиеВидовСравнения.Добавить().Имя = "НеВИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "НеВСписке";
СоответствиеВидовСравнения.Добавить().Имя = "НеВСпискеПоИерархии";
СоответствиеВидовСравнения.Добавить().Имя = "НеРавно";
СоответствиеВидовСравнения.Добавить().Имя = "НеСодержит";
СоответствиеВидовСравнения.Добавить().Имя = "Равно";
СоответствиеВидовСравнения.Добавить().Имя = "Содержит";
Для Каждого СтрокаСоответствия Из СоответствиеВидовСравнения Цикл
	СтрокаСоответствия.Построитель = Вычислить("ВидСравнения." + СтрокаСоответствия.Имя);
	СтрокаСоответствия.Компоновка  = Вычислить("ВидСравненияКомпоновкиДанных." + СтрокаСоответствия.Имя);
КонецЦикла;

мТаблицаЗамеров = Новый ТаблицаЗначений;
мТаблицаЗамеров.Колонки.Добавить("_0");
мТаблицаЗамеров.Колонки.Добавить("Ключ");
мТаблицаЗамеров.Колонки.Добавить("ДатаНачала");
мТаблицаЗамеров.Колонки.Добавить("Отладчик", Новый ОписаниеТипов("Булево"));
мТаблицаЗамеров.Колонки.Добавить("КоличествоПроходов", Новый ОписаниеТипов("Число"));

мТаблицаИндикаторов = Новый ТаблицаЗначений;
мТаблицаИндикаторов.Колонки.Добавить("КоличествоПроходов", Новый ОписаниеТипов("Число"));
мТаблицаИндикаторов.Колонки.Добавить("ПредставлениеПроцесса", Новый ОписаниеТипов("Строка"));
мТаблицаИндикаторов.Колонки.Добавить("ЛиВыводитьВремя", Новый ОписаниеТипов("Булево"));
мТаблицаИндикаторов.Колонки.Добавить("РазрешитьПрерывание", Новый ОписаниеТипов("Булево"));
мТаблицаИндикаторов.Колонки.Добавить("ДатаНачалаПроцесса", Новый ОписаниеТипов("Дата"));
мТаблицаИндикаторов.Колонки.Добавить("МинимальныйПериодОбновления", Новый ОписаниеТипов("Число"));
мТаблицаИндикаторов.Колонки.Добавить("ДатаСледующегоОбновления", Новый ОписаниеТипов("Дата"));
мТаблицаИндикаторов.Колонки.Добавить("Шаг", Новый ОписаниеТипов("Число"));
мТаблицаИндикаторов.Колонки.Добавить("ТекстСостояния", Новый ОписаниеТипов("Строка"));
мТаблицаИндикаторов.Колонки.Добавить("СледующийСчетчик", Новый ОписаниеТипов("Число"));
мТаблицаИндикаторов.Колонки.Добавить("Счетчик", Новый ОписаниеТипов("Число"));

//#КонецЕсли
RegExp = ПолучитьНовыйВычислительРегулярныхВыражений();
RegExp.IgnoreCase = Истина;
RegExp.MultiLine = Ложь;

RegExp2 = ПолучитьНовыйВычислительРегулярныхВыражений();
RegExp2.IgnoreCase = Истина;
RegExp2.MultiLine = Ложь;

мИменаОсновныхКлассовБиблиотекCOM = Новый Соответствие;
мОбразцыCOMОбъектов = Новый Соответствие;
БуферСравнения = Новый Массив();
